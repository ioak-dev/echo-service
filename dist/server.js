/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./env.js":
/*!****************!*\
  !*** ./env.js ***!
  \****************/
/***/ ((module) => {

module.exports = {
    CHATGPT_API_KEY:
        process.env.CHATGPT_API_KEY ||
        "sk-proj-ypujYZvr1RDkmp3ZlUmtT3BlbkFJdRbWD9cvaKJiXbZ3OZ6Z",
    GEMINI_API_KEY:
        process.env.GEMINI_API_KEY || "AIzaSyAq1gQekrycyU0wp5n9IFIMKMZktO_rX68",
};

/***/ }),

/***/ "./src/handler.ts":
/*!************************!*\
  !*** ./src/handler.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncHandler = void 0;
var asyncHandler = function (fn) { return function (req, res, next) {
    return Promise.resolve(fn(req, res, next)).catch(next);
}; };
exports.asyncHandler = asyncHandler;


/***/ }),

/***/ "./src/lib/DateUtils.ts":
/*!******************************!*\
  !*** ./src/lib/DateUtils.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatDateText = exports.FORMAT_MONTH_AND_YEAR = exports.FORMAT_FULL_DATE = void 0;
var moment_1 = __importDefault(__webpack_require__(/*! moment */ "moment"));
exports.FORMAT_FULL_DATE = "Do MMM YYYY";
exports.FORMAT_MONTH_AND_YEAR = "MMMM YYYY";
var formatDateText = function (dateText, format) {
    if (dateText) {
        var date = (0, moment_1.default)(dateText, 'YYYY-MM-DDTHH:mm:ssZ');
        return date.format(format);
    }
    return "";
};
exports.formatDateText = formatDateText;


/***/ }),

/***/ "./src/lib/Utils.ts":
/*!**************************!*\
  !*** ./src/lib/Utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmptyOrSpaces = isEmptyOrSpaces;
exports.isEmptyAttributes = isEmptyAttributes;
exports.match = match;
exports.sort = sort;
exports.htmlToText = htmlToText;
function isEmptyOrSpaces(str) {
    return !str || str.match(/^ *$/) !== null;
}
function isEmptyAttributes(object) {
    if (!object) {
        return true;
    }
    return !Object.keys(object).find(function (key) {
        if (object[key]) {
            return true;
        }
        return false;
    });
}
function match(text, words) {
    var found = false;
    if (words) {
        words.split(' ').forEach(function (word) {
            if (text.toString().match(new RegExp("(\\w*".concat(word, "\\w*)"), 'gi'))) {
                found = true;
            }
        });
    }
    return found;
}
function sort(array, property, isReverseOrder) {
    var result = array.sort(function (o1, o2) {
        if (isReverseOrder) {
            return o1[property] > o2[property]
                ? -1
                : o1[property] < o2[property]
                    ? 1
                    : 0;
        }
        return o1[property] < o2[property]
            ? -1
            : o1[property] > o2[property]
                ? 1
                : 0;
    });
    return result;
}
function htmlToText(str) {
    if (!str)
        return false;
    str = str.toString();
    return str.replace(/(<([^>]+)>)/gi, '');
}


/***/ }),

/***/ "./src/lib/dbutils.ts":
/*!****************************!*\
  !*** ./src/lib/dbutils.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getGlobalCollection = exports.getCollection = void 0;
var mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
var getCollection = function (realm, collection, schema) {
    var db = mongoose_1.default.connection.useDb("echo_".concat(realm));
    return db.model(collection, schema);
};
exports.getCollection = getCollection;
var getGlobalCollection = function (collection, schema) {
    var db = mongoose_1.default.connection.useDb("echo");
    return db.model(collection, schema);
};
exports.getGlobalCollection = getGlobalCollection;


/***/ }),

/***/ "./src/lib/gptutils.ts":
/*!*****************************!*\
  !*** ./src/lib/gptutils.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPrompt = exports.replaceVariables = exports.predict = void 0;
var Handlebars = __importStar(__webpack_require__(/*! handlebars */ "handlebars"));
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var axios = __webpack_require__(/*! axios */ "axios");
var DODO_URL = process.env.DODO_URL || "https://api.ioak.io:8120";
var DODO_KEY = process.env.DODO_KEY || "a53dc337-a203-4980-bfc8-12f19acddd26";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
var predict = function (payload) { return __awaiter(void 0, void 0, void 0, function () {
    var response, err_1;
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return __generator(this, function (_l) {
        switch (_l.label) {
            case 0:
                _l.trys.push([0, 2, , 3]);
                return [4, axios.post("".concat(DODO_URL, "/api/chatgpt/v1/chat/completions"), payload, {
                        headers: {
                            authorization: DODO_KEY,
                        },
                    })];
            case 1:
                response = _l.sent();
                if (response.status === 200) {
                    console.log("GPT RESPONSE");
                    if (((_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.choices.length) > 0 &&
                        ((_f = (_e = (_d = (_c = response.data) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.choices[0]) === null || _e === void 0 ? void 0 : _e.message) === null || _f === void 0 ? void 0 : _f.content)) {
                        return [2, (_k = (_j = (_h = (_g = response.data) === null || _g === void 0 ? void 0 : _g.data) === null || _h === void 0 ? void 0 : _h.choices[0]) === null || _j === void 0 ? void 0 : _j.message) === null || _k === void 0 ? void 0 : _k.content.replace(/```json/g, "").replace(/```/g, "")];
                    }
                }
                return [3, 3];
            case 2:
                err_1 = _l.sent();
                console.log("*", err_1);
                return [2, {}];
            case 3: return [2, null];
        }
    });
}); };
exports.predict = predict;
var replaceVariables = function (content, context) {
    if (Array.isArray(content)) {
        return content.map(function (item) { return Handlebars.compile(item)(context); }).join("\n");
    }
    else if (typeof content === "string") {
        return Handlebars.compile(content)(context);
    }
    else {
        throw new Error("Unsupported content type");
    }
};
exports.replaceVariables = replaceVariables;
var getPrompt = function (_prompt, context) {
    var prompt = (0, lodash_1.cloneDeep)(_prompt);
    for (var i = 0; i < prompt.messages.length; i++) {
        prompt.messages[i].content = (0, exports.replaceVariables)(prompt.messages[i].content, __assign({ modelName: _MODEL_NAME }, context));
    }
    console.log(prompt);
    return prompt;
};
exports.getPrompt = getPrompt;


/***/ }),

/***/ "./src/lib/validation.ts":
/*!*******************************!*\
  !*** ./src/lib/validation.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateMandatoryFields = void 0;
var validateMandatoryFields = function (res, data, mandatoryFields) {
    var missingFields = [];
    mandatoryFields.forEach(function (fieldName) {
        if (!data.hasOwnProperty(fieldName)) {
            missingFields.push(fieldName);
        }
    });
    if (missingFields.length === 0) {
        return true;
    }
    res.status(400);
    res.send({
        error: { missingFields: missingFields },
    });
    res.end();
    return false;
};
exports.validateMandatoryFields = validateMandatoryFields;


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
if (true) {
    module.hot.accept();
    module.hot.dispose(function () { return server.stop(); });
}
var ApolloServer = (__webpack_require__(/*! apollo-server-express */ "apollo-server-express").ApolloServer);
var middlewares_1 = __webpack_require__(/*! ./middlewares */ "./src/middlewares.ts");
var mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
var startup_1 = __webpack_require__(/*! ./startup */ "./src/startup.ts");
var express = __webpack_require__(/*! express */ "express");
var cors = __webpack_require__(/*! cors */ "cors");
var ApiRoute = __webpack_require__(/*! ./route */ "./src/route.ts");
var gqlScalarSchema = __webpack_require__(/*! ./modules/gql-scalar */ "./src/modules/gql-scalar/index.js");
var assetSchema = __webpack_require__(/*! ./modules/asset */ "./src/modules/asset/index.js");
var sessionSchema = __webpack_require__(/*! ./modules/session */ "./src/modules/session/index.ts");
var userSchema = __webpack_require__(/*! ./modules/user */ "./src/modules/user/index.ts");
var articleSchema = __webpack_require__(/*! ./modules/article */ "./src/modules/article/index.js");
var articleCommentSchema = __webpack_require__(/*! ./modules/article/comment */ "./src/modules/article/comment/index.js");
var articleCommentFeedbackSchema = __webpack_require__(/*! ./modules/article/comment/feedback */ "./src/modules/article/comment/feedback/index.js");
var articleFeedbackSchema = __webpack_require__(/*! ./modules/article/feedback */ "./src/modules/article/feedback/index.js");
var articleCategorySchema = __webpack_require__(/*! ./modules/article/category */ "./src/modules/article/category/index.js");
var articleTagSchema = __webpack_require__(/*! ./modules/article/tag */ "./src/modules/article/tag/index.js");
var postSchema = __webpack_require__(/*! ./modules/post */ "./src/modules/post/index.js");
var postCommentSchema = __webpack_require__(/*! ./modules/post/comment */ "./src/modules/post/comment/index.js");
var postCommentFeedbackSchema = __webpack_require__(/*! ./modules/post/comment/feedback */ "./src/modules/post/comment/feedback/index.js");
var postFeedbackSchema = __webpack_require__(/*! ./modules/post/feedback */ "./src/modules/post/feedback/index.js");
var postFollowerSchema = __webpack_require__(/*! ./modules/post/follower */ "./src/modules/post/follower/index.js");
var postTagSchema = __webpack_require__(/*! ./modules/post/tag */ "./src/modules/post/tag/index.js");
var databaseUri = process.env.MONGODB_URI || "mongodb://127.0.0.1:27017";
mongoose_1.default.connect(databaseUri, {});
mongoose_1.default.pluralize(undefined);
var app = express();
var server = new ApolloServer({
    typeDefs: [
        gqlScalarSchema.typeDefs,
        assetSchema.typeDefs,
        sessionSchema.typeDefs,
        userSchema.typeDefs,
        articleSchema.typeDefs,
        articleCommentSchema.typeDefs,
        articleCommentFeedbackSchema.typeDefs,
        articleCategorySchema.typeDefs,
        articleFeedbackSchema.typeDefs,
        articleTagSchema.typeDefs,
        postSchema.typeDefs,
        postCommentSchema.typeDefs,
        postCommentFeedbackSchema.typeDefs,
        postFeedbackSchema.typeDefs,
        postFollowerSchema.typeDefs,
        postTagSchema.typeDefs,
    ],
    resolvers: [
        gqlScalarSchema.resolvers,
        assetSchema.resolvers,
        sessionSchema.resolvers,
        userSchema.resolvers,
        articleSchema.resolvers,
        articleCommentSchema.resolvers,
        articleCommentFeedbackSchema.resolvers,
        articleCategorySchema.resolvers,
        articleFeedbackSchema.resolvers,
        articleTagSchema.resolvers,
        postSchema.resolvers,
        postCommentSchema.resolvers,
        postCommentFeedbackSchema.resolvers,
        postFeedbackSchema.resolvers,
        postFollowerSchema.resolvers,
        postTagSchema.resolvers,
    ],
    context: function (_a) {
        var req = _a.req, res = _a.res;
        var authString = req.headers.authorization || "";
        var authParts = authString.split(" ");
        var token = "";
        var user = null;
        var asset = "";
        if (authParts.length === 2) {
            token = authParts[1];
            asset = authParts[0];
            user = (0, middlewares_1.authorize)(token);
        }
        return { user: user, token: token, asset: asset };
    },
    introspection: true,
    playground: true,
});
server.start().then(function () { return server.applyMiddleware({ app: app }); });
app.use(cors());
app.get("/hello", function (_, res) {
    res.send("basic connection to server works. database connection is not validated");
    res.end();
});
app.use(express.json({ limit: 5000000 }));
app.use(express.urlencoded({
    extended: true,
}));
app.use("/api", ApiRoute);
app.use(function (_, res) {
    res.status(404);
    res.send("Not found");
    res.end();
});
app.use(function (err, req, res, next) {
    console.error('Error:', err);
    res.status(500).send(err.stack);
});
app.listen({ port: process.env.PORT || 4000 }, function () {
    return console.log("\uD83D\uDE80 Server ready at http://localhost:".concat(process.env.PORT || 4000).concat(server.graphqlPath));
});
(0, startup_1.initializeSequences)();


/***/ }),

/***/ "./src/middlewares.ts":
/*!****************************!*\
  !*** ./src/middlewares.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.authorizeApi = exports.authorizeApiOneauth = exports.authorize = void 0;
var fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
var jsonwebtoken_1 = __importDefault(__webpack_require__(/*! jsonwebtoken */ "jsonwebtoken"));
var helper_1 = __webpack_require__(/*! ./modules/auth/helper */ "./src/modules/auth/helper.ts");
var authorize = function (token) {
    var appRoot = process.cwd();
    var publicKey = fs_1.default.readFileSync(appRoot + "/public.pem");
    try {
        if (token) {
            return jsonwebtoken_1.default.verify(token, publicKey);
        }
        return null;
    }
    catch (err) {
        return null;
    }
};
exports.authorize = authorize;
var authorizeApiOneauth = function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    var token, data, err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                token = req.headers["authorization"];
                if (!token) {
                    return [2, res.sendStatus(401)];
                }
                return [4, (0, helper_1.decodeToken)(token)];
            case 1:
                data = _a.sent();
                if (!data.outcome) {
                    return [2, res.sendStatus(401)];
                }
                req.user = data.claims;
                next();
                return [3, 3];
            case 2:
                err_1 = _a.sent();
                console.log(err_1);
                return [2, res.sendStatus(401)];
            case 3: return [2];
        }
    });
}); };
exports.authorizeApiOneauth = authorizeApiOneauth;
var authorizeApi = function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    var token, data, err_2;
    var _a, _b, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                _d.trys.push([0, 2, , 3]);
                token = req.headers["authorization"];
                if (!token) {
                    return [2, res.sendStatus(401)];
                }
                return [4, (0, helper_1.decodeToken)(token)];
            case 1:
                data = _d.sent();
                if (!data.outcome ||
                    (req.params.space && (!((_a = data.claims) === null || _a === void 0 ? void 0 : _a.permissions) || !((_c = (_b = data.claims) === null || _b === void 0 ? void 0 : _b.permissions['COMPANY_ADMIN']) === null || _c === void 0 ? void 0 : _c.includes(req.params.space))))) {
                    return [2, res.sendStatus(401)];
                }
                req.user = data.claims;
                next();
                return [3, 3];
            case 2:
                err_2 = _d.sent();
                console.log(err_2);
                return [2, res.sendStatus(401)];
            case 3: return [2];
        }
    });
}); };
exports.authorizeApi = authorizeApi;


/***/ }),

/***/ "./src/modules/auth/helper.ts":
/*!************************************!*\
  !*** ./src/modules/auth/helper.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeAppToken = exports.encodeAppToken = exports.getHash = exports.decodeSession = exports.decodeToken = exports.deleteSessionByRefreshToken = exports.deleteSession = exports.validateSession = exports.getAccessToken = exports.createSession = void 0;
var bcrypt_1 = __importDefault(__webpack_require__(/*! bcrypt */ "bcrypt"));
var uuid_1 = __webpack_require__(/*! uuid */ "uuid");
var fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
var jsonwebtoken_1 = __importDefault(__webpack_require__(/*! jsonwebtoken */ "jsonwebtoken"));
var date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
var model_1 = __webpack_require__(/*! ../session/model */ "./src/modules/session/model.ts");
var dbutils_1 = __webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts");
var selfRealm = 100;
var appUrl = process.env.APP_URL || "http://localhost:3010";
var createSession = function (realm, user) { return __awaiter(void 0, void 0, void 0, function () {
    var session_id, model, claims, appRoot, privateKey, refresh_token;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                session_id = (0, uuid_1.v4)();
                model = (0, dbutils_1.getCollection)(String(realm), model_1.sessionCollection, model_1.sessionSchema);
                claims = {
                    user_id: user.id,
                    given_name: user.given_name,
                    family_name: user.family_name,
                    name: user.name,
                    nickname: user.nickname,
                    email: user.email,
                    type: user.type,
                };
                appRoot = process.cwd();
                privateKey = fs_1.default.readFileSync(appRoot + "/private.pem");
                refresh_token = jsonwebtoken_1.default.sign({
                    realm: realm,
                    id: session_id,
                }, { key: privateKey, passphrase: "no1knowsme" }, {
                    algorithm: "RS256",
                    expiresIn: "8h",
                });
                return [4, model.create({
                        session_id: session_id,
                        refresh_token: refresh_token,
                        user_id: user.id,
                        claims: claims,
                        iat: new Date(),
                        eat: (0, date_fns_1.add)(new Date(), { hours: 8 }),
                    })];
            case 1:
                _a.sent();
                return [2, { session_id: session_id, refresh_token: refresh_token }];
        }
    });
}); };
exports.createSession = createSession;
var getAccessToken = function (refreshToken) { return __awaiter(void 0, void 0, void 0, function () {
    var decoded, claims, appRoot, privateKey, model, session, refreshTokenDuration, access_token;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, (0, exports.decodeToken)(refreshToken)];
            case 1:
                decoded = _a.sent();
                if (!decoded.outcome ||
                    !decoded.claims ||
                    !decoded.claims.realm ||
                    !decoded.claims.id) {
                    return [2, null];
                }
                claims = decoded.claims;
                appRoot = process.cwd();
                privateKey = fs_1.default.readFileSync(appRoot + "/private.pem");
                model = (0, dbutils_1.getCollection)(claims.realm, model_1.sessionCollection, model_1.sessionSchema);
                return [4, model.findOne({ session_id: claims.id })];
            case 2:
                session = _a.sent();
                if ((0, date_fns_1.differenceInSeconds)(session.eat, new Date()) < 60) {
                    return [2, null];
                }
                refreshTokenDuration = (0, date_fns_1.differenceInSeconds)(session.eat, new Date()) > 60 * 60 * 2
                    ? 60 * 60 * 2
                    : (0, date_fns_1.differenceInSeconds)(session.eat, new Date());
                access_token = jsonwebtoken_1.default.sign(session.claims, { key: privateKey, passphrase: "no1knowsme" }, {
                    algorithm: "RS256",
                    expiresIn: "".concat(refreshTokenDuration, "s"),
                });
                return [2, access_token];
        }
    });
}); };
exports.getAccessToken = getAccessToken;
var validateSession = function (realm, sessionId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, session;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getCollection)(String(realm), model_1.sessionCollection, model_1.sessionSchema);
                return [4, model.findOne({ sessionId: sessionId })];
            case 1:
                session = _a.sent();
                return [2, session];
        }
    });
}); };
exports.validateSession = validateSession;
var deleteSession = function (realm, session_id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getCollection)(String(realm), model_1.sessionCollection, model_1.sessionSchema);
                return [4, model.deleteOne({ session_id: session_id })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.deleteSession = deleteSession;
var deleteSessionByRefreshToken = function (realm, refresh_token) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getCollection)(String(realm), model_1.sessionCollection, model_1.sessionSchema);
                return [4, model.deleteOne({ refresh_token: refresh_token })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.deleteSessionByRefreshToken = deleteSessionByRefreshToken;
var decodeToken = function (token) { return __awaiter(void 0, void 0, void 0, function () {
    var appRoot, publicKey, res, err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                appRoot = process.cwd();
                publicKey = fs_1.default.readFileSync(appRoot + "/public.pem");
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, jsonwebtoken_1.default.verify(token, publicKey)];
            case 2:
                res = _a.sent();
                return [2, { outcome: true, token: token, claims: res }];
            case 3:
                err_1 = _a.sent();
                console.log(err_1);
                return [2, { outcome: false, err: err_1 }];
            case 4: return [2];
        }
    });
}); };
exports.decodeToken = decodeToken;
var decodeSession = function (realmId, sessionId) { return __awaiter(void 0, void 0, void 0, function () {
    var session;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, (0, exports.validateSession)(realmId, sessionId)];
            case 1:
                session = _a.sent();
                if (!session) {
                    return [2, session];
                }
                return [2, (0, exports.decodeToken)(session.token)];
        }
    });
}); };
exports.decodeSession = decodeSession;
var getHash = function (password) { return __awaiter(void 0, void 0, void 0, function () {
    var salt;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, bcrypt_1.default.genSalt(10)];
            case 1:
                salt = _a.sent();
                return [4, bcrypt_1.default.hash(password, salt)];
            case 2: return [2, _a.sent()];
        }
    });
}); };
exports.getHash = getHash;
var encodeAppToken = function (claims) {
    var appRoot = process.cwd();
    var privateKey = fs_1.default.readFileSync(appRoot + "/local_private.pem");
    var token = jsonwebtoken_1.default.sign(claims, { key: privateKey, passphrase: "fevicryl" }, {
        algorithm: "RS256",
        expiresIn: "100h",
    });
    return token;
};
exports.encodeAppToken = encodeAppToken;
var decodeAppToken = function (token) { return __awaiter(void 0, void 0, void 0, function () {
    var appRoot, publicKey, res, err_2;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                appRoot = process.cwd();
                publicKey = fs_1.default.readFileSync(appRoot + "/local_public.pem");
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, jsonwebtoken_1.default.verify(token, publicKey)];
            case 2:
                res = _a.sent();
                return [2, { outcome: true, token: token, claims: res }];
            case 3:
                err_2 = _a.sent();
                console.log(err_2);
                return [2, { outcome: false, err: err_2 }];
            case 4: return [2];
        }
    });
}); };
exports.decodeAppToken = decodeAppToken;


/***/ }),

/***/ "./src/modules/auth/route.ts":
/*!***********************************!*\
  !*** ./src/modules/auth/route.ts ***!
  \***********************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/auth/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.post("/auth/authorize", (0, handler_1.asyncHandler)(service_1.signin));
    router.post("/auth/token", (0, handler_1.asyncHandler)(service_1.issueToken));
    router.get("/auth/token/decode", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.decodeToken));
    router.post("/auth/logout", (0, handler_1.asyncHandler)(service_1.logout));
    router.get("/auth/oa/session/:id", function (req, res, next) {
        return (0, handler_1.asyncHandler)((0, service_1.validateSession)(selfRealm, req, res, next));
    });
    router.delete("/auth/oa/session/:id", function (req, res, next) {
        return (0, handler_1.asyncHandler)((0, service_1.deleteSession)(selfRealm, req, res, next));
    });
    router.get("/auth/oa/session/:id/decode", function (req, res, next) {
        return (0, handler_1.asyncHandler)((0, service_1.decodeSession)(selfRealm, req, res, next));
    });
    router.get("/auth/realm/:realm/session/:id", function (req, res, next) {
        return (0, handler_1.asyncHandler)((0, service_1.validateSession)(req.params.realm, req, res, next));
    });
    router.get("/auth/realm/:realm/session/:id/decode", function (req, res, next) {
        return (0, handler_1.asyncHandler)((0, service_1.decodeSession)(req.params.realm, req, res, next));
    });
    router.delete("/auth/realm/:realm/session/:id", function (req, res, next) {
        return (0, handler_1.asyncHandler)((0, service_1.deleteSession)(req.params.realm, req, res, next));
    });
};


/***/ }),

/***/ "./src/modules/auth/service.ts":
/*!*************************************!*\
  !*** ./src/modules/auth/service.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeSession = exports.decodeToken = exports.deleteSession = exports.validateSession = exports.logout = exports.issueToken = exports.signin = void 0;
var bcrypt_1 = __importDefault(__webpack_require__(/*! bcrypt */ "bcrypt"));
var validation_1 = __webpack_require__(/*! ../../lib/validation */ "./src/lib/validation.ts");
var model_1 = __webpack_require__(/*! ../user/model */ "./src/modules/user/model.ts");
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/auth/helper.ts"));
var dbutils_1 = __webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts");
var selfRealm = 100;
var signin = function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    var payload, model, user, outcome, _a, session_id, refresh_token, access_token;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                payload = req.body;
                if (!(0, validation_1.validateMandatoryFields)(res, payload, [
                    "email",
                    "password",
                    "realm",
                    "response_type",
                ])) {
                    return [2];
                }
                model = (0, dbutils_1.getCollection)(payload.realm, model_1.userCollection, model_1.userSchema);
                return [4, model.findOne({
                        email: payload.email,
                        type: "oneauth",
                    })];
            case 1:
                user = _b.sent();
                if (!user) {
                    res.status(404);
                    res.send({ error: { message: "User with this user name does not exist" } });
                    res.end();
                    return [2];
                }
                if (!user.email_verified) {
                    res.status(403);
                    res.send({ error: { message: "Email of user not verified" } });
                    res.end();
                    return [2];
                }
                return [4, bcrypt_1.default.compare(payload.password, user.hash)];
            case 2:
                outcome = _b.sent();
                if (!outcome) {
                    res.status(401);
                    res.send({ error: { message: "Incorrect password" } });
                    res.end();
                    return [2];
                }
                return [4, Helper.createSession(payload.realm, user)];
            case 3:
                _a = _b.sent(), session_id = _a.session_id, refresh_token = _a.refresh_token;
                if (payload.response_type === "code") {
                    res.status(200);
                    res.send({ session_id: session_id });
                    res.end();
                    return [2];
                }
                res.status(200);
                return [4, Helper.getAccessToken(refresh_token)];
            case 4:
                access_token = _b.sent();
                res.send({ token_type: "Bearer", access_token: access_token, refresh_token: refresh_token });
                res.end();
                return [2];
        }
    });
}); };
exports.signin = signin;
var issueToken = function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    var payload, access_token, token, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                payload = req.body;
                if (!(0, validation_1.validateMandatoryFields)(res, payload, [
                    "grant_type",
                    "realm",
                    "refresh_token",
                ])) {
                    return [2];
                }
                if (!(payload.grant_type === "refresh_token")) return [3, 2];
                return [4, Helper.getAccessToken(payload.refresh_token)];
            case 1:
                access_token = _a.sent();
                if (!access_token) {
                    res.status(400);
                    res.send({ error: { message: "Refresh token invalid or expired" } });
                    res.end();
                    return [2];
                }
                res.status(200);
                res.send({ token_type: "Bearer", access_token: access_token });
                res.end();
                return [2];
            case 2:
                token = req.params.token;
                return [4, Helper.decodeToken(token)];
            case 3:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.issueToken = issueToken;
var logout = function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    var payload, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                payload = req.body;
                if (!(0, validation_1.validateMandatoryFields)(res, payload, ["realm", "refresh_token"])) {
                    return [2];
                }
                return [4, Helper.deleteSessionByRefreshToken(payload.realm, payload.refresh_token)];
            case 1:
                outcome = _a.sent();
                if (outcome.deletedCount === 0) {
                    res.status(404);
                    res.send({ error: { message: "Invalid session" } });
                    res.end();
                    return [2];
                }
                res.status(200);
                res.send({ refresh_token: payload.refresh_token });
                res.end();
                return [2];
        }
    });
}); };
exports.logout = logout;
var validateSession = function (realmId, req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    var session, err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, Helper.validateSession(realmId, req.params.id)];
            case 1:
                session = _a.sent();
                if (!session) {
                    res.status(404);
                    res.send("Session not found");
                    res.end();
                    return [2];
                }
                res.status(200);
                res.send({ sessionId: req.params.id, token: session.token });
                res.end();
                return [3, 3];
            case 2:
                err_1 = _a.sent();
                next(err_1);
                return [3, 3];
            case 3: return [2];
        }
    });
}); };
exports.validateSession = validateSession;
var deleteSession = function (realmId, req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    var outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.deleteSession(selfRealm, req.params.id)];
            case 1:
                outcome = _a.sent();
                if (outcome.deletedCount === 0) {
                    res.status(404);
                    res.send("Session not found");
                    res.end();
                    return [2];
                }
                res.status(200);
                res.send({ sessionId: req.params.id });
                res.end();
                return [2];
        }
    });
}); };
exports.deleteSession = deleteSession;
var decodeToken = function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        res.status(200);
        res.send(__assign({}, req.user));
        res.end();
        return [2];
    });
}); };
exports.decodeToken = decodeToken;
var decodeSession = function (realmId, req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
    var outcome, err_2;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, Helper.decodeSession(selfRealm, req.params.id)];
            case 1:
                outcome = _a.sent();
                if (!outcome) {
                    res.status(404);
                    res.send("Session not found");
                    res.end();
                    return [2];
                }
                res.status(200);
                res.send(outcome);
                res.end();
                return [3, 3];
            case 2:
                err_2 = _a.sent();
                next(err_2);
                return [3, 3];
            case 3: return [2];
        }
    });
}); };
exports.decodeSession = decodeSession;


/***/ }),

/***/ "./src/modules/book/chapter/helper.ts":
/*!********************************************!*\
  !*** ./src/modules/book/chapter/helper.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addChapters = exports.deleteBookChapterByReference = exports.deleteBookChapter = exports.getBookChapterById = exports.getBookChapterByBookReference = exports.getBookChaptersByBookReference = exports.getBookChapter = exports.updateBookChapter = exports.createBookChapter = exports.generateChapters = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/chapter/model.ts");
var BookHelper = __importStar(__webpack_require__(/*! ../helper */ "./src/modules/book/helper.ts"));
var service_1 = __webpack_require__(/*! ../../sequence/service */ "./src/modules/sequence/service.ts");
var Gptutils = __importStar(__webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/chapter/prompt.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var generateChapters = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var book, gptResponseText, gptResponse, model, _payload, i, _a, _b;
    var _c, _d, _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _f.sent();
                console.log(book === null || book === void 0 ? void 0 : book.isbn);
                if (!book || !book.isManaged) {
                    return [2, null];
                }
                return [4, Gptutils.predict((0, prompt_1.getBookChaptersPrompt)(book.title, book.primaryAuthor))];
            case 2:
                gptResponseText = _f.sent();
                console.log(gptResponseText);
                gptResponse = JSON.parse(gptResponseText);
                console.log(gptResponse);
                if (!gptResponse) {
                    return [2, null];
                }
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                _payload = [];
                i = 0;
                _f.label = 3;
            case 3:
                if (!(i < gptResponse.length)) return [3, 6];
                _b = (_a = _payload).push;
                _c = {};
                _d = {
                    filter: {
                        bookref: bookref,
                        name: gptResponse[i],
                    }
                };
                _e = {
                    name: gptResponse[i]
                };
                return [4, (0, service_1.nextval)("chapterId", bookref, space)];
            case 4:
                _b.apply(_a, [(_c.updateOne = (_d.update = (_e.reference = _f.sent(),
                        _e),
                        _d.upsert = true,
                        _d),
                        _c)]);
                _f.label = 5;
            case 5:
                i++;
                return [3, 3];
            case 6: return [4, model.bulkWrite(_payload)];
            case 7: return [2, _f.sent()];
        }
    });
}); };
exports.generateChapters = generateChapters;
var createBookChapter = function (space_1, _a, userId_1) { return __awaiter(void 0, [space_1, _a, userId_1], void 0, function (space, _b, userId) {
    var model, response;
    var bookChapter = _b.bookChapter, meta = _b.meta;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                response = null;
                return [4, model.create(__assign({}, bookChapter))];
            case 1:
                response = _c.sent();
                console.log(response.reference);
                return [2, response];
        }
    });
}); };
exports.createBookChapter = createBookChapter;
var updateBookChapter = function (space, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, bookChapterResponse, bookChapter;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                response = null;
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, data, {
                        new: true,
                        upsert: true,
                    })];
            case 1:
                response = _a.sent();
                return [3, 4];
            case 2: return [4, model.create(__assign({}, data))];
            case 3:
                response = _a.sent();
                _a.label = 4;
            case 4: return [4, model.find({
                    reference: response.reference,
                })];
            case 5:
                bookChapterResponse = _a.sent();
                bookChapter = null;
                if (bookChapterResponse.length > 0) {
                    bookChapter = bookChapterResponse[0];
                }
                return [2, {
                        bookChapter: bookChapter,
                    }];
        }
    });
}); };
exports.updateBookChapter = updateBookChapter;
var getBookChapter = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                return [4, model.find()];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.getBookChapter = getBookChapter;
var getBookChaptersByBookReference = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                return [4, model.find({ bookref: bookref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getBookChaptersByBookReference = getBookChaptersByBookReference;
var getBookChapterByBookReference = function (space, bookref, chapterref) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                return [4, model.find({ bookref: bookref, reference: chapterref })];
            case 1:
                response = _a.sent();
                if (response.length > 0) {
                    return [2, response[0]];
                }
                return [2, null];
        }
    });
}); };
exports.getBookChapterByBookReference = getBookChapterByBookReference;
var getBookChapterById = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                return [4, model.find({ _id: _id })];
            case 1:
                res = _a.sent();
                if (res.length > 0) {
                    return [2, res[0]];
                }
                return [2];
        }
    });
}); };
exports.getBookChapterById = getBookChapterById;
var deleteBookChapter = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { bookChapter: _id }];
        }
    });
}); };
exports.deleteBookChapter = deleteBookChapter;
var deleteBookChapterByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                return [4, model.deleteMany({ reference: reference })];
            case 1:
                _a.sent();
                return [2, { bookChapter: reference }];
        }
    });
}); };
exports.deleteBookChapterByReference = deleteBookChapterByReference;
var addChapters = function (space, bookref, chapterTitles) { return __awaiter(void 0, void 0, void 0, function () {
    var model, _payload, i, _a, _b;
    var _c, _d, _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0:
                model = getCollection(space, model_1.bookChapterCollection, model_1.bookChapterSchema);
                _payload = [];
                i = 0;
                _f.label = 1;
            case 1:
                if (!(i < chapterTitles.length)) return [3, 4];
                _b = (_a = _payload).push;
                _c = {};
                _d = {
                    filter: {
                        bookref: bookref,
                        name: chapterTitles[i],
                    }
                };
                _e = {
                    name: chapterTitles[i]
                };
                return [4, (0, service_1.nextval)("chapterId", bookref, space)];
            case 2:
                _b.apply(_a, [(_c.updateOne = (_d.update = (_e.reference = _f.sent(),
                        _e),
                        _d.upsert = true,
                        _d),
                        _c)]);
                _f.label = 3;
            case 3:
                i++;
                return [3, 1];
            case 4: return [4, model.bulkWrite(_payload)];
            case 5: return [2, _f.sent()];
        }
    });
}); };
exports.addChapters = addChapters;


/***/ }),

/***/ "./src/modules/book/chapter/model.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/chapter/model.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bookChapterCollection = exports.bookChapterSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var bookChapterSchema = new Schema({
    name: { type: String },
    reference: { type: String },
    bookref: { type: String },
}, { timestamps: true, strict: false, strictQuery: false });
exports.bookChapterSchema = bookChapterSchema;
var bookChapterCollection = "book.chapter";
exports.bookChapterCollection = bookChapterCollection;


/***/ }),

/***/ "./src/modules/book/chapter/prompt.ts":
/*!********************************************!*\
  !*** ./src/modules/book/chapter/prompt.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBookChaptersPrompt = void 0;
var Handlebars = __importStar(__webpack_require__(/*! handlebars */ "handlebars"));
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
;
var getBookChaptersPrompt = function (bookName, authorName) {
    var prompt = (0, lodash_1.cloneDeep)(_BOOK_CHAPTERS_PROMPT);
    prompt.messages[prompt.messages.length - 1].content = Handlebars.compile(prompt.messages[prompt.messages.length - 1].content)({
        bookName: bookName,
        authorName: authorName,
        modelName: _MODEL_NAME,
    });
    console.log(prompt);
    return prompt;
};
exports.getBookChaptersPrompt = getBookChaptersPrompt;
var _BOOK_CHAPTERS_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: "You are a helpful assistant designed to retrieve and provide accurate book chapter titles. Your task is to process a given book name and author name to generate a JSON array of chapter titles in string format. Ensure that the titles are returned as accurately as possible. The input will include placeholders for bookName and authorName. Do not include any additional details outside of the chapter titles.",
        },
        {
            role: "user",
            content: "Please get the list of chapters for the book titled '{{bookName}}' by '{{authorName}}' and return them as a JSON array of strings.",
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/chapter/route.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/chapter/route.ts ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/chapter/service.ts");
module.exports = function (router) {
    router.put("/book/chapter/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateBookChapter));
    router.post("/book/chapter/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createBookChapter));
    router.post("/book/chapter/:space/:bookref/generate-chapters", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.generateChapters));
    router.get("/book/chapter/:space/id/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookChapterById));
    router.get("/book/chapter/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookChaptersByBookReference));
    router.get("/book/chapter/:space/:bookref/:chapterref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookChapterByBookReference));
    router.delete("/book/chapter/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookChapter));
    router.delete("/book/chapter/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookChapterByReference));
};


/***/ }),

/***/ "./src/modules/book/chapter/service.ts":
/*!*********************************************!*\
  !*** ./src/modules/book/chapter/service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteBookChapterByReference = exports.deleteBookChapter = exports.getBookChapterByBookReference = exports.getBookChaptersByBookReference = exports.getBookChapterById = exports.getBookChapter = exports.updateBookChapter = exports.createBookChapter = exports.generateChapters = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/chapter/helper.ts"));
var generateChapters = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.generateChapters(req.params.space, req.params.bookref)];
            case 1:
                response = _a.sent();
                if (!response) {
                    res.status(404);
                    res.send({
                        errorMessage: "ISBN not found",
                    });
                    res.end();
                }
                else {
                    res.status(200);
                    res.send(response);
                    res.end();
                }
                return [2];
        }
    });
}); };
exports.generateChapters = generateChapters;
var createBookChapter = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookChapter;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createBookChapter(req.params.space, req.body, userId)];
            case 1:
                bookChapter = _a.sent();
                res.status(200);
                res.send(bookChapter);
                res.end();
                return [2];
        }
    });
}); };
exports.createBookChapter = createBookChapter;
var updateBookChapter = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookChapter;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateBookChapter(req.params.space, req.body, userId)];
            case 1:
                bookChapter = _a.sent();
                res.status(200);
                res.send(bookChapter);
                res.end();
                return [2];
        }
    });
}); };
exports.updateBookChapter = updateBookChapter;
var getBookChapter = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookChapterList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookChapter(req.params.space)];
            case 1:
                bookChapterList = _a.sent();
                res.status(200);
                res.send(bookChapterList);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookChapter = getBookChapter;
var getBookChapterById = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookChapter;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookChapterById(req.params.space, req.params.id)];
            case 1:
                bookChapter = _a.sent();
                res.status(200);
                res.send(bookChapter);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookChapterById = getBookChapterById;
var getBookChaptersByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookChapter;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookChaptersByBookReference(req.params.space, req.params.bookref)];
            case 1:
                bookChapter = _a.sent();
                res.status(200);
                res.send(bookChapter);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookChaptersByBookReference = getBookChaptersByBookReference;
var getBookChapterByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookChapter;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookChapterByBookReference(req.params.space, req.params.bookref, req.params.chapterref)];
            case 1:
                bookChapter = _a.sent();
                res.status(200);
                res.send(bookChapter);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookChapterByBookReference = getBookChapterByBookReference;
var deleteBookChapter = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookChapter(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookChapter = deleteBookChapter;
var deleteBookChapterByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookChapterByReference(req.params.space, req.params.reference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookChapterByReference = deleteBookChapterByReference;


/***/ }),

/***/ "./src/modules/book/concept/helper.ts":
/*!********************************************!*\
  !*** ./src/modules/book/concept/helper.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addConcepts = exports.deleteBookConceptByReference = exports.deleteBookConcept = exports.getBookConceptById = exports.getBookConceptByBookReference = exports.getBookConceptsByBookReference = exports.getBookConcept = exports.updateBookConcept = exports.createBookConcept = exports.generateConcepts = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/concept/model.ts");
var BookHelper = __importStar(__webpack_require__(/*! ../helper */ "./src/modules/book/helper.ts"));
var service_1 = __webpack_require__(/*! ../../sequence/service */ "./src/modules/sequence/service.ts");
var Gptutils = __importStar(__webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/concept/prompt.ts");
var helper_1 = __webpack_require__(/*! ../theme/helper */ "./src/modules/book/theme/helper.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var SIMILARITY_ALGORITHM = "similarity";
var generateConcepts = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var book, prompt, gptResponseText, gptResponse, model, _payload, i, _a, _b, concepts, i;
    var _c, _d, _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _f.sent();
                if (!book || !book.isManaged) {
                    return [2, null];
                }
                prompt = (0, prompt_1.getBookConceptsPrompt)(book.title, book.primaryAuthor);
                console.log(typeof prompt.messages[0].content);
                return [4, Gptutils.predict((0, prompt_1.getBookConceptsPrompt)(book.title, book.primaryAuthor))];
            case 2:
                gptResponseText = _f.sent();
                console.log(gptResponseText);
                gptResponse = JSON.parse(gptResponseText);
                console.log(gptResponse);
                if (!gptResponse) {
                    return [2, null];
                }
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                _payload = [];
                i = 0;
                _f.label = 3;
            case 3:
                if (!(i < gptResponse.length)) return [3, 6];
                _b = (_a = _payload).push;
                _c = {};
                _d = {
                    filter: {
                        bookref: bookref,
                        name: gptResponse[i].title,
                    }
                };
                _e = {
                    name: gptResponse[i].title,
                    description: gptResponse[i].description,
                    themes: gptResponse[i].themes
                };
                return [4, (0, service_1.nextval)("conceptId", bookref, space)];
            case 4:
                _b.apply(_a, [(_c.updateOne = (_d.update = (_e.reference = _f.sent(),
                        _e),
                        _d.upsert = true,
                        _d),
                        _c)]);
                _f.label = 5;
            case 5:
                i++;
                return [3, 3];
            case 6: return [4, model.deleteMany({ bookref: bookref })];
            case 7:
                _f.sent();
                return [4, model.bulkWrite(_payload)];
            case 8:
                _f.sent();
                return [4, model.find({ bookref: bookref })];
            case 9:
                concepts = _f.sent();
                i = 0;
                _f.label = 10;
            case 10:
                if (!(i < concepts.length)) return [3, 13];
                return [4, (0, helper_1.addThemes)(space, bookref, concepts[i].reference, concepts[i].themes)];
            case 11:
                _f.sent();
                _f.label = 12;
            case 12:
                i++;
                return [3, 10];
            case 13: return [2, concepts];
        }
    });
}); };
exports.generateConcepts = generateConcepts;
var createBookConcept = function (space_1, _a, userId_1) { return __awaiter(void 0, [space_1, _a, userId_1], void 0, function (space, _b, userId) {
    var model, response;
    var bookConcept = _b.bookConcept, meta = _b.meta;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                response = null;
                return [4, model.create(__assign({}, bookConcept))];
            case 1:
                response = _c.sent();
                console.log(response.reference);
                return [2, response];
        }
    });
}); };
exports.createBookConcept = createBookConcept;
var updateBookConcept = function (space, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, bookConceptResponse, bookConcept;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                response = null;
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, data, {
                        new: true,
                        upsert: true,
                    })];
            case 1:
                response = _a.sent();
                return [3, 4];
            case 2: return [4, model.create(__assign({}, data))];
            case 3:
                response = _a.sent();
                _a.label = 4;
            case 4: return [4, model.find({
                    reference: response.reference,
                })];
            case 5:
                bookConceptResponse = _a.sent();
                bookConcept = null;
                if (bookConceptResponse.length > 0) {
                    bookConcept = bookConceptResponse[0];
                }
                return [2, {
                        bookConcept: bookConcept,
                    }];
        }
    });
}); };
exports.updateBookConcept = updateBookConcept;
var _ai_populate_for_concept = function (space, bookref, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log(bookref, reference);
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios.get("".concat(AI_API, "/").concat(SIMILARITY_ALGORITHM, "/").concat(space, "/populate-concept/").concat(bookref, "/").concat(reference), {})];
            case 2:
                _a.sent();
                console.log("populated keywords for " + bookref + ", " + reference);
                return [3, 4];
            case 3:
                err_1 = _a.sent();
                console.log(err_1);
                return [3, 4];
            case 4: return [2];
        }
    });
}); };
var getBookConcept = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                return [4, model.find()];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.getBookConcept = getBookConcept;
var getBookConceptsByBookReference = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                return [4, model.find({ bookref: bookref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getBookConceptsByBookReference = getBookConceptsByBookReference;
var getBookConceptByBookReference = function (space, bookref, conceptref) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                return [4, model.find({ bookref: bookref, reference: conceptref })];
            case 1:
                response = _a.sent();
                if (response.length > 0) {
                    return [2, response[0]];
                }
                return [2, null];
        }
    });
}); };
exports.getBookConceptByBookReference = getBookConceptByBookReference;
var getBookConceptById = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                return [4, model.find({ _id: _id })];
            case 1:
                res = _a.sent();
                if (res.length > 0) {
                    return [2, res[0]];
                }
                return [2];
        }
    });
}); };
exports.getBookConceptById = getBookConceptById;
var deleteBookConcept = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { bookConcept: _id }];
        }
    });
}); };
exports.deleteBookConcept = deleteBookConcept;
var deleteBookConceptByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                return [4, model.deleteMany({ reference: reference })];
            case 1:
                _a.sent();
                return [2, { bookConcept: reference }];
        }
    });
}); };
exports.deleteBookConceptByReference = deleteBookConceptByReference;
var addConcepts = function (space, bookref, conceptTitles) { return __awaiter(void 0, void 0, void 0, function () {
    var model, _payload, i, _a, _b;
    var _c, _d, _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0:
                model = getCollection(space, model_1.bookConceptCollection, model_1.bookConceptSchema);
                _payload = [];
                i = 0;
                _f.label = 1;
            case 1:
                if (!(i < conceptTitles.length)) return [3, 4];
                _b = (_a = _payload).push;
                _c = {};
                _d = {
                    filter: {
                        bookref: bookref,
                        name: conceptTitles[i],
                    }
                };
                _e = {
                    name: conceptTitles[i]
                };
                return [4, (0, service_1.nextval)("conceptId", bookref, space)];
            case 2:
                _b.apply(_a, [(_c.updateOne = (_d.update = (_e.reference = _f.sent(),
                        _e),
                        _d.upsert = true,
                        _d),
                        _c)]);
                _f.label = 3;
            case 3:
                i++;
                return [3, 1];
            case 4: return [4, model.bulkWrite(_payload)];
            case 5: return [2, _f.sent()];
        }
    });
}); };
exports.addConcepts = addConcepts;


/***/ }),

/***/ "./src/modules/book/concept/model.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/concept/model.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bookConceptCollection = exports.bookConceptSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var bookConceptSchema = new Schema({
    name: { type: String },
    description: { type: String },
    reference: { type: String },
    bookref: { type: String },
    themes: { type: Array },
}, { timestamps: true, strict: false, strictQuery: false });
exports.bookConceptSchema = bookConceptSchema;
var bookConceptCollection = "book.concept";
exports.bookConceptCollection = bookConceptCollection;


/***/ }),

/***/ "./src/modules/book/concept/prompt.ts":
/*!********************************************!*\
  !*** ./src/modules/book/concept/prompt.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBookConceptsPrompt = void 0;
var gptutils_1 = __webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME_GPT4_MINI = "gpt-4o-mini";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
var getBookConceptsPrompt = function (bookName, authorName) {
    return (0, gptutils_1.getPrompt)(_BOOK_CONCEPTS_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        modelName: _MODEL_NAME,
    });
};
exports.getBookConceptsPrompt = getBookConceptsPrompt;
var _BOOK_CONCEPTS_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            "role": "system",
            "content": [
                "You are an AI assistant tasked with generating lists of key concepts from books;",
                "Your goal is to extract a broad range of important concepts from the book and provide detailed yet concise descriptions for each;",
                "Each concept description should fit into a single paragraph;",
                "Identify and include key concepts from the book based on its content;",
                "For each key concept, provide a flexible number of themes related to that concept. Include as many themes as are applicable but do not enforce a strict number;",
                "Each theme should be represented as an object with 'title' and 'description' fields;",
                "The 'title' of each theme should be a unique name, and the 'description' should provide context about the theme;",
                "Each theme may have a flexible number of sub-themes. Include as many sub-themes as are applicable, but do not enforce a strict number;",
                "Each sub-theme should be represented as an object with 'title' and 'description' fields;",
                "Ensure that all themes and sub-themes across all key concepts are unique in their meaning and content to avoid redundancy;",
                "Provide the output as a JSON array, where each object represents a key concept and includes 'title', 'description', and a 'themes' field;",
                "The 'themes' field should be an array of objects, each containing 'title' and 'description', and optionally a 'subThemes' field, which is an array of objects with 'title' and 'description'.",
                "Ensure the JSON output is properly formatted with correct quotation and comma placement:",
                "1. Property names and string values must be enclosed in double quotes.",
                "2. No trailing commas are allowed.",
                "3. Each object and array should be correctly nested and closed.",
                "If 'bookName' and 'authorName' are provided, include them in the context, but do not quote them;",
                "Avoid HTML content in the output."
            ]
        },
        {
            "role": "user",
            "content": [
                "Generate a comprehensive list of key concepts covered in the book '{{bookName}}' by '{{authorName}}';",
                "Each key concept should be described in a detailed yet concise paragraph;",
                "For each key concept, provide a flexible number of themes related to that concept. Include as many themes as are applicable, but do not enforce a strict number;",
                "Each theme should be represented as an object with 'title' and 'description' fields;",
                "The 'title' of each theme should be a unique name, and the 'description' should provide context to assist GPT in understanding the theme better;",
                "Each theme may include a flexible number of sub-themes. Include as many sub-themes as are applicable, but do not enforce a strict number;",
                "Each sub-theme should be represented as an object with 'title' and 'description' fields;",
                "Ensure that all themes and sub-themes across all key concepts are unique in their meaning and content to avoid redundancy;",
                "Provide the output as a JSON array, where each object represents a key concept and includes 'title', 'description', and a 'themes' field;",
                "The 'themes' field should be an array of objects, each containing 'title' and 'description', and optionally a 'subThemes' field, which is an array of objects with 'title' and 'description'.",
                "Ensure the JSON output is correctly formatted, with proper use of double quotes and no trailing commas."
            ]
        }
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/concept/route.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/concept/route.ts ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/concept/service.ts");
module.exports = function (router) {
    router.put("/book/concept/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateBookConcept));
    router.post("/book/concept/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createBookConcept));
    router.post("/book/concept/:space/:bookref/generate-concepts", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.generateConcepts));
    router.get("/book/concept/:space/id/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookConceptById));
    router.get("/book/concept/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookConceptsByBookReference));
    router.get("/book/concept/:space/:bookref/:conceptref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookConceptByBookReference));
    router.delete("/book/concept/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookConcept));
    router.delete("/book/concept/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookConceptByReference));
};


/***/ }),

/***/ "./src/modules/book/concept/service.ts":
/*!*********************************************!*\
  !*** ./src/modules/book/concept/service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteBookConceptByReference = exports.deleteBookConcept = exports.getBookConceptByBookReference = exports.getBookConceptsByBookReference = exports.getBookConceptById = exports.getBookConcept = exports.updateBookConcept = exports.createBookConcept = exports.generateConcepts = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/concept/helper.ts"));
var generateConcepts = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.generateConcepts(req.params.space, req.params.bookref)];
            case 1:
                response = _a.sent();
                if (!response) {
                    res.status(404);
                    res.send({
                        errorMessage: "ISBN not found",
                    });
                    res.end();
                }
                else {
                    res.status(200);
                    res.send(response);
                    res.end();
                }
                return [2];
        }
    });
}); };
exports.generateConcepts = generateConcepts;
var createBookConcept = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookConcept;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createBookConcept(req.params.space, req.body, userId)];
            case 1:
                bookConcept = _a.sent();
                res.status(200);
                res.send(bookConcept);
                res.end();
                return [2];
        }
    });
}); };
exports.createBookConcept = createBookConcept;
var updateBookConcept = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookConcept;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateBookConcept(req.params.space, req.body, userId)];
            case 1:
                bookConcept = _a.sent();
                res.status(200);
                res.send(bookConcept);
                res.end();
                return [2];
        }
    });
}); };
exports.updateBookConcept = updateBookConcept;
var getBookConcept = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookConceptList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookConcept(req.params.space)];
            case 1:
                bookConceptList = _a.sent();
                res.status(200);
                res.send(bookConceptList);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookConcept = getBookConcept;
var getBookConceptById = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookConcept;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookConceptById(req.params.space, req.params.id)];
            case 1:
                bookConcept = _a.sent();
                res.status(200);
                res.send(bookConcept);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookConceptById = getBookConceptById;
var getBookConceptsByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookConcept;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookConceptsByBookReference(req.params.space, req.params.bookref)];
            case 1:
                bookConcept = _a.sent();
                res.status(200);
                res.send(bookConcept);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookConceptsByBookReference = getBookConceptsByBookReference;
var getBookConceptByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookConcept;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookConceptByBookReference(req.params.space, req.params.bookref, req.params.conceptref)];
            case 1:
                bookConcept = _a.sent();
                res.status(200);
                res.send(bookConcept);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookConceptByBookReference = getBookConceptByBookReference;
var deleteBookConcept = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookConcept(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookConcept = deleteBookConcept;
var deleteBookConceptByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookConceptByReference(req.params.space, req.params.reference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookConceptByReference = deleteBookConceptByReference;


/***/ }),

/***/ "./src/modules/book/conceptdetail/helper.ts":
/*!**************************************************!*\
  !*** ./src/modules/book/conceptdetail/helper.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createShortform = exports.deleteConceptDetail = exports.getConceptDetailsByBookReferenceShortform = exports.getConceptDetailsByBookReference = exports.updateConceptDetail = exports.createConceptDetail = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/conceptdetail/model.ts");
var BookHelper = __importStar(__webpack_require__(/*! ../helper */ "./src/modules/book/helper.ts"));
var ConceptHelper = __importStar(__webpack_require__(/*! ../concept/helper */ "./src/modules/book/concept/helper.ts"));
var ExtractHelper = __importStar(__webpack_require__(/*! ../extract/helper */ "./src/modules/book/extract/helper.ts"));
var ThemeHelper = __importStar(__webpack_require__(/*! ../theme/helper */ "./src/modules/book/theme/helper.ts"));
var NoteHelper = __importStar(__webpack_require__(/*! ../../note/helper */ "./src/modules/note/helper.ts"));
var Gptutils = __importStar(__webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/conceptdetail/prompt.ts");
var model_2 = __webpack_require__(/*! ../concept/model */ "./src/modules/book/concept/model.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var createConceptDetail = function (space, bookref, conceptref, payload, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var book, model, contextList, references, excludedBooks, gptResponseText, content, conceptDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(payload.type === "summary")) return [3, 2];
                return [4, _createSummary(space, bookref, conceptref)];
            case 1: return [2, _a.sent()];
            case 2: return [4, BookHelper.getBookByReference(space, bookref)];
            case 3:
                book = _a.sent();
                model = getCollection(space, model_1.conceptDetailCollection, model_1.conceptDetailSchema);
                return [4, model.find({
                        bookref: bookref,
                        conceptref: conceptref,
                        type: "context",
                    })];
            case 4:
                contextList = _a.sent();
                if (contextList.length === 0) {
                    return [2, {}];
                }
                return [4, model.find({
                        conceptref: { $ne: conceptref },
                        bookref: bookref,
                        type: "further_references",
                    })];
            case 5:
                references = _a.sent();
                excludedBooks = references
                    .flatMap(function (entry) {
                    return entry.content.map(function (item) {
                        return "".concat(item.book.replace(/,/g, " "), " by ").concat(item.author.replace(/,/g, " "));
                    });
                })
                    .join(", ");
                console.log(excludedBooks);
                return [4, Gptutils.predict((0, prompt_1.getSecondarySectionPrompt)(payload.type, book.title, book.primaryAuthor, contextList[0].content, excludedBooks))];
            case 6:
                gptResponseText = _a.sent();
                content = _processAiResponse(payload.type, gptResponseText);
                return [4, model.updateOne({
                        bookref: bookref,
                        conceptref: conceptref,
                        type: payload.type,
                    }, {
                        $set: {
                            customTitle: payload.sectionTitle,
                            customDescription: payload.sectionDescription,
                            content: content,
                        },
                    }, { upsert: true })];
            case 7:
                conceptDetail = _a.sent();
                return [2, conceptDetail];
        }
    });
}); };
exports.createConceptDetail = createConceptDetail;
var _createSummary = function (space, bookref, conceptref) { return __awaiter(void 0, void 0, void 0, function () {
    var book, concept, notes, notesList, extracts, themesList, themes, gptResponseText, content, model, conceptDetail, shorterSummary;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _a.sent();
                return [4, ConceptHelper.getBookConceptByBookReference(space, bookref, conceptref)];
            case 2:
                concept = _a.sent();
                return [4, NoteHelper.getNoteByBookref(space, bookref)];
            case 3:
                notes = _a.sent();
                notesList = [];
                _filterAndSortDomainByKeywordOverlap(concept.keywords, notes).forEach(function (item) { return notesList.push(item.content); });
                return [4, ExtractHelper.getExtractChunksByBookReference(space, bookref)];
            case 4:
                extracts = _a.sent();
                _filterAndSortDomainByKeywordOverlap(concept.keywords, extracts).forEach(function (item) { return notesList.push(item.summary); });
                return [4, ThemeHelper.getBookThemesByConceptReference(space, bookref, conceptref)];
            case 5:
                themesList = _a.sent();
                themes = _formatThemesForPrompt(themesList);
                console.log(notesList.length);
                console.log(concept.themes);
                return [4, Gptutils.predict((0, prompt_1.getSummarySectionPrompt)(book.title, book.primaryAuthor, concept.name, concept.description, themes, notesList))];
            case 6:
                gptResponseText = _a.sent();
                content = _processAiResponse("summary", gptResponseText);
                model = getCollection(space, model_1.conceptDetailCollection, model_1.conceptDetailSchema);
                return [4, model.updateOne({
                        bookref: bookref,
                        conceptref: conceptref,
                        type: "summary",
                    }, {
                        $set: {
                            content: content,
                        },
                    }, { upsert: true })];
            case 7:
                conceptDetail = _a.sent();
                return [4, _generateShorterSummaryForContext(book.title, book.primaryAuthor, gptResponseText)];
            case 8:
                shorterSummary = _a.sent();
                return [4, model.updateOne({
                        bookref: bookref,
                        conceptref: conceptref,
                        type: "context",
                    }, {
                        $set: {
                            content: shorterSummary,
                        },
                    }, { upsert: true })];
            case 9:
                _a.sent();
                return [2, conceptDetail];
        }
    });
}); };
var _generateShorterSummaryForContext = function (bookName, authorName, content) { return __awaiter(void 0, void 0, void 0, function () {
    var gptResponseText;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Gptutils.predict((0, prompt_1.getShortenContentPrompt)(bookName, authorName, content))];
            case 1:
                gptResponseText = _a.sent();
                return [2, gptResponseText];
        }
    });
}); };
function _formatThemesForPrompt(themes) {
    return themes
        .map(function (theme) { return "<strong>".concat(theme.title, ":</strong> ").concat(theme.description); })
        .join("<br><br>");
}
var _filterAndSortDomainByKeywordOverlap = function (inputKeywords, data) {
    return data
        .filter(function (item) { var _a; return (_a = item.keywords) === null || _a === void 0 ? void 0 : _a.some(function (keyword) { return inputKeywords === null || inputKeywords === void 0 ? void 0 : inputKeywords.includes(keyword); }); })
        .sort(function (a, b) {
        var _a, _b;
        var overlapA = (_a = a.keywords) === null || _a === void 0 ? void 0 : _a.filter(function (keyword) {
            return inputKeywords.includes(keyword);
        }).length;
        var overlapB = (_b = b.keywords) === null || _b === void 0 ? void 0 : _b.filter(function (keyword) {
            return inputKeywords.includes(keyword);
        }).length;
        return overlapB - overlapA;
    });
};
var _processAiResponse = function (type, text) {
    console.log(text);
    var htmlString = "";
    var data = text;
    switch (type) {
        case "further_references":
            data = JSON.parse(text);
            break;
        default:
            break;
    }
    switch (type) {
        case "further_references2":
            data.forEach(function (item) {
                htmlString += "\n          <li>\n            <strong><em>".concat(item.book, "</em></strong> by ").concat(item.author, " explores key themes such as ").concat(item.centralIdeas.join(", "), ". \n            ").concat(item.summary, "\n          </li>\n        ");
            });
            break;
        default:
            htmlString = data;
            break;
    }
    return htmlString;
};
var updateConceptDetail = function (space, id, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.conceptDetailCollection, model_1.conceptDetailSchema);
                response = null;
                return [4, model.findByIdAndUpdate(id, data, {})];
            case 1:
                response = _a.sent();
                return [2, response];
        }
    });
}); };
exports.updateConceptDetail = updateConceptDetail;
var getConceptDetailsByBookReference = function (space, bookref, conceptref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.conceptDetailCollection, model_1.conceptDetailSchema);
                return [4, model.find({ bookref: bookref, conceptref: conceptref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getConceptDetailsByBookReference = getConceptDetailsByBookReference;
var getConceptDetailsByBookReferenceShortform = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.conceptDetailCollection, model_1.conceptDetailSchema);
                return [4, model.find({ bookref: bookref, type: "summary" })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getConceptDetailsByBookReferenceShortform = getConceptDetailsByBookReferenceShortform;
var deleteConceptDetail = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.conceptDetailCollection, model_1.conceptDetailSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { conceptDetail: _id }];
        }
    });
}); };
exports.deleteConceptDetail = deleteConceptDetail;
var createShortform = function (space, bookref, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var book, notes, notesList, concepts, keyInsightsList, conceptMap, gptResponseText, gptResponse, model, conceptModel, keyInsightsDataMap, keyInsightsSummaryMap, bulkOperationsConcept, bulkOperationsConceptDetail;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _b.sent();
                return [4, NoteHelper.getNoteByBookref(space, bookref)];
            case 2:
                notes = _b.sent();
                notesList = [];
                notes.forEach(function (item) { return notesList.push(item.content); });
                return [4, ConceptHelper.getBookConceptsByBookReference(space, bookref)];
            case 3:
                concepts = _b.sent();
                keyInsightsList = [];
                conceptMap = {};
                concepts.forEach(function (item) {
                    keyInsightsList.push(item.name);
                    conceptMap[item.name] = item.reference;
                });
                return [4, Gptutils.predict((0, prompt_1.getBookShortFormPrompt)(book.title, book.primaryAuthor, notesList, keyInsightsList))];
            case 4:
                gptResponseText = _b.sent();
                console.log(gptResponseText);
                gptResponse = JSON.parse(gptResponseText);
                model = getCollection(space, model_1.conceptDetailCollection, model_1.conceptDetailSchema);
                conceptModel = getCollection(space, model_2.bookConceptCollection, model_2.bookConceptSchema);
                keyInsightsDataMap = {};
                keyInsightsSummaryMap = {};
                (_a = gptResponse.keyInsights) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
                    if (conceptMap[item.title])
                        keyInsightsDataMap[conceptMap[item.title]] = item.description;
                    keyInsightsSummaryMap[conceptMap[item.title]] = item.summary;
                });
                return [4, BookHelper.updateBook(space, book._id, { _id: book._id, overview: gptResponse.bookOverview.overview }, userId)];
            case 5:
                _b.sent();
                bulkOperationsConcept = Object.keys(keyInsightsDataMap).map(function (item) { return ({
                    updateOne: {
                        filter: {
                            bookref: book.reference,
                            reference: item,
                        },
                        update: {
                            $set: {
                                description: keyInsightsSummaryMap[item],
                            },
                        },
                        upsert: true,
                    },
                }); });
                bulkOperationsConceptDetail = Object.keys(keyInsightsDataMap).map(function (item) { return ({
                    updateOne: {
                        filter: {
                            bookref: book.reference,
                            conceptref: item,
                            type: "_shortform",
                        },
                        update: {
                            $set: {
                                type: "_shortform",
                                content: keyInsightsDataMap[item],
                            },
                        },
                        upsert: true,
                    },
                }); });
                return [4, model.bulkWrite(bulkOperationsConceptDetail)];
            case 6:
                _b.sent();
                return [2];
        }
    });
}); };
exports.createShortform = createShortform;


/***/ }),

/***/ "./src/modules/book/conceptdetail/model.ts":
/*!*************************************************!*\
  !*** ./src/modules/book/conceptdetail/model.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.conceptDetailCollection = exports.conceptDetailSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var conceptDetailSchema = new Schema({
    customTitle: { type: String },
    customDescription: { type: String },
    type: { type: String },
    conceptref: { type: String },
    bookref: { type: String },
    content: { type: JSON },
}, { timestamps: true, strict: false, strictQuery: false });
exports.conceptDetailSchema = conceptDetailSchema;
var conceptDetailCollection = "book.conceptdetail";
exports.conceptDetailCollection = conceptDetailCollection;


/***/ }),

/***/ "./src/modules/book/conceptdetail/prompt.ts":
/*!**************************************************!*\
  !*** ./src/modules/book/conceptdetail/prompt.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getShortenContentPrompt = exports.getBookShortFormPrompt = exports.getSummarySectionPrompt = exports.getSecondarySectionPrompt = void 0;
var gptutils_1 = __webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME_GPT4_MINI = "gpt-4o-mini";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
var getSecondarySectionPrompt = function (type, bookName, authorName, content, excludedBooks) {
    switch (type) {
        case "context":
            return (0, gptutils_1.getPrompt)(_SHORTEN_CONTENT_PROMPT, {
                bookName: bookName,
                authorName: authorName,
                content: content,
            });
        case "further_references":
            return (0, gptutils_1.getPrompt)(_FURTHER_REFERENCES_PROMPT, {
                bookName: bookName,
                authorName: authorName,
                content: content,
                excludedBooks: excludedBooks,
            });
        default:
            break;
    }
};
exports.getSecondarySectionPrompt = getSecondarySectionPrompt;
var getSummarySectionPrompt = function (bookName, authorName, keyConceptTitle, keyConceptDescription, themes, noteList) {
    var notes = noteList.join("/n");
    return (0, gptutils_1.getPrompt)(_SUMMARY_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        keyConceptTitle: keyConceptTitle,
        keyConceptDescription: keyConceptDescription,
        notes: notes,
        themes: themes,
    });
};
exports.getSummarySectionPrompt = getSummarySectionPrompt;
var getBookShortFormPrompt = function (bookName, authorName, notesList, keyInsightsList) {
    var keyInsights = keyInsightsList.join(", ");
    var notes = notesList.join("\n");
    return (0, gptutils_1.getPrompt)(_SHORTFORM_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        notes: notes,
        keyInsights: keyInsights,
    });
};
exports.getBookShortFormPrompt = getBookShortFormPrompt;
var _SHORTFORM_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: 'You are an AI assistant tasked with creating a comprehensive analysis of a book in JSON format. The output should contain only valid JSON without any extra text, comments, or explanations. Follow the structure below:\n\n{\n  "bookOverview": {\n    "overview": "string",\n    "authorInfo": "string"\n  },\n  "keyInsights": [\n    {"title": "string", "description": "html", "summary": "string"},\n    {"title": "string", "description": "html", "summary": "string"},\n    ...\n  ]\n}.\n\nInstructions:\n\n1. For the "bookOverview":\n- Provide a detailed summary of the book\'s main premise and significance (4-5 sentences).\n- Mention the author\'s background and expertise relevant to the book\'s topic (2-3 sentences).\n\n2. For "keyInsights":\n- Each key insight should have a title and a detailed description.\n- The description must be in HTML format, with each paragraph enclosed within <p> tags. Only <p>, <b>, and <i> tags are allowed.\n- The description should include an in-depth explanation of the insight (4-5 paragraphs), practical examples or applications (2-3 paragraphs), and any relevant statistics or research mentioned in the book.\n\nGuidelines:\n- Ensure that the total word count of the output is between 2500 and 3000 words.\n- Provide only the JSON output with no additional text.',
        },
        {
            role: "assistant",
            content: "Ensure that each key insight is elaborated with multiple paragraphs and detailed explanations, with each paragraph enclosed in <p> tags. For each key insight in {{keyInsights}}, provide a comprehensive analysis that includes examples, applications, and supporting evidence to meet the 2500-3000 word range. Output only valid JSON.",
        },
        {
            role: "user",
            content: "The book is '{{bookName}}' by {{authorName}}. The key insights are: {{keyInsights}}.",
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var getShortenContentPrompt = function (bookName, authorName, content) {
    return (0, gptutils_1.getPrompt)(_SHORTEN_CONTENT_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        content: content,
    });
};
exports.getShortenContentPrompt = getShortenContentPrompt;
var _SHORTEN_CONTENT_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI designed to provide a concise summary of the detailed exploration of a theme from a specific book.",
                "Your summary should capture the essence of the central theme and its sub-themes, while being brief and clear.",
                "Include references to the book name and author name to provide context for later prompts.",
                "Avoid unnecessary details and focus on the key points.",
                "When in doubt, it is safer to retain content rather than remove it. Ensure that important aspects of the theme and sub-themes are preserved.",
            ],
        },
        {
            role: "user",
            content: [
                "Summarize the following content into a shorter, concise version suitable for further analysis or interpretation. Include references to the book name {{bookName}} and author {{authorName}} in the summary:",
                "{{content}}",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _SUMMARY_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI designed to provide a detailed, logically structured, and informative explanation of a key concept explored in the book {{bookName}} by {{authorName}}.",
                "Ensure that your explanation directly describes the key concept without framing it as third-person commentary or narrative.",
                "Use clear, concise language to convey the information, maintaining a logical flow and coherence with smooth transitions between paragraphs.",
                "The notes provided are strictly for contextual understanding and should only be used where they are relevant to the book and the key concept being explored.",
                "However, they should not be treated as a source of information.",
                "You should rely on your own knowledge base to explain the concept and not use the notes as a foundation for building your logic.",
                "Format the output using HTML with paragraphs, lists, bold, and italic elements.",
                "Avoid including any extraneous tags or text.",
                "Ensure that the output always follows this structure:",
                "  - A few introductory paragraphs explaining the key concept.",
                "  - A bulleted list of key points, with the titles of each point bolded.",
                "  - A final few paragraphs to conclude the explanation.",
            ],
        },
        {
            role: "user",
            content: [
                "Explain the main ideas and arguments about {{keyConceptTitle}} from {{bookName}} by {{authorName}}, formatted in HTML with paragraphs, lists, bold, and italic elements.",
                "{{keyConceptDescription}}",
            ],
        },
        {
            role: "user",
            content: [
                "Use the following notes for contextual understanding only, and only where relevant to {{bookName}} by {{authorName}} and the key concept.",
                "Do not directly use these notes as a source for building your explanation:",
                "{{notes}}",
            ],
        },
        {
            role: "user",
            content: [
                "Here are the relevant themes for context in {{bookName}} by {{authorName}}:",
                "{{themes}}",
            ],
        },
        {
            role: "assistant",
            content: [
                "<p>{{keyConceptDescription}}</p>",
                "<p><strong>Key Ideas of {{keyConceptTitle}}:</strong></p>",
                "<ul>",
                "    <li><strong>{{KeyPointTitle1}}:</strong> {{KeyPointDescription1}}</li>",
                "    <li><strong>{{KeyPointTitle2}}:</strong> {{KeyPointDescription2}}</li>",
                "    <li><strong>{{KeyPointTitle3}}:</strong> {{KeyPointDescription3}}</li>",
                "</ul>",
                "<p>{{ConclusionParagraph1}}</p>",
                "<p>{{ConclusionParagraph2}}</p>",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _MINI_ESSAY_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "Provide a comprehensive explanation of {{keyConceptTitle}} from {{bookName}} by {{authorName}};",
                "Present the concept directly as it would be articulated in the book;",
                "The notes provided are strictly for contextual understanding and should only be used where they are relevant to the book and the key concept being explored;",
                "However, they should not be treated as a source of information;",
                "You should rely on your own knowledge base to explain the concept and not use the notes as a foundation for building your logic;",
                "Avoid commentary or third-person narrative, and instead, deliver the information in a clear, descriptive manner;",
                "Ensure that each paragraph is enclosed within <p> tags and that the explanation integrates related themes naturally and flows continuously;",
                "Exclude unnecessary tags, self-references, or apologies.",
            ],
        },
        {
            role: "user",
            content: [
                "Describe {{keyConceptTitle}} based on {{keyConceptDescription}};",
                "Illustrate its connections with other themes in the book directly and clearly.",
            ],
        },
        {
            role: "user",
            content: [
                "Use the following notes for contextual understanding only, and only where relevant to the book and key concept;",
                "Do not directly use these notes as a source for building your explanation: {{notes}}",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _EXPLAIN_TO_CHILD_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "Explain {{keyConceptTitle}} from {{bookName}} by {{authorName}} in a way that's easy for a small child to understand.",
                "Use simple words, short sentences, and relatable examples.",
                "The notes provided are strictly for contextual understanding and should only be used where they are relevant to the book and the key concept being explored.",
                "They should not be treated as a source of information.",
                "You should rely on your own knowledge base to explain the concept and not use the notes as a foundation for building your logic.",
                "Make sure to format the response in HTML paragraphs, without extra tags or text, and avoid self-references and apologies.",
            ],
        },
        {
            role: "user",
            content: [
                "Describe {{keyConceptTitle}} in a fun and easy way, connecting it to simple ideas and stories that a child would understand.",
            ],
        },
        {
            role: "user",
            content: [
                "Use the following notes for contextual understanding only, and only where relevant to the book and key concept.",
                "Do not directly use these notes as a source for building your explanation:",
                "{{notes}}",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _FURTHER_REFERENCES_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI designed to provide a list of references for further learning based on the provided content.",
                "Your task is to generate a list of references to other books or research papers that could deepen understanding or provide additional perspectives.",
                "The output must be strictly in JSON format, without any preceding or additional text.",
                "Each reference should be a JSON object with four fields: 'book', 'author', 'centralIdeas', and 'summary'.",
                "'book' should contain the book name or the research paper title.",
                "'author' should contain the author name.",
                "'centralIdeas' should be an array list of 2-5 central ideas from the book or research paper, highlighting the core concepts discussed.",
                "'summary' should be a 2-5 line explanation of the key concepts in this reference book. The summary may or may not be related to the main content, but it should independently highlight the key concepts from the reference book.",
            ],
        },
        {
            role: "user",
            content: [
                "Provide a list of references to other books or research papers for further learning based on the main content from the book {{bookName}} by {{authorName}}. For each reference, include the following details:",
                "1. 'book' field for the book name or research paper title.",
                "2. 'author' field for the author name.",
                "3. 'centralIdeas' field as an array list of 2-5 central ideas from the reference book or research paper.",
                "4. 'summary' field as a 2-5 line explanation of the key concepts in this reference book or paper.",
                "The summary can be related or unrelated to the main content, but should highlight the concepts independently.",
                "Ensure that none of the following books are included in the recommendations (leave blank if no exclusions):",
                "{{excludedBooks}}",
                "Here is the content for reference:",
                "{{content}}",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/conceptdetail/route.ts":
/*!*************************************************!*\
  !*** ./src/modules/book/conceptdetail/route.ts ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/conceptdetail/service.ts");
module.exports = function (router) {
    router.put("/book/concept-detail/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateConceptDetail));
    router.post("/book/concept-detail/:space/:bookref/:conceptref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createConceptDetail));
    router.get("/book/concept-detail/:space/:bookref/:conceptref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getConceptDetailsByBookReference));
    router.get("/book/concept-detail-shortform/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getConceptDetailsByBookReferenceShortform));
    router.delete("/book/concept-detail/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteConceptDetail));
};


/***/ }),

/***/ "./src/modules/book/conceptdetail/service.ts":
/*!***************************************************!*\
  !*** ./src/modules/book/conceptdetail/service.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteConceptDetail = exports.getConceptDetailsByBookReferenceShortform = exports.getConceptDetailsByBookReference = exports.updateConceptDetail = exports.createConceptDetail = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/conceptdetail/helper.ts"));
var createConceptDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, conceptDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createConceptDetail(req.params.space, req.params.bookref, req.params.conceptref, req.body, userId)];
            case 1:
                conceptDetail = _a.sent();
                res.status(200);
                res.send(conceptDetail);
                res.end();
                return [2];
        }
    });
}); };
exports.createConceptDetail = createConceptDetail;
var updateConceptDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, conceptDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateConceptDetail(req.params.space, req.params.id, req.body, userId)];
            case 1:
                conceptDetail = _a.sent();
                res.status(200);
                res.send(conceptDetail);
                res.end();
                return [2];
        }
    });
}); };
exports.updateConceptDetail = updateConceptDetail;
var getConceptDetailsByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, conceptDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getConceptDetailsByBookReference(req.params.space, req.params.bookref, req.params.conceptref)];
            case 1:
                conceptDetail = _a.sent();
                res.status(200);
                res.send(conceptDetail);
                res.end();
                return [2];
        }
    });
}); };
exports.getConceptDetailsByBookReference = getConceptDetailsByBookReference;
var getConceptDetailsByBookReferenceShortform = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, conceptDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getConceptDetailsByBookReferenceShortform(req.params.space, req.params.bookref)];
            case 1:
                conceptDetail = _a.sent();
                res.status(200);
                res.send(conceptDetail);
                res.end();
                return [2];
        }
    });
}); };
exports.getConceptDetailsByBookReferenceShortform = getConceptDetailsByBookReferenceShortform;
var deleteConceptDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteConceptDetail(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteConceptDetail = deleteConceptDetail;


/***/ }),

/***/ "./src/modules/book/extract/helper.ts":
/*!********************************************!*\
  !*** ./src/modules/book/extract/helper.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExtractChunksByBookReference = exports.deleteExtract = exports.getExtractsByBookReference = exports.updateExtract = exports.createExtract = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/extract/model.ts");
var Gptutils = __importStar(__webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/extract/prompt.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var SIMILARITY_ALGORITHM = "similarity";
var createExtract = function (space, bookref, payload, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, extract;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.extractCollection, model_1.extractSchema);
                return [4, model.create(__assign(__assign({}, payload), { bookref: bookref }))];
            case 1:
                extract = _a.sent();
                return [2, extract];
        }
    });
}); };
exports.createExtract = createExtract;
var updateExtract = function (space, bookref, id, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var gptResponseText, gptResponse, model, _id, rest, extractChunkModel, _payload, i, extractChunks, i;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Gptutils.predict((0, prompt_1.getAtomicChunksPrompt)(data.text))];
            case 1:
                gptResponseText = _a.sent();
                console.log(gptResponseText);
                gptResponse = JSON.parse(gptResponseText);
                console.log(gptResponse);
                model = getCollection(space, model_1.extractCollection, model_1.extractSchema);
                _id = data._id, rest = __rest(data, ["_id"]);
                extractChunkModel = getCollection(space, model_1.extractChunkCollection, model_1.extractChunkSchema);
                _payload = [];
                for (i = 0; i < gptResponse.length; i++) {
                    _payload.push({
                        insertOne: {
                            document: {
                                bookref: bookref,
                                conceptref: [],
                                extractId: id,
                                summary: gptResponse[i].summary,
                                text: gptResponse[i].content,
                            },
                        },
                    });
                }
                return [4, extractChunkModel.deleteMany({ extractId: id })];
            case 2:
                _a.sent();
                return [4, extractChunkModel.bulkWrite(_payload)];
            case 3:
                _a.sent();
                return [4, model.findByIdAndUpdate(id, __assign(__assign({}, rest), { chunks: _payload.length }), {
                        new: true,
                        upsert: true,
                    })];
            case 4:
                _a.sent();
                return [4, extractChunkModel.find({
                        bookref: bookref,
                        extractId: id,
                    })];
            case 5:
                extractChunks = _a.sent();
                console.log(extractChunks.length);
                i = 0;
                _a.label = 6;
            case 6:
                if (!(i < extractChunks.length)) return [3, 9];
                return [4, _ai_populate_for_extract(space, bookref, id, extractChunks[i]._id)];
            case 7:
                _a.sent();
                _a.label = 8;
            case 8:
                i++;
                return [3, 6];
            case 9: return [2];
        }
    });
}); };
exports.updateExtract = updateExtract;
var _ai_populate_for_extract = function (space, bookref, extractId, extractChunkId) { return __awaiter(void 0, void 0, void 0, function () {
    var err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, axios.get("".concat(AI_API, "/").concat(SIMILARITY_ALGORITHM, "/").concat(space, "/populate-extractchunk/").concat(bookref, "/").concat(extractId, "/").concat(extractChunkId), {})];
            case 1:
                _a.sent();
                console.log("populated keywords for " + bookref + ", " + extractChunkId);
                return [3, 3];
            case 2:
                err_1 = _a.sent();
                console.log(err_1);
                return [3, 3];
            case 3: return [2];
        }
    });
}); };
var getExtractsByBookReference = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.extractCollection, model_1.extractSchema);
                return [4, model.find({ bookref: bookref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getExtractsByBookReference = getExtractsByBookReference;
var deleteExtract = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.extractCollection, model_1.extractSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { extract: _id }];
        }
    });
}); };
exports.deleteExtract = deleteExtract;
var getExtractChunksByBookReference = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.extractChunkCollection, model_1.extractChunkSchema);
                return [4, model.find({ bookref: bookref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getExtractChunksByBookReference = getExtractChunksByBookReference;


/***/ }),

/***/ "./src/modules/book/extract/model.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/extract/model.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractChunkCollection = exports.extractChunkSchema = exports.extractCollection = exports.extractSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var extractSchema = new Schema({
    text: { type: String },
    bookref: { type: String },
    chunks: { type: Number },
}, { timestamps: true, strict: false, strictQuery: false });
exports.extractSchema = extractSchema;
var extractCollection = "book.extract";
exports.extractCollection = extractCollection;
var extractChunkSchema = new Schema({
    summary: { type: String },
    text: { type: String },
    bookref: { type: String },
    conceptref: { type: Array },
    extractId: { type: String },
}, { timestamps: true, strict: false, strictQuery: false });
exports.extractChunkSchema = extractChunkSchema;
var extractChunkCollection = "book.extractchunk";
exports.extractChunkCollection = extractChunkCollection;


/***/ }),

/***/ "./src/modules/book/extract/prompt.ts":
/*!********************************************!*\
  !*** ./src/modules/book/extract/prompt.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAtomicChunksPrompt = void 0;
var Handlebars = __importStar(__webpack_require__(/*! handlebars */ "handlebars"));
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
;
var getAtomicChunksPrompt = function (text) {
    return _getPrompt(_ATOMIC_CHUNKS_PROMPT, text);
};
exports.getAtomicChunksPrompt = getAtomicChunksPrompt;
var _getPrompt = function (_prompt, text) {
    var prompt = (0, lodash_1.cloneDeep)(_prompt);
    for (var i = 0; i < prompt.messages.length; i++) {
        prompt.messages[i].content = Handlebars.compile(prompt.messages[i].content)({ text: text });
    }
    console.log(prompt);
    return prompt;
};
var _ATOMIC_CHUNKS_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: "You are an assistant that processes a series of sentences from a whole text and breaks them into atomic groups based on meaning and context. For each group, create a JSON array of objects where each object has two fields: 'summary' (a single sentence that condenses the group's meaning) and 'content' (a concise form made by merging related sentences). Ensure that all key points and concepts in the input text are accurately represented in the output and that no important information is missing. The groups should be formed by your understanding of the entire text, not by dividing the text into passages.",
        },
        {
            role: "user",
            content: "{{text}}",
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/extract/route.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/extract/route.ts ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/extract/service.ts");
module.exports = function (router) {
    router.put("/book/extract/:space/:bookref/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateExtract));
    router.post("/book/extract/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createExtract));
    router.get("/book/extract/:space/bookref/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getExtractsByBookReference));
    router.delete("/book/extract/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteExtract));
};


/***/ }),

/***/ "./src/modules/book/extract/service.ts":
/*!*********************************************!*\
  !*** ./src/modules/book/extract/service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteExtract = exports.getExtractsByBookReference = exports.updateExtract = exports.createExtract = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/extract/helper.ts"));
var createExtract = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, extract;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createExtract(req.params.space, req.params.bookref, req.body, userId)];
            case 1:
                extract = _a.sent();
                res.status(200);
                res.send(extract);
                res.end();
                return [2];
        }
    });
}); };
exports.createExtract = createExtract;
var updateExtract = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, extract;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateExtract(req.params.space, req.params.bookref, req.params.id, req.body, userId)];
            case 1:
                extract = _a.sent();
                res.status(200);
                res.send(extract);
                res.end();
                return [2];
        }
    });
}); };
exports.updateExtract = updateExtract;
var getExtractsByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, extract;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getExtractsByBookReference(req.params.space, req.params.bookref)];
            case 1:
                extract = _a.sent();
                res.status(200);
                res.send(extract);
                res.end();
                return [2];
        }
    });
}); };
exports.getExtractsByBookReference = getExtractsByBookReference;
var deleteExtract = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteExtract(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteExtract = deleteExtract;


/***/ }),

/***/ "./src/modules/book/google_book_helper.ts":
/*!************************************************!*\
  !*** ./src/modules/book/google_book_helper.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBookMetadata = exports.getAllBooksByBookNameAndAuthor = exports.getBookMetadataByBookNameAndAuthor = exports.getBookMetadataByIsbn = exports.getMostRelevantBookMetadata = void 0;
var axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
var GOOGLE_BOOKS_API_KEY = "AIzaSyCUM3NDW_5h9faRaAliTVJ1IOnCQsDIyzs";
var WIKIPEDIA_API_URL = "https://en.wikipedia.org/w/api.php";
var getMostRelevantBookMetadata = function (bookName, authorName) { return __awaiter(void 0, void 0, void 0, function () {
    var query, url, response, items, books, relevantBook, allCategories_1, error_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                query = "intitle:".concat(bookName, "+inauthor:").concat(authorName);
                url = "https://www.googleapis.com/books/v1/volumes?q=".concat(query, "&key=").concat(GOOGLE_BOOKS_API_KEY);
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios_1.default.get(url)];
            case 2:
                response = _a.sent();
                items = response.data.items || [];
                if (items.length === 0) {
                    return [2, null];
                }
                books = items.map(function (item) {
                    var _a, _b, _c, _d, _e, _f, _g;
                    return ({
                        title: item.volumeInfo.title,
                        description: item.volumeInfo.description,
                        shortDescription: item.volumeInfo.shortDescription || "",
                        isbn: ((_b = (_a = item.volumeInfo.industryIdentifiers) === null || _a === void 0 ? void 0 : _a.find(function (id) { return id.type === "ISBN_13"; })) === null || _b === void 0 ? void 0 : _b.identifier) ||
                            ((_d = (_c = item.volumeInfo.industryIdentifiers) === null || _c === void 0 ? void 0 : _c.find(function (id) { return id.type === "ISBN_10"; })) === null || _d === void 0 ? void 0 : _d.identifier),
                        pageCount: item.volumeInfo.pageCount,
                        categories: item.volumeInfo.categories || [],
                        publisher: item.volumeInfo.publisher,
                        publishedDate: item.volumeInfo.publishedDate,
                        thumbnail: (_e = item.volumeInfo.imageLinks) === null || _e === void 0 ? void 0 : _e.thumbnail,
                        authors: item.volumeInfo.authors,
                        primaryAuthor: (_f = item.volumeInfo.authors) === null || _f === void 0 ? void 0 : _f[0],
                        chapterCount: ((_g = item.volumeInfo.tableOfContents) === null || _g === void 0 ? void 0 : _g.length) || 0,
                    });
                });
                relevantBook = books
                    .filter(function (book) {
                    var _a;
                    return book.title.toLowerCase() === bookName.toLowerCase() &&
                        ((_a = book.primaryAuthor) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === authorName.toLowerCase();
                })
                    .sort(function (a, b) {
                    return new Date(b.publishedDate).getTime() -
                        new Date(a.publishedDate).getTime();
                })[0];
                if (!relevantBook) {
                    relevantBook = books
                        .filter(function (book) { var _a; return ((_a = book.primaryAuthor) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === authorName.toLowerCase(); })
                        .sort(function (a, b) {
                        return new Date(b.publishedDate).getTime() -
                            new Date(a.publishedDate).getTime();
                    })[0];
                }
                if (!relevantBook) {
                    relevantBook = books
                        .filter(function (book) {
                        return book.title.toLowerCase().includes(bookName.toLowerCase());
                    })
                        .sort(function (a, b) {
                        return new Date(b.publishedDate).getTime() -
                            new Date(a.publishedDate).getTime();
                    })[0];
                }
                if (!relevantBook) {
                    relevantBook = books.sort(function (a, b) {
                        return new Date(b.publishedDate).getTime() -
                            new Date(a.publishedDate).getTime();
                    })[0];
                }
                allCategories_1 = new Set();
                books.forEach(function (book) {
                    return book.categories.forEach(function (category) { return allCategories_1.add(category); });
                });
                return [2, __assign(__assign({}, relevantBook), { categories: Array.from(allCategories_1) })];
            case 3:
                error_1 = _a.sent();
                console.error("Error retrieving book metadata:", error_1);
                return [2, null];
            case 4: return [2];
        }
    });
}); };
exports.getMostRelevantBookMetadata = getMostRelevantBookMetadata;
var getBookMetadataByIsbn = function (isbn) { return __awaiter(void 0, void 0, void 0, function () {
    var query, url, response, items, item, metadata, error_2;
    var _a, _b, _c, _d, _e, _f, _g;
    return __generator(this, function (_h) {
        switch (_h.label) {
            case 0:
                query = "isbn:".concat(isbn);
                url = "https://www.googleapis.com/books/v1/volumes?q=".concat(query, "&key=").concat(GOOGLE_BOOKS_API_KEY);
                _h.label = 1;
            case 1:
                _h.trys.push([1, 3, , 4]);
                return [4, axios_1.default.get(url)];
            case 2:
                response = _h.sent();
                items = response.data.items || [];
                if (items.length === 0) {
                    return [2, null];
                }
                item = items[0];
                console.log(item.volumeInfo.imageLinks);
                metadata = {
                    title: item.volumeInfo.title,
                    description: item.volumeInfo.description,
                    shortDescription: item.volumeInfo.shortDescription || "",
                    isbn: ((_b = (_a = item.volumeInfo.industryIdentifiers) === null || _a === void 0 ? void 0 : _a.find(function (id) { return id.type === "ISBN_13"; })) === null || _b === void 0 ? void 0 : _b.identifier) ||
                        ((_d = (_c = item.volumeInfo.industryIdentifiers) === null || _c === void 0 ? void 0 : _c.find(function (id) { return id.type === "ISBN_10"; })) === null || _d === void 0 ? void 0 : _d.identifier),
                    pageCount: item.volumeInfo.pageCount,
                    categories: item.volumeInfo.categories || [],
                    publisher: item.volumeInfo.publisher,
                    publishedDate: item.volumeInfo.publishedDate,
                    thumbnail: (_e = item.volumeInfo.imageLinks) === null || _e === void 0 ? void 0 : _e.thumbnail,
                    authors: item.volumeInfo.authors,
                    primaryAuthor: (_f = item.volumeInfo.authors) === null || _f === void 0 ? void 0 : _f[0],
                    chapterCount: ((_g = item.volumeInfo.tableOfContents) === null || _g === void 0 ? void 0 : _g.length) || 0,
                };
                return [2, metadata];
            case 3:
                error_2 = _h.sent();
                console.error("Error retrieving book metadata:", error_2);
                return [2, null];
            case 4: return [2];
        }
    });
}); };
exports.getBookMetadataByIsbn = getBookMetadataByIsbn;
var getBookMetadataByBookNameAndAuthor = function (bookName, authorName) { return __awaiter(void 0, void 0, void 0, function () {
    var query, url, response, items, bestMatch, metadata, error_3;
    var _a, _b, _c, _d, _e, _f, _g;
    return __generator(this, function (_h) {
        switch (_h.label) {
            case 0:
                query = "intitle:".concat(bookName, "+inauthor:").concat(authorName);
                url = "https://www.googleapis.com/books/v1/volumes?q=".concat(query, "&key=").concat(GOOGLE_BOOKS_API_KEY);
                _h.label = 1;
            case 1:
                _h.trys.push([1, 3, , 4]);
                return [4, axios_1.default.get(url)];
            case 2:
                response = _h.sent();
                items = response.data.items || [];
                if (items.length === 0) {
                    return [2, null];
                }
                bestMatch = items.find(function (item) {
                    var _a, _b;
                    var volumeInfo = item.volumeInfo;
                    return (((_a = volumeInfo.title) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === bookName.toLowerCase() &&
                        ((_b = volumeInfo.authors) === null || _b === void 0 ? void 0 : _b.some(function (author) {
                            return author.toLowerCase() === authorName.toLowerCase();
                        })));
                }) || items[0];
                console.log(bestMatch.volumeInfo.imageLinks);
                metadata = {
                    title: bestMatch.volumeInfo.title,
                    description: bestMatch.volumeInfo.description,
                    shortDescription: bestMatch.volumeInfo.shortDescription || "",
                    isbn: ((_b = (_a = bestMatch.volumeInfo.industryIdentifiers) === null || _a === void 0 ? void 0 : _a.find(function (id) { return id.type === "ISBN_13"; })) === null || _b === void 0 ? void 0 : _b.identifier) ||
                        ((_d = (_c = bestMatch.volumeInfo.industryIdentifiers) === null || _c === void 0 ? void 0 : _c.find(function (id) { return id.type === "ISBN_10"; })) === null || _d === void 0 ? void 0 : _d.identifier),
                    pageCount: bestMatch.volumeInfo.pageCount,
                    categories: bestMatch.volumeInfo.categories || [],
                    publisher: bestMatch.volumeInfo.publisher,
                    publishedDate: bestMatch.volumeInfo.publishedDate,
                    thumbnail: (_e = bestMatch.volumeInfo.imageLinks) === null || _e === void 0 ? void 0 : _e.thumbnail,
                    authors: bestMatch.volumeInfo.authors,
                    primaryAuthor: (_f = bestMatch.volumeInfo.authors) === null || _f === void 0 ? void 0 : _f[0],
                    chapterCount: ((_g = bestMatch.volumeInfo.tableOfContents) === null || _g === void 0 ? void 0 : _g.length) || 0,
                };
                return [2, metadata];
            case 3:
                error_3 = _h.sent();
                console.error("Error retrieving book metadata:", error_3);
                return [2, null];
            case 4: return [2];
        }
    });
}); };
exports.getBookMetadataByBookNameAndAuthor = getBookMetadataByBookNameAndAuthor;
var getAllBooksByBookNameAndAuthor = function (bookName, authorName) { return __awaiter(void 0, void 0, void 0, function () {
    var query, url, response, items, error_4;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                query = "intitle:".concat(bookName, "+inauthor:").concat(authorName);
                url = "https://www.googleapis.com/books/v1/volumes?q=".concat(query, "&key=").concat(GOOGLE_BOOKS_API_KEY);
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios_1.default.get(url)];
            case 2:
                response = _a.sent();
                items = response.data.items || [];
                if (items.length === 0) {
                    return [2, []];
                }
                return [2, items.map(function (bestMatch) {
                        var _a, _b, _c, _d, _e;
                        return ({
                            title: bestMatch.volumeInfo.title,
                            shortDescription: bestMatch.volumeInfo.shortDescription || "",
                            isbn: ((_b = (_a = bestMatch.volumeInfo.industryIdentifiers) === null || _a === void 0 ? void 0 : _a.find(function (id) { return id.type === "ISBN_13"; })) === null || _b === void 0 ? void 0 : _b.identifier) ||
                                ((_d = (_c = bestMatch.volumeInfo.industryIdentifiers) === null || _c === void 0 ? void 0 : _c.find(function (id) { return id.type === "ISBN_10"; })) === null || _d === void 0 ? void 0 : _d.identifier),
                            pageCount: bestMatch.volumeInfo.pageCount,
                            thumbnail: (_e = bestMatch.volumeInfo.imageLinks) === null || _e === void 0 ? void 0 : _e.thumbnail,
                        });
                    })];
            case 3:
                error_4 = _a.sent();
                console.error("Error retrieving book metadata:", error_4);
                return [2, []];
            case 4: return [2];
        }
    });
}); };
exports.getAllBooksByBookNameAndAuthor = getAllBooksByBookNameAndAuthor;
var getBookMetadata = function (isbn, bookName, authorName) { return __awaiter(void 0, void 0, void 0, function () {
    var fetchBookMetadata, items, query, item, metadata;
    var _a, _b, _c, _d, _e, _f, _g;
    return __generator(this, function (_h) {
        switch (_h.label) {
            case 0:
                fetchBookMetadata = function (query) { return __awaiter(void 0, void 0, void 0, function () {
                    var url, response, error_5;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                url = "https://www.googleapis.com/books/v1/volumes?q=".concat(query, "&key=").concat(GOOGLE_BOOKS_API_KEY);
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                return [4, axios_1.default.get(url)];
                            case 2:
                                response = _a.sent();
                                return [2, response.data.items || []];
                            case 3:
                                error_5 = _a.sent();
                                console.error("Error retrieving book metadata:", error_5);
                                return [2, []];
                            case 4: return [2];
                        }
                    });
                }); };
                return [4, fetchBookMetadata("isbn:".concat(isbn))];
            case 1:
                items = _h.sent();
                if (!(items.length === 0)) return [3, 3];
                query = "intitle:".concat(encodeURIComponent(bookName), "+inauthor:").concat(encodeURIComponent(authorName));
                return [4, fetchBookMetadata(query)];
            case 2:
                items = _h.sent();
                _h.label = 3;
            case 3:
                if (items.length === 0) {
                    return [2, null];
                }
                item = items[0];
                console.log(item.volumeInfo.imageLinks);
                metadata = {
                    title: item.volumeInfo.title,
                    description: item.volumeInfo.description,
                    shortDescription: item.volumeInfo.shortDescription || "",
                    isbn: ((_b = (_a = item.volumeInfo.industryIdentifiers) === null || _a === void 0 ? void 0 : _a.find(function (id) { return id.type === "ISBN_13"; })) === null || _b === void 0 ? void 0 : _b.identifier) ||
                        ((_d = (_c = item.volumeInfo.industryIdentifiers) === null || _c === void 0 ? void 0 : _c.find(function (id) { return id.type === "ISBN_10"; })) === null || _d === void 0 ? void 0 : _d.identifier),
                    pageCount: item.volumeInfo.pageCount,
                    categories: item.volumeInfo.categories || [],
                    publisher: item.volumeInfo.publisher,
                    publishedDate: item.volumeInfo.publishedDate,
                    thumbnail: (_e = item.volumeInfo.imageLinks) === null || _e === void 0 ? void 0 : _e.thumbnail,
                    authors: item.volumeInfo.authors,
                    primaryAuthor: (_f = item.volumeInfo.authors) === null || _f === void 0 ? void 0 : _f[0],
                    chapterCount: ((_g = item.volumeInfo.tableOfContents) === null || _g === void 0 ? void 0 : _g.length) || 0,
                };
                return [2, metadata];
        }
    });
}); };
exports.getBookMetadata = getBookMetadata;
var getAuthorInfo = function (authorName) { return __awaiter(void 0, void 0, void 0, function () {
    var response, pages, page, error_6;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, axios_1.default.get(WIKIPEDIA_API_URL, {
                        params: {
                            action: "query",
                            format: "json",
                            titles: authorName,
                            prop: "extracts",
                            exintro: true,
                            explaintext: true,
                            redirects: 1,
                        },
                    })];
            case 1:
                response = _a.sent();
                pages = response.data.query.pages;
                page = Object.values(pages)[0];
                if (page === null || page === void 0 ? void 0 : page.extract) {
                    return [2, page.extract];
                }
                return [2, null];
            case 2:
                error_6 = _a.sent();
                console.error("Error retrieving author information:", error_6);
                return [2, null];
            case 3: return [2];
        }
    });
}); };


/***/ }),

/***/ "./src/modules/book/helper.ts":
/*!************************************!*\
  !*** ./src/modules/book/helper.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.searchBook = exports.searchBookByText = exports.deleteBookByReference = exports.deleteBook = exports.getLibrariesByReferenceList = exports.getLibrariesByFolderIdList = exports.deleteBooksByFolderIdList = exports.getBookById = exports.getBookByReference = exports.getLibraries = exports.getBook = exports.getCoverImages = exports.updateChapterCount = exports.updateBook = exports.createBook = exports.validateBookUsingGoogleBookApi = exports.validateBook = void 0;
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/model.ts");
var getCollection = (__webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var service_1 = __webpack_require__(/*! ../sequence/service */ "./src/modules/sequence/service.ts");
var GoogleBookHelper = __importStar(__webpack_require__(/*! ./google_book_helper */ "./src/modules/book/google_book_helper.ts"));
var Utils_1 = __webpack_require__(/*! ../../lib/Utils */ "./src/lib/Utils.ts");
var Gptutils = __importStar(__webpack_require__(/*! ../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/prompt.ts");
var aihub_1 = __webpack_require__(/*! aihub */ "aihub");
var config = __webpack_require__(/*! ../../../env */ "./env.js");
var validateBook = function (book, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var gptResponse;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, aihub_1.ChatGpt.process(config.CHATGPT_API_KEY, "/v1/chat/completions", (0, prompt_1.getBookDetailPrompt)(book.title, book.primaryAuthor), "object")];
            case 1:
                gptResponse = _a.sent();
                return [2, {
                        data: gptResponse.isSuccessful
                            ? __assign({ title: gptResponse.responseObject.title, fullTitle: gptResponse.responseObject.fullBookName }, gptResponse.responseObject) : null,
                        outcome: {
                            status: gptResponse.isSuccessful && !gptResponse.responseObject.errorDescription
                                ? "success"
                                : "failure",
                            errorCode: gptResponse.errorCode,
                            errorDetails: gptResponse.errorDetails,
                            errorMessage: gptResponse.responseObject.errorDescription,
                        },
                    }];
        }
    });
}); };
exports.validateBook = validateBook;
var validateBookUsingGoogleBookApi = function (space_1, _a, userId_1) { return __awaiter(void 0, [space_1, _a, userId_1], void 0, function (space, _b, userId) {
    var gptResponseText, response;
    var book = _b.book;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4, Gptutils.predict((0, prompt_1.getBookDetailPrompt)(book.title, book.primaryAuthor))];
            case 1:
                gptResponseText = _c.sent();
                return [4, GoogleBookHelper.getMostRelevantBookMetadata(book.title, book.primaryAuthor)];
            case 2:
                response = _c.sent();
                console.log(response);
                if (!response) {
                    return [2, {
                            outcome: {
                                status: "failure",
                                message: "No book could be found with the details specified. Please provide more accurate details to do the search.",
                            },
                        }];
                }
                return [2, {
                        outcome: {
                            status: "success",
                        },
                        book: __assign({}, response),
                    }];
        }
    });
}); };
exports.validateBookUsingGoogleBookApi = validateBookUsingGoogleBookApi;
var createBook = function (space_1, _a, userId_1) { return __awaiter(void 0, [space_1, _a, userId_1], void 0, function (space, _b, userId) {
    var bookMetadata, model, response, _c, _d, _e;
    var _f;
    var book = _b.book, meta = _b.meta;
    return __generator(this, function (_g) {
        switch (_g.label) {
            case 0:
                if (!book.isManaged) return [3, 2];
                return [4, GoogleBookHelper.getBookMetadataByBookNameAndAuthor(book.title, book.primaryAuthor)];
            case 1:
                bookMetadata = _g.sent();
                if (bookMetadata) {
                    book.thumbnail = bookMetadata.thumbnail;
                    book.publisher = bookMetadata.publisher;
                    book.publishedDate = bookMetadata.publishedDate;
                }
                _g.label = 2;
            case 2:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                response = null;
                _d = (_c = model).create;
                _e = [__assign({}, book)];
                _f = {};
                return [4, (0, service_1.nextval)("bookId", undefined, space)];
            case 3: return [4, _d.apply(_c, [__assign.apply(void 0, _e.concat([(_f.reference = _g.sent(), _f)]))])];
            case 4:
                response = _g.sent();
                return [2, response];
        }
    });
}); };
exports.createBook = createBook;
var updateBook = function (space, bookId, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                response = null;
                return [4, model.findByIdAndUpdate(bookId, data, {
                        new: true,
                        upsert: true,
                    })];
            case 1:
                response = _a.sent();
                return [2, response];
        }
    });
}); };
exports.updateBook = updateBook;
var updateChapterCount = function (space, bookref, chapterCount) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.findOneAndUpdate({ reference: bookref }, { chapterCount: chapterCount }, {
                        upsert: true,
                    })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.updateChapterCount = updateChapterCount;
var getCoverImages = function (space, reference, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var book;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, (0, exports.getBookByReference)(space, reference)];
            case 1:
                book = _a.sent();
                return [4, GoogleBookHelper.getAllBooksByBookNameAndAuthor(book.title, book.primaryAuthor)];
            case 2: return [2, _a.sent()];
        }
    });
}); };
exports.getCoverImages = getCoverImages;
var getBook = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.find()];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.getBook = getBook;
var getLibraries = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.find()];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getLibraries = getLibraries;
var getBookByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.find({ reference: reference })];
            case 1:
                res = _a.sent();
                if (res.length === 0) {
                    return [2, null];
                }
                return [2, res[0]];
        }
    });
}); };
exports.getBookByReference = getBookByReference;
var getBookById = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.find({ _id: _id })];
            case 1:
                res = _a.sent();
                if (res.length > 0) {
                    return [2, res[0]];
                }
                return [2];
        }
    });
}); };
exports.getBookById = getBookById;
var deleteBooksByFolderIdList = function (space, folderIdList) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.deleteMany({ folderId: { $in: folderIdList } })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.deleteBooksByFolderIdList = deleteBooksByFolderIdList;
var getLibrariesByFolderIdList = function (space, folderIdList) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.find({ folderId: { $in: folderIdList } })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getLibrariesByFolderIdList = getLibrariesByFolderIdList;
var getLibrariesByReferenceList = function (space, refList) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.find({ reference: { $in: refList } })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getLibrariesByReferenceList = getLibrariesByReferenceList;
var deleteBook = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { book: _id }];
        }
    });
}); };
exports.deleteBook = deleteBook;
var deleteBookByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.deleteMany({ reference: reference })];
            case 1:
                _a.sent();
                return [2, { book: reference }];
        }
    });
}); };
exports.deleteBookByReference = deleteBookByReference;
var searchBookByText = function (space, text) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, model.find({
                        $text: { $search: "\"".concat(text, "\""), $caseSensitive: false },
                    })];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.searchBookByText = searchBookByText;
var searchBook = function (space, text, textList, searchPref) { return __awaiter(void 0, void 0, void 0, function () {
    var _text, model, condition, res;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _text = (_a = text === null || text === void 0 ? void 0 : text.toLowerCase()) === null || _a === void 0 ? void 0 : _a.replace(/ +/g, " ");
                model = getCollection(space, model_1.bookCollection, model_1.bookSchema);
                return [4, _getSearchCondition(space, _text, textList, searchPref)];
            case 1:
                condition = _b.sent();
                return [4, model.find({ $or: condition }).sort({ createdAt: -1 })];
            case 2:
                res = _b.sent();
                return [2, res.map(function (item) {
                        return __assign(__assign({}, item._doc), { summary: (0, Utils_1.isEmptyOrSpaces)(item.summary)
                                ? item.autoGeneratedSummary
                                : item.summary });
                    })];
        }
    });
}); };
exports.searchBook = searchBook;
var _getSearchCondition = function (space, text, textList, searchPref) { return __awaiter(void 0, void 0, void 0, function () {
    var searchFields, condition, isValidText;
    return __generator(this, function (_a) {
        searchFields = [];
        if (searchPref) {
            Object.keys(searchPref).forEach(function (fieldName) {
                if (searchPref[fieldName]) {
                    searchFields.push(fieldName);
                }
            });
        }
        condition = [];
        isValidText = !(0, Utils_1.isEmptyOrSpaces)(text);
        if (isValidText &&
            (searchFields.length === 0 || searchFields.includes("content"))) {
            condition.push({
                content: new RegExp(text, "i"),
            });
        }
        if (isValidText && searchFields.includes("name")) {
            condition.push({
                name: new RegExp(text, "i"),
            });
        }
        if (isValidText && searchFields.includes("labels")) {
            condition.push({
                labels: {
                    $in: text.split(" "),
                },
            });
        }
        if (searchFields.length === 1 &&
            searchFields.includes("labels") &&
            textList.length > 0) {
            condition.push({
                labels: {
                    $in: textList,
                },
            });
        }
        if (condition.length === 0) {
            return [2, [{}]];
        }
        return [2, condition];
    });
}); };


/***/ }),

/***/ "./src/modules/book/log/helper.ts":
/*!****************************************!*\
  !*** ./src/modules/book/log/helper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLog = exports.finishGenerating = exports.startGenerating = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/log/model.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var startGenerating = function (space, bookref, sectionref, sectiontype) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookLogCollection, model_1.bookLogSchema);
                return [4, model.deleteMany({ bookref: bookref, sectionref: sectionref, sectiontype: sectiontype })];
            case 1:
                _a.sent();
                return [4, model.updateOne({
                        bookref: bookref,
                        sectionref: sectionref,
                        sectiontype: sectiontype,
                    }, {
                        $set: {
                            isRunning: true,
                        },
                    }, { upsert: true })];
            case 2: return [2, _a.sent()];
        }
    });
}); };
exports.startGenerating = startGenerating;
var finishGenerating = function (space, bookref, sectionref, sectiontype) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookLogCollection, model_1.bookLogSchema);
                return [4, model.deleteMany({ bookref: bookref, sectionref: sectionref, sectiontype: sectiontype })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.finishGenerating = finishGenerating;
var getLog = function (space, bookref, sectionref, sectiontype) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookLogCollection, model_1.bookLogSchema);
                return [4, removeStaleLogs(space)];
            case 1:
                _a.sent();
                if (!!sectionref) return [3, 3];
                return [4, model.find({ bookref: bookref, sectionref: null })];
            case 2: return [2, _a.sent()];
            case 3:
                if (!!sectiontype) return [3, 5];
                return [4, model.find({ bookref: bookref, sectionref: sectionref })];
            case 4: return [2, _a.sent()];
            case 5: return [4, model.find({ bookref: bookref, sectionref: sectionref, sectiontype: sectiontype })];
            case 6: return [2, _a.sent()];
        }
    });
}); };
exports.getLog = getLog;
var removeStaleLogs = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookLogCollection, model_1.bookLogSchema);
                return [4, model.deleteMany({
                        createdAt: { $lt: new Date(Date.now() - 2 * 60 * 1000) },
                    })];
            case 1: return [2, _a.sent()];
        }
    });
}); };


/***/ }),

/***/ "./src/modules/book/log/model.ts":
/*!***************************************!*\
  !*** ./src/modules/book/log/model.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bookLogCollection = exports.bookLogSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var bookLogSchema = new Schema({
    sectiontype: { type: String },
    sectionref: { type: String },
    bookref: { type: String },
    isRunning: { type: Boolean },
}, { timestamps: true, strict: false, strictQuery: false });
exports.bookLogSchema = bookLogSchema;
var bookLogCollection = "book.log";
exports.bookLogCollection = bookLogCollection;


/***/ }),

/***/ "./src/modules/book/log/route.ts":
/*!***************************************!*\
  !*** ./src/modules/book/log/route.ts ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/log/service.ts");
module.exports = function (router) {
    router.get("/book/log/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getLog));
    router.get("/book/log/:space/:bookref/:sectionref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getLog));
    router.get("/book/log/:space/:bookref/:sectionref/:sectiontype", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getLog));
};


/***/ }),

/***/ "./src/modules/book/log/service.ts":
/*!*****************************************!*\
  !*** ./src/modules/book/log/service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLog = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/log/helper.ts"));
var getLog = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getLog(req.params.space, req.params.bookref, req.params.sectionref, req.params.sectiontype)];
            case 1:
                response = _a.sent();
                res.status(200);
                res.send(response);
                res.end();
                return [2];
        }
    });
}); };
exports.getLog = getLog;


/***/ }),

/***/ "./src/modules/book/model.ts":
/*!***********************************!*\
  !*** ./src/modules/book/model.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bookCollection = exports.bookSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var bookSchema = new Schema({
    title: { type: String },
    fullTitle: { type: String },
    reference: { type: String },
    description: { type: String },
    shortDescription: { type: String },
    overview: { type: String },
    authors: { type: Array },
    primaryAuthor: { type: String },
    authorInfo: { type: String },
    categories: { type: Array },
    isManaged: { type: Boolean },
    isbn: { type: String },
    pageCount: { type: Number },
    chapterCount: { type: Number },
    publishedDate: { type: String },
    publisher: { type: String },
    thumbnail: { type: String },
    readingProgress: { type: String },
    startedReadingOn: { type: Date }
}, { timestamps: true, strict: false, strictQuery: false });
exports.bookSchema = bookSchema;
var bookCollection = "book";
exports.bookCollection = bookCollection;


/***/ }),

/***/ "./src/modules/book/prompt.ts":
/*!************************************!*\
  !*** ./src/modules/book/prompt.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBookDetailPrompt = void 0;
var Handlebars = __importStar(__webpack_require__(/*! handlebars */ "handlebars"));
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
var getBookDetailPrompt = function (bookName, authorName) {
    var prompt = (0, lodash_1.cloneDeep)(_BOOK_DETAIL_PROMPT);
    prompt.messages[prompt.messages.length - 1].content = Handlebars.compile(prompt.messages[prompt.messages.length - 1].content)({
        bookName: bookName,
        authorName: authorName,
        modelName: _MODEL_NAME,
    });
    return prompt;
};
exports.getBookDetailPrompt = getBookDetailPrompt;
var _BOOK_DETAIL_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: "You are a highly intelligent assistant that processes book details.",
        },
        {
            role: "system",
            content: "When given a book name and author name, verify the book's existence.",
        },
        {
            role: "system",
            content: "If the book is valid, return only a JSON object with 'categories' (as an array), 'description' (a detailed description of 2 to 5 paragraphs), 'shortDescription' (a single paragraph summary), 'fullBookName', 'title', 'pageCount', 'authors' (as an array), 'primaryAuthor', 'publishedDate', 'isbn', 'authorInfo' (a paragraph of information about the author's major works and achievements), and 'chapterCount' (the total number of chapters in the book). If the book is part of a multi-volume series, combine the number of chapters from all volumes in 'chapterCount'. The 'authors' field should be an array ordered by the popularity of the authors. If the book cannot be found, return only a JSON object with 'errorDescription'. The response must be in JSON format only, without any additional text.",
        },
        {
            role: "user",
            content: "Please find the details for the book '{{bookName}}' authored by '{{authorName}}'.",
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/route.ts":
/*!***********************************!*\
  !*** ./src/modules/book/route.ts ***!
  \***********************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var multer = __webpack_require__(/*! multer */ "multer");
var storage = multer.memoryStorage();
var upload = multer({ storage: storage });
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/service.ts");
module.exports = function (router) {
    router.put("/book/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateBook));
    router.post("/book/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createBook));
    router.post("/book/:space/validate-book", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.validateBook));
    router.post("/book/:space/search", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.searchBook));
    router.get("/book/:space/reference/:reference/cover-images", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getCoverImages));
    router.get("/book/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getLibraries));
    router.get("/book/:space/id/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookById));
    router.get("/book/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookByReference));
    router.delete("/book/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBook));
    router.delete("/book/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookByReference));
};


/***/ }),

/***/ "./src/modules/book/section/helper.ts":
/*!********************************************!*\
  !*** ./src/modules/book/section/helper.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addSections = exports.deleteBookSectionByReference = exports.deleteBookSection = exports.getBookSectionById = exports.getBookSectionByBookReference = exports.getBookSectionsByBookReference = exports.getBookSection = exports.updateBookSection = exports.createBookSection = exports.generateSections = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/section/model.ts");
var BookHelper = __importStar(__webpack_require__(/*! ../helper */ "./src/modules/book/helper.ts"));
var ExtractHelper = __importStar(__webpack_require__(/*! ../extract/helper */ "./src/modules/book/extract/helper.ts"));
var NoteHelper = __importStar(__webpack_require__(/*! ../../note/helper */ "./src/modules/note/helper.ts"));
var service_1 = __webpack_require__(/*! ../../sequence/service */ "./src/modules/sequence/service.ts");
var Gptutils = __importStar(__webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/section/prompt.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var SIMILARITY_ALGORITHM = "similarity";
var SEQUENCE_ID = "bookSectionReference";
var generateSections = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var book, chaptersList, chapters, sections, model, _payload, i, _a, _b;
    var _c, _d, _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _f.sent();
                if (!book || !book.isManaged) {
                    return [2, null];
                }
                return [4, _getChaptersList(space, bookref)];
            case 2:
                chaptersList = _f.sent();
                chapters = chaptersList
                    .map(function (chapter) { return "".concat(chapter.title, ": ").concat(chapter.subtitle); })
                    .join("\n");
                return [4, _createSummary(space, bookref, chapters)];
            case 3:
                sections = _f.sent();
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                _payload = [];
                i = 0;
                _f.label = 4;
            case 4:
                if (!(i < sections.length)) return [3, 7];
                _b = (_a = _payload).push;
                _c = {};
                _d = {
                    filter: {
                        bookref: bookref,
                        title: sections[i].title,
                    }
                };
                _e = {
                    title: sections[i].title,
                    description: sections[i].summary
                };
                return [4, (0, service_1.nextval)(SEQUENCE_ID, bookref, space)];
            case 5:
                _b.apply(_a, [(_c.updateOne = (_d.update = (_e.reference = _f.sent(),
                        _e),
                        _d.upsert = true,
                        _d),
                        _c)]);
                _f.label = 6;
            case 6:
                i++;
                return [3, 4];
            case 7: return [4, model.deleteMany({ bookref: bookref })];
            case 8:
                _f.sent();
                return [4, model.bulkWrite(_payload)];
            case 9:
                _f.sent();
                return [4, BookHelper.updateChapterCount(space, bookref, _payload.length)];
            case 10:
                _f.sent();
                return [2, sections];
        }
    });
}); };
exports.generateSections = generateSections;
var _createSummary = function (space, bookref, chapters) { return __awaiter(void 0, void 0, void 0, function () {
    var book, notes, notesList, extracts, gptResponseText, gptResponse, _data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _a.sent();
                return [4, NoteHelper.getNoteByBookref(space, bookref)];
            case 2:
                notes = _a.sent();
                notesList = [];
                notes.forEach(function (item) { return notesList.push(item.content); });
                return [4, ExtractHelper.getExtractChunksByBookReference(space, bookref)];
            case 3:
                extracts = _a.sent();
                extracts.forEach(function (item) { return notesList.push(item.summary); });
                return [4, Gptutils.predict((0, prompt_1.getSummarySectionPrompt)(book.title, book.primaryAuthor, chapters, notesList))];
            case 4:
                gptResponseText = _a.sent();
                console.log(gptResponseText);
                gptResponse = JSON.parse(gptResponseText);
                _data = [];
                gptResponse.forEach(function (section) {
                    var _a;
                    var tempText = "".concat(section.content);
                    (_a = section.subsections) === null || _a === void 0 ? void 0 : _a.forEach(function (subsection) {
                        tempText += "<b>".concat(subsection.title, "</b>").concat(subsection.content);
                    });
                    _data.push({ title: section.title, summary: tempText });
                });
                return [2, _data];
        }
    });
}); };
var _getChaptersList = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var book, notes, notesList, extracts, gptResponseText, gptResponse;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _a.sent();
                return [4, NoteHelper.getNoteByBookref(space, bookref)];
            case 2:
                notes = _a.sent();
                notesList = [];
                notes.forEach(function (item) { return notesList.push(item.content); });
                return [4, ExtractHelper.getExtractChunksByBookReference(space, bookref)];
            case 3:
                extracts = _a.sent();
                extracts.forEach(function (item) { return notesList.push(item.summary); });
                return [4, Gptutils.predict((0, prompt_1.getChaptersListPrompt)(book.title, book.primaryAuthor, book.chapterCount, notesList))];
            case 4:
                gptResponseText = _a.sent();
                gptResponse = JSON.parse(gptResponseText);
                return [2, gptResponse];
        }
    });
}); };
var _processAiResponse = function (type, text) {
    var htmlString = "";
    var data = text;
    console.log("****", data);
    switch (type) {
        case "summary":
        case "presummary":
            data = JSON.parse(text);
            break;
        default:
            break;
    }
    switch (type) {
        case "presummary":
            var _data_1 = [];
            data.forEach(function (section) {
                var _a;
                var tempText = "".concat(section.content);
                (_a = section.subsections) === null || _a === void 0 ? void 0 : _a.forEach(function (subsection) {
                    tempText += "<b>".concat(subsection.title, "</b>").concat(subsection.content);
                });
                _data_1.push({ title: section.title, summary: tempText });
            });
            htmlString = _data_1;
            break;
        case "summary":
            console.log("--", data);
            data.forEach(function (section) {
                htmlString += "<h4>".concat(section.title, "</h4>");
                htmlString += section.content;
            });
            break;
        default:
            htmlString = data;
            break;
    }
    return htmlString;
};
var createBookSection = function (space, bookref, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, _a, _b, _c;
    var _d;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                response = null;
                _b = (_a = model).create;
                _c = [__assign({}, data)];
                _d = { bookref: bookref };
                return [4, (0, service_1.nextval)(SEQUENCE_ID, bookref, space)];
            case 1: return [4, _b.apply(_a, [__assign.apply(void 0, _c.concat([(_d.reference = _e.sent(), _d)]))])];
            case 2:
                response = _e.sent();
                return [2, response];
        }
    });
}); };
exports.createBookSection = createBookSection;
var updateBookSection = function (space, bookref, sectionref, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, _a, title, description;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                response = null;
                _a = __assign({}, data), title = _a.title, description = _a.description;
                return [4, model.findOneAndUpdate({ bookref: bookref, reference: sectionref }, { title: title, description: description }, {
                        upsert: true,
                    })];
            case 1:
                response = _b.sent();
                return [2, response];
        }
    });
}); };
exports.updateBookSection = updateBookSection;
var _ai_populate_for_section = function (space, bookref, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log(bookref, reference);
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios.get("".concat(AI_API, "/").concat(SIMILARITY_ALGORITHM, "/").concat(space, "/populate-section/").concat(bookref, "/").concat(reference), {})];
            case 2:
                _a.sent();
                console.log("populated keywords for " + bookref + ", " + reference);
                return [3, 4];
            case 3:
                err_1 = _a.sent();
                console.log(err_1);
                return [3, 4];
            case 4: return [2];
        }
    });
}); };
var getBookSection = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                return [4, model.find()];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.getBookSection = getBookSection;
var getBookSectionsByBookReference = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                return [4, model.find({ bookref: bookref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getBookSectionsByBookReference = getBookSectionsByBookReference;
var getBookSectionByBookReference = function (space, bookref, sectionref) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                return [4, model.find({ bookref: bookref, reference: sectionref })];
            case 1:
                response = _a.sent();
                if (response.length > 0) {
                    return [2, response[0]];
                }
                return [2, null];
        }
    });
}); };
exports.getBookSectionByBookReference = getBookSectionByBookReference;
var getBookSectionById = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                return [4, model.find({ _id: _id })];
            case 1:
                res = _a.sent();
                if (res.length > 0) {
                    return [2, res[0]];
                }
                return [2];
        }
    });
}); };
exports.getBookSectionById = getBookSectionById;
var deleteBookSection = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { bookSection: _id }];
        }
    });
}); };
exports.deleteBookSection = deleteBookSection;
var deleteBookSectionByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                return [4, model.deleteMany({ reference: reference })];
            case 1:
                _a.sent();
                return [2, { bookSection: reference }];
        }
    });
}); };
exports.deleteBookSectionByReference = deleteBookSectionByReference;
var addSections = function (space, bookref, sectionTitles) { return __awaiter(void 0, void 0, void 0, function () {
    var model, _payload, i, _a, _b;
    var _c, _d, _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0:
                model = getCollection(space, model_1.bookSectionCollection, model_1.bookSectionSchema);
                _payload = [];
                i = 0;
                _f.label = 1;
            case 1:
                if (!(i < sectionTitles.length)) return [3, 4];
                _b = (_a = _payload).push;
                _c = {};
                _d = {
                    filter: {
                        bookref: bookref,
                        name: sectionTitles[i],
                    }
                };
                _e = {
                    name: sectionTitles[i]
                };
                return [4, (0, service_1.nextval)("sectionId", bookref, space)];
            case 2:
                _b.apply(_a, [(_c.updateOne = (_d.update = (_e.reference = _f.sent(),
                        _e),
                        _d.upsert = true,
                        _d),
                        _c)]);
                _f.label = 3;
            case 3:
                i++;
                return [3, 1];
            case 4: return [4, model.bulkWrite(_payload)];
            case 5: return [2, _f.sent()];
        }
    });
}); };
exports.addSections = addSections;


/***/ }),

/***/ "./src/modules/book/section/model.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/section/model.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bookSectionCollection = exports.bookSectionSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var bookSectionSchema = new Schema({
    title: { type: String },
    description: { type: String },
    reference: { type: String },
    bookref: { type: String },
    themes: { type: Array },
}, { timestamps: true, strict: false, strictQuery: false });
exports.bookSectionSchema = bookSectionSchema;
var bookSectionCollection = "book.section";
exports.bookSectionCollection = bookSectionCollection;


/***/ }),

/***/ "./src/modules/book/section/prompt.ts":
/*!********************************************!*\
  !*** ./src/modules/book/section/prompt.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChaptersListPrompt = exports.getSummarySectionPrompt = void 0;
var gptutils_1 = __webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME_GPT4_MINI = "gpt-4o-mini";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
var getSummarySectionPrompt = function (bookName, authorName, chapters, noteList) {
    var notes = noteList.join("/n");
    return (0, gptutils_1.getPrompt)(_SUMMARY_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        chapters: chapters,
        notes: notes,
    });
};
exports.getSummarySectionPrompt = getSummarySectionPrompt;
var getChaptersListPrompt = function (bookName, authorName, chapterCount, noteList) {
    var notes = noteList.join("/n");
    return (0, gptutils_1.getPrompt)(_CHAPTERS_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        chapterCount: chapterCount,
        notes: notes,
    });
};
exports.getChaptersListPrompt = getChaptersListPrompt;
var _SUMMARY_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI assistant and expert book reader.",
                "Provide comprehensive chapter-by-chapter summaries, ensuring all major plot points, character developments, and themes are included.",
                "Follow the chapters as given by the user, ensuring logical flow and organization of the book's content.",
                "Ensure the content is distributed naturally across the chapters, fitting all key events and elements of the book appropriately.",
                "Each section should capture the essence of the chapter with a detailed summary of at least one paragraph, covering all important aspects without oversimplifying.",
                "Format using <p>, <i>, and <b> tags only when necessary.",
                'Do not include any explanations, only provide a  RFC8259 compliant JSON response following this format without deviation. [{"title": "section title", "content": "section summary", "subsections": [{"title": "sub-section title", "content": "sub-section summary"}]}].',
            ],
        },
        {
            role: "user",
            content: [
                "Provide a detailed summary of {{bookName}} by {{authorName}}.",
                "Use the list of chapter titles provided in {{chapters}} to organize the book's content logically.",
                "Ensure all key details and content of the book are covered within the chapter summaries, flowing correctly from one chapter to the next as per the book's structure.",
                "Each section must cover key details comprehensively without oversimplification and maintain conciseness, providing at least a paragraph for each chapter.",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 8192,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _CHAPTERS_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "Use the provided book name {{bookName}}.",
                "Use the author name {{authorName}}.",
                "Use the chapter count {{chapterCount}}.",
                "Generate a list of chapter titles that closely follow the actual structure and flow of the book, wherever possible.",
                "If the original book does not have enough distinct chapters to meet the chapterCount, distribute additional chapters evenly throughout the books content, while maintaining logical divisions.",
                "Ensure the number of chapters generated is exactly equal to the chapterCount specified.",
                "If chapters are numbered without titles, create suitable titles based on their content.",
                "Do not include any chapter number prefix in the chapter titles. Do not repeat chapter title in chapter subtitle.",
                'Do not include any explanations, only provide a  RFC8259 compliant JSON response following this format without deviation. [{"title": "chapter title", "subtitle": "a short one line text to give a context of wht the chapter is about"}].',
            ],
        },
        {
            role: "user",
            content: [
                "Book name is {{bookName}}.",
                "Author name is {{authorName}}.",
                "Number of chapters is {{chapterCount}}.",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/section/route.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/section/route.ts ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/section/service.ts");
module.exports = function (router) {
    router.put("/book/section/:space/:bookref/:sectionref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateBookSection));
    router.post("/book/section/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createBookSection));
    router.post("/book/section/:space/:bookref/generate-sections", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.generateSections));
    router.get("/book/section/:space/id/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookSectionById));
    router.get("/book/section/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookSectionsByBookReference));
    router.get("/book/section/:space/:bookref/:sectionref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookSectionByBookReference));
    router.delete("/book/section/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookSection));
    router.delete("/book/section/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookSectionByReference));
};


/***/ }),

/***/ "./src/modules/book/section/service.ts":
/*!*********************************************!*\
  !*** ./src/modules/book/section/service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteBookSectionByReference = exports.deleteBookSection = exports.getBookSectionByBookReference = exports.getBookSectionsByBookReference = exports.getBookSectionById = exports.getBookSection = exports.updateBookSection = exports.createBookSection = exports.generateSections = void 0;
var helper_1 = __webpack_require__(/*! ../log/helper */ "./src/modules/book/log/helper.ts");
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/section/helper.ts"));
var generateSections = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, (0, helper_1.startGenerating)(req.params.space, req.params.bookref)];
            case 1:
                _a.sent();
                res.status(202).send({
                    message: "Section generation started. You will be notified upon completion.",
                });
                return [4, Helper.generateSections(req.params.space, req.params.bookref)];
            case 2:
                _a.sent();
                return [4, (0, helper_1.finishGenerating)(req.params.space, req.params.bookref)];
            case 3:
                _a.sent();
                return [2];
        }
    });
}); };
exports.generateSections = generateSections;
var createBookSection = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSection;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createBookSection(req.params.space, req.params.bookref, req.body, userId)];
            case 1:
                bookSection = _a.sent();
                res.status(200);
                res.send(bookSection);
                res.end();
                return [2];
        }
    });
}); };
exports.createBookSection = createBookSection;
var updateBookSection = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSection;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateBookSection(req.params.space, req.params.bookref, req.params.sectionref, req.body, userId)];
            case 1:
                bookSection = _a.sent();
                res.status(200);
                res.send(bookSection);
                res.end();
                return [2];
        }
    });
}); };
exports.updateBookSection = updateBookSection;
var getBookSection = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSectionList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookSection(req.params.space)];
            case 1:
                bookSectionList = _a.sent();
                res.status(200);
                res.send(bookSectionList);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookSection = getBookSection;
var getBookSectionById = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSection;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookSectionById(req.params.space, req.params.id)];
            case 1:
                bookSection = _a.sent();
                res.status(200);
                res.send(bookSection);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookSectionById = getBookSectionById;
var getBookSectionsByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSection;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookSectionsByBookReference(req.params.space, req.params.bookref)];
            case 1:
                bookSection = _a.sent();
                res.status(200);
                res.send(bookSection);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookSectionsByBookReference = getBookSectionsByBookReference;
var getBookSectionByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSection;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookSectionByBookReference(req.params.space, req.params.bookref, req.params.sectionref)];
            case 1:
                bookSection = _a.sent();
                res.status(200);
                res.send(bookSection);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookSectionByBookReference = getBookSectionByBookReference;
var deleteBookSection = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookSection(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookSection = deleteBookSection;
var deleteBookSectionByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookSectionByReference(req.params.space, req.params.reference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookSectionByReference = deleteBookSectionByReference;


/***/ }),

/***/ "./src/modules/book/sectiondetail/helper.ts":
/*!**************************************************!*\
  !*** ./src/modules/book/sectiondetail/helper.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateAllSectionSummaries = exports.addSectionDetailPlaceholder = exports.deleteDetail = exports.getDetailsByBookReferenceShortform = exports.getDetailsByBookReference = exports.updateDetail = exports.createDetail = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/sectiondetail/model.ts");
var BookHelper = __importStar(__webpack_require__(/*! ../helper */ "./src/modules/book/helper.ts"));
var ExtractHelper = __importStar(__webpack_require__(/*! ../extract/helper */ "./src/modules/book/extract/helper.ts"));
var SectionHelper = __importStar(__webpack_require__(/*! ../section/helper */ "./src/modules/book/section/helper.ts"));
var NoteHelper = __importStar(__webpack_require__(/*! ../../note/helper */ "./src/modules/note/helper.ts"));
var Gptutils = __importStar(__webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/sectiondetail/prompt.ts");
var helper_1 = __webpack_require__(/*! ../log/helper */ "./src/modules/book/log/helper.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var createDetail = function (space, bookref, sectionref, payload, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var book, model, contextList, themesContextList, gptResponseText, content, sectiondetail, shorterSummary;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(payload.type === "summary")) return [3, 2];
                return [4, _createSummary(space, bookref, sectionref)];
            case 1: return [2, _a.sent()];
            case 2: return [4, BookHelper.getBookByReference(space, bookref)];
            case 3:
                book = _a.sent();
                model = getCollection(space, model_1.sectionDetailCollection, model_1.sectionDetailSchema);
                return [4, model.find({
                        bookref: bookref,
                        sectionref: sectionref,
                        type: "context",
                    })];
            case 4:
                contextList = _a.sent();
                return [4, model.find({
                        bookref: bookref,
                        sectionref: sectionref,
                        type: "themes_context",
                    })];
            case 5:
                themesContextList = _a.sent();
                if (contextList.length === 0) {
                    return [2, {}];
                }
                return [4, Gptutils.predict((0, prompt_1.getSecondarySectionPrompt)(payload.type, book.title, book.primaryAuthor, contextList[0].content, themesContextList.length > 0 ? themesContextList[0].content : undefined))];
            case 6:
                gptResponseText = _a.sent();
                content = _processAiResponse(payload.type, gptResponseText);
                return [4, model.updateOne({
                        bookref: bookref,
                        sectionref: sectionref,
                        type: payload.type,
                    }, {
                        $set: {
                            customTitle: payload.sectionTitle,
                            customDescription: payload.sectionDescription,
                            content: content,
                        },
                    }, { upsert: true })];
            case 7:
                sectiondetail = _a.sent();
                if (!(payload.type === "themes")) return [3, 10];
                return [4, _generateShorterThemesSummaryForContext(book.title, book.primaryAuthor, gptResponseText)];
            case 8:
                shorterSummary = _a.sent();
                return [4, model.updateOne({
                        bookref: bookref,
                        sectionref: sectionref,
                        type: "themes_context",
                    }, {
                        $set: {
                            content: shorterSummary,
                        },
                    }, { upsert: true })];
            case 9:
                _a.sent();
                _a.label = 10;
            case 10: return [2, sectiondetail];
        }
    });
}); };
exports.createDetail = createDetail;
var _createSummary = function (space, bookref, sectionref) { return __awaiter(void 0, void 0, void 0, function () {
    var book, notes, notesList, extracts, section, gptResponseText, content, model, sectiondetail, shorterSummary;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _a.sent();
                return [4, NoteHelper.getNoteByBookref(space, bookref)];
            case 2:
                notes = _a.sent();
                notesList = [];
                notes.forEach(function (item) { return notesList.push(item.content); });
                return [4, ExtractHelper.getExtractChunksByBookReference(space, bookref)];
            case 3:
                extracts = _a.sent();
                extracts.forEach(function (item) { return notesList.push(item.summary); });
                return [4, SectionHelper.getBookSectionByBookReference(space, bookref, sectionref)];
            case 4:
                section = _a.sent();
                if (!section) {
                    return [2, null];
                }
                return [4, Gptutils.predict((0, prompt_1.getSummarySectionPrompt)(book.title, book.primaryAuthor, section.title, section.description))];
            case 5:
                gptResponseText = _a.sent();
                content = _processAiResponse("summary", gptResponseText);
                model = getCollection(space, model_1.sectionDetailCollection, model_1.sectionDetailSchema);
                return [4, model.updateOne({
                        bookref: bookref,
                        sectionref: sectionref,
                        type: "summary",
                    }, {
                        $set: {
                            content: content,
                        },
                    }, { upsert: true })];
            case 6:
                sectiondetail = _a.sent();
                return [4, _generateShorterSummaryForContext(book.title, book.primaryAuthor, gptResponseText)];
            case 7:
                shorterSummary = _a.sent();
                return [4, model.updateOne({
                        bookref: bookref,
                        sectionref: sectionref,
                        type: "context",
                    }, {
                        $set: {
                            content: shorterSummary,
                        },
                    }, { upsert: true })];
            case 8:
                _a.sent();
                return [2, sectiondetail];
        }
    });
}); };
var _generateShorterSummaryForContext = function (bookName, authorName, content) { return __awaiter(void 0, void 0, void 0, function () {
    var gptResponseText;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Gptutils.predict((0, prompt_1.getShortenContentPrompt)(bookName, authorName, content))];
            case 1:
                gptResponseText = _a.sent();
                return [2, gptResponseText];
        }
    });
}); };
var _generateShorterThemesSummaryForContext = function (bookName, authorName, content) { return __awaiter(void 0, void 0, void 0, function () {
    var gptResponseText;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Gptutils.predict((0, prompt_1.getShortenThemesPrompt)(bookName, authorName, content))];
            case 1:
                gptResponseText = _a.sent();
                return [2, gptResponseText];
        }
    });
}); };
var _processAiResponse = function (type, text) {
    var htmlString = "";
    var data = text;
    console.log("****", data);
    switch (type) {
        case "summary":
        case "themes":
        case "alternate_takes":
        case "purpose":
            data = JSON.parse(text);
            break;
        default:
            break;
    }
    switch (type) {
        case "summary":
            data.forEach(function (section) {
                htmlString += "<b>".concat(section.title, "</b>");
                htmlString += section.content;
            });
            break;
        case "themes":
            data.forEach(function (section) {
                htmlString += "<b>".concat(section.themeTitle, "</b>");
                htmlString += section.content;
            });
            break;
        case "alternate_takes":
            data.forEach(function (section) {
                htmlString += "<b>".concat(section.author, "</b> in <i>").concat(section.book, "</i>");
                htmlString += section.content;
            });
            break;
        case "purpose":
            data.forEach(function (section) {
                htmlString += "(<i>".concat(section.section, "</i>) <b>").concat(section.purpose, "</b>");
                htmlString += section.analysis;
            });
            break;
        default:
            htmlString = data;
            break;
    }
    return htmlString;
};
var updateDetail = function (space, id, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.sectionDetailCollection, model_1.sectionDetailSchema);
                response = null;
                return [4, model.findByIdAndUpdate(id, data, {})];
            case 1:
                response = _a.sent();
                return [2, response];
        }
    });
}); };
exports.updateDetail = updateDetail;
var getDetailsByBookReference = function (space, bookref, sectionref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.sectionDetailCollection, model_1.sectionDetailSchema);
                return [4, model.find({
                        bookref: bookref,
                        sectionref: sectionref,
                        type: { $nin: ["context", "themes_context"] },
                    })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getDetailsByBookReference = getDetailsByBookReference;
var getDetailsByBookReferenceShortform = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.sectionDetailCollection, model_1.sectionDetailSchema);
                return [4, model.find({ bookref: bookref, type: "summary" })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getDetailsByBookReferenceShortform = getDetailsByBookReferenceShortform;
var deleteDetail = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.sectionDetailCollection, model_1.sectionDetailSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { sectiondetail: _id }];
        }
    });
}); };
exports.deleteDetail = deleteDetail;
var addSectionDetailPlaceholder = function (space, bookref, sectionref, sectiontype) { return __awaiter(void 0, void 0, void 0, function () {
    var model, sectiondetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.sectionDetailCollection, model_1.sectionDetailSchema);
                return [4, model.updateOne({
                        bookref: bookref,
                        sectionref: sectionref,
                        type: sectiontype,
                    }, {
                        $set: {
                            content: "",
                        },
                    }, { upsert: true })];
            case 1:
                sectiondetail = _a.sent();
                return [2];
        }
    });
}); };
exports.addSectionDetailPlaceholder = addSectionDetailPlaceholder;
var generateAllSectionSummaries = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var sections, i, i;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, SectionHelper.getBookSectionsByBookReference(space, bookref)];
            case 1:
                sections = _a.sent();
                i = 0;
                _a.label = 2;
            case 2:
                if (!(i < sections.length)) return [3, 6];
                return [4, (0, helper_1.startGenerating)(space, bookref, sections[i].reference, "summary")];
            case 3:
                _a.sent();
                return [4, (0, exports.addSectionDetailPlaceholder)(space, bookref, sections[i].reference, "summary")];
            case 4:
                _a.sent();
                _a.label = 5;
            case 5:
                i++;
                return [3, 2];
            case 6:
                i = 0;
                _a.label = 7;
            case 7:
                if (!(i < sections.length)) return [3, 11];
                return [4, _createSummary(space, bookref, sections[i].reference)];
            case 8:
                _a.sent();
                return [4, (0, helper_1.finishGenerating)(space, bookref, sections[i].reference, "summary")];
            case 9:
                _a.sent();
                _a.label = 10;
            case 10:
                i++;
                return [3, 7];
            case 11: return [2];
        }
    });
}); };
exports.generateAllSectionSummaries = generateAllSectionSummaries;


/***/ }),

/***/ "./src/modules/book/sectiondetail/model.ts":
/*!*************************************************!*\
  !*** ./src/modules/book/sectiondetail/model.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sectionDetailCollection = exports.sectionDetailSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var sectionDetailSchema = new Schema({
    customTitle: { type: String },
    customDescription: { type: String },
    type: { type: String },
    conceptref: { type: String },
    bookref: { type: String },
    content: { type: JSON },
}, { timestamps: true, strict: false, strictQuery: false });
exports.sectionDetailSchema = sectionDetailSchema;
var sectionDetailCollection = "book.sectiondetail";
exports.sectionDetailCollection = sectionDetailCollection;


/***/ }),

/***/ "./src/modules/book/sectiondetail/prompt.ts":
/*!**************************************************!*\
  !*** ./src/modules/book/sectiondetail/prompt.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getShortenThemesPrompt = exports.getShortenContentPrompt = exports.getSummarySectionPrompt = exports.getSecondarySectionPrompt = void 0;
var gptutils_1 = __webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME_GPT4_MINI = "gpt-4o-mini";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
var getSecondarySectionPrompt = function (type, bookName, authorName, content, themesContext) {
    switch (type) {
        case "context":
            return (0, gptutils_1.getPrompt)(_SHORTEN_CONTENT_PROMPT, {
                bookName: bookName,
                authorName: authorName,
                content: content,
            });
        case "themes":
            return (0, gptutils_1.getPrompt)(_THEMES_PROMPT, {
                bookName: bookName,
                authorName: authorName,
                content: content,
            });
        case "alternate_takes":
            return (0, gptutils_1.getPrompt)(_ALTERNATE_TAKES_PROMPT, {
                bookName: bookName,
                authorName: authorName,
                content: themesContext || content,
            });
        case "purpose":
            return (0, gptutils_1.getPrompt)(_PURPOSE_PROMPT, {
                bookName: bookName,
                authorName: authorName,
                content: themesContext || content,
            });
        default:
            break;
    }
};
exports.getSecondarySectionPrompt = getSecondarySectionPrompt;
var getSummarySectionPrompt = function (bookName, authorName, sectionName, sectionSummary) {
    return (0, gptutils_1.getPrompt)(_SUMMARY_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        sectionName: sectionName,
        sectionSummary: sectionSummary,
    });
};
exports.getSummarySectionPrompt = getSummarySectionPrompt;
var getShortenContentPrompt = function (bookName, authorName, content) {
    return (0, gptutils_1.getPrompt)(_SHORTEN_CONTENT_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        content: content,
    });
};
exports.getShortenContentPrompt = getShortenContentPrompt;
var getShortenThemesPrompt = function (bookName, authorName, content) {
    return (0, gptutils_1.getPrompt)(_SHORTEN_THEMES_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        content: content,
    });
};
exports.getShortenThemesPrompt = getShortenThemesPrompt;
var _SHORTEN_CONTENT_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI designed to provide a concise summary of a particular section or chapter from a specific book.",
                "Your summary should focus on the key events, explanations, or discussions presented in that section or chapter.",
                "Include references to the book name and author name to provide context for later prompts.",
                "Avoid unnecessary details and focus on the most important content relevant to the section being summarized.",
                "When in doubt, it is safer to retain content rather than remove it. Ensure that the key points from the section or chapter are preserved.",
            ],
        },
        {
            role: "user",
            content: [
                "Summarize the following section or chapter into a shorter, concise version suitable for further analysis or interpretation. Include references to the book name {{bookName}} and author {{authorName}} in the summary:",
                "{{content}}",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _SHORTEN_THEMES_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI designed to provide a concise summary of the detailed exploration of a theme from a specific book.",
                "Your summary should capture the essence of the central theme and its sub-themes, while being brief and clear.",
                "Include references to the book name and author name to provide context for later prompts.",
                "Avoid unnecessary details and focus on the key points.",
                "When in doubt, it is safer to retain content rather than remove it. Ensure that important aspects of the theme and sub-themes are preserved.",
            ],
        },
        {
            role: "user",
            content: [
                "Summarize the following content into a shorter, concise version suitable for further analysis or interpretation. Include references to the book name {{bookName}} and author {{authorName}} in the summary:",
                "{{content}}",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _SUMMARY_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI assistant and an expert book reader.",
                "Your task is to expand the provided section summary into a highly detailed explanation, ensuring that no details are omitted.",
                "Stick strictly to explaining the content of the book without providing any analysis or interpretation.",
                "Focus entirely on providing a more in-depth explanation of the section, ensuring that every event, plot development, and character action is covered comprehensively.",
                "Do not add any extra information outside of what is already in the book.",
                "Ensure that the expanded explanation closely follows the events as they unfold in the book and mirrors the original section, but in a much more detailed manner.",
                "Do not present the explanation in a commentary style or provide any opinions. The content should read as a detailed and factual recounting of the events, actions, and details without subjective language or meta-commentary.",
                "Use <p> for paragraphs, <i> for emphasis, <b> when necessary, and bullet points where appropriate. Do not use <b> (bold) in the content field, as the title is already provided in the title field.",
                'Do not include any explanations, only provide a RFC8259 compliant JSON response following this format without deviation. [{"title": "Subtitle for the first subsection", "content": "Set of paragraphs in HTML with <p> and <i> tags"}, {"title": "Subtitle for the next subsection", "content": "Set of paragraphs in HTML with <p> and <i> tags"}, {...}]',
                "Make sure to create logical subsections based on the content, and do not merge all the details into a single section.",
                "Avoid using any commentary tone or explanatory text that goes beyond the factual content of the book.",
                "Ensure that all JSON keys and strings are enclosed in double quotes to comply with RFC8259 JSON formatting.",
            ],
        },
        {
            role: "user",
            content: [
                "Expand the section summary for {{sectionName}} from the book {{bookName}} by {{authorName}}.",
                "Here is the summary: {{sectionSummary}}.",
                "Provide a detailed explanation of this section using <p> for paragraphs, <i> for emphasis, <b> when necessary, and bullet points where appropriate.",
                "Break the expanded content into logical subsections, using appropriate titles for each.",
                "Do not include any explanations, only provide a RFC8259 compliant JSON response, ensuring all keys and strings are enclosed in double quotes.",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _THEMES_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI assistant and an expert book reader.",
                "Your task is to analyze the key themes and ideas in the provided section summary from the book {{bookName}} by {{authorName}}.",
                "Ensure the output includes a list of themes or ideas extracted from the section, with each theme accompanied by an explanation.",
                "The explanation for each theme or idea must be highly detailed and written in paragraph form, describing the theme's significance and how it appears in the section.",
                "For each theme, use <p> for paragraphs, <i> for specific words or phrases that require emphasis, and <b> only when necessary within the explanation.",
                "Use <p> for paragraphs, <i> for emphasis, <b> when necessary, and bullet points where appropriate.",
                "Do not provide any extra commentary or subjective analysis beyond the book's content.",
                "The output must be a valid JSON structure with all strings, property names, and values properly enclosed in double quotes.",
                "Structure the output as follows: [{'themeTitle': 'Title of the theme or idea', 'content': 'Set of paragraphs in HTML with <p>, <i>, <b>, and bullet points as necessary.'}, {'themeTitle': 'Next theme or idea', 'content': 'Set of paragraphs in HTML with <p>, <i>, <b>, and bullet points.'}, {...}]",
                "Each theme should be logically titled based on the content and avoid redundant information.",
                "Ensure that the JSON structure is correctly formatted with no extra spaces or errors in the syntax.",
            ],
        },
        {
            role: "user",
            content: [
                "Analyze the key themes and ideas from the book {{bookName}} by {{authorName}} for the below section summary {{content}}.",
                "Ensure that the output is structured in a JSON format with a list of themes.",
                "For each theme, provide a title in the 'themeTitle' field and a detailed explanation in the 'content' field, formatted with <p>, <i>, <b>, and bullet points where appropriate.",
                "Ensure all property names and values are double-quoted, and the output is fully JSON compliant with correct formatting.",
                "Use <p> for paragraphs, <i> for emphasis, <b> when necessary, and bullet points where appropriate. Do not add unnecessary commentary or explanations.",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _ALTERNATE_TAKES_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI assistant with expertise in literary analysis.",
                "Your task is to provide alternate perspectives on the key themes and ideas presented in the book {{bookName}} by {{authorName}} based on the summary of key themes provided.",
                "The output should be a JSON array containing objects for each alternate perspective from different authors.",
                "Each object should include the following fields: 'author', 'book', and 'content'.",
                "The 'author' field should contain the name of the author providing the perspective.",
                "The 'book' field should contain the title of the book where the perspective is found.",
                "The 'content' field should contain a set of paragraphs in HTML format, describing the alternate perspectives on the themes. Use <p> for paragraphs, <i> for emphasis, <b> only when necessary, and bullet points if applicable.",
                "Ensure the content is detailed and provides a thorough examination of the themes from the perspective of each cited author.",
                "The JSON structure should be correctly formatted, with all strings, property names, and values enclosed in double quotes.",
                "Avoid including any unnecessary commentary or subjective opinions beyond what is provided in the alternate perspectives.",
                "The output should be a valid JSON structure with no extra spaces or syntax errors.",
            ],
        },
        {
            role: "user",
            content: [
                "Analyze the key themes and ideas from the book {{bookName}} by {{authorName}} based on the following summary of themes: {{content}}.",
                "Provide alternate perspectives on these themes by referencing other authors and their works.",
                "Structure the output in a JSON format with an array of objects. Each object should include:",
                "1. 'author': The name of the author offering the alternate perspective.",
                "2. 'book': The title of the book where the perspective is discussed.",
                "3. 'content': A set of detailed paragraphs in HTML format, discussing the alternate perspectives. Use <p> for paragraphs, <i> for emphasis, <b> when necessary, and bullet points where appropriate.",
                "Ensure that all HTML formatting is limited to <b>, <i>, and bullet points to maintain readability.",
                "Make sure the JSON output is correctly formatted with double-quoted strings, proper property names, and valid syntax.",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _PURPOSE_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI assistant with expertise in literary analysis.",
                "Your task is to provide a deeper analysis of the purpose of the themes and ideas presented in the book {{bookName}} by {{authorName}} based on the summary of key themes provided.",
                "Consider how the themes fit into the larger narrative of the book, including their role in revealing critical information and their contribution to the overall structure of the book.",
                "The output should be a JSON array containing objects that offer detailed analysis of how the themes function within the book's narrative.",
                "Each object should include the following fields: 'section', 'purpose', and 'analysis'.",
                "The 'section' field should specify the section or chapter being analyzed.",
                "The 'purpose' field should describe the thematic purpose and its relevance to the book's larger narrative.",
                "The 'analysis' field should contain a set of paragraphs in HTML format, offering a thorough examination of the themes' roles and their impact on the book's structure. Use <p> for paragraphs, <i> for emphasis, <b> only when necessary, and bullet points if applicable.",
                "Ensure the content is detailed and explores how the themes contribute to the narrative's development.",
                "The JSON structure should be correctly formatted, with all strings, property names, and values enclosed in double quotes.",
                "Avoid including any unnecessary commentary or subjective opinions beyond what is provided in the thematic analysis.",
                "The output should be a valid JSON structure with no extra spaces or syntax errors.",
            ],
        },
        {
            role: "user",
            content: [
                "Analyze the purpose of the key themes and ideas from the book {{bookName}} by {{authorName}} based on the following summary of themes: {{content}}.",
                "Consider how these themes fit into the larger narrative of the book. Evaluate whether they reveal critical information or contribute to the overall structure of the book.",
                "Structure the output in a JSON format with an array of objects. Each object should include:",
                "1. 'section': The specific section or chapter being analyzed.",
                "2. 'purpose': A description of the thematic purpose and its relevance to the book's larger narrative.",
                "3. 'analysis': A set of detailed paragraphs in HTML format, discussing the role of the themes and their impact on the narrative. Use <p> for paragraphs, <i> for emphasis, <b> when necessary, and bullet points where appropriate.",
                "Ensure that all HTML formatting is limited to <b>, <i>, and bullet points to maintain readability.",
                "Make sure the JSON output is correctly formatted with double-quoted strings, proper property names, and valid syntax.",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/sectiondetail/route.ts":
/*!*************************************************!*\
  !*** ./src/modules/book/sectiondetail/route.ts ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/sectiondetail/service.ts");
module.exports = function (router) {
    router.put("/book/section-detail/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateDetail));
    router.post("/book/section-detail/:space/:bookref/:sectionref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createDetail));
    router.get("/book/section-detail/:space/:bookref/:sectionref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getDetailsByBookReference));
    router.delete("/book/section-detail/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteDetail));
};


/***/ }),

/***/ "./src/modules/book/sectiondetail/service.ts":
/*!***************************************************!*\
  !*** ./src/modules/book/sectiondetail/service.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteDetail = exports.getDetailsByBookReference = exports.updateDetail = exports.createDetail = void 0;
var helper_1 = __webpack_require__(/*! ../log/helper */ "./src/modules/book/log/helper.ts");
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/sectiondetail/helper.ts"));
var createDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, (0, helper_1.startGenerating)(req.params.space, req.params.bookref, req.params.sectionref, req.body.type)];
            case 1:
                _a.sent();
                return [4, Helper.addSectionDetailPlaceholder(req.params.space, req.params.bookref, req.params.sectionref, req.body.type)];
            case 2:
                _a.sent();
                res.status(202).send({
                    message: "Section generation started. You will be notified upon completion.",
                });
                return [4, Helper.createDetail(req.params.space, req.params.bookref, req.params.sectionref, req.body, userId)];
            case 3:
                _a.sent();
                return [4, (0, helper_1.finishGenerating)(req.params.space, req.params.bookref, req.params.sectionref, req.body.type)];
            case 4:
                _a.sent();
                return [2];
        }
    });
}); };
exports.createDetail = createDetail;
var updateDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, sectiondetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateDetail(req.params.space, req.params.id, req.body, userId)];
            case 1:
                sectiondetail = _a.sent();
                res.status(200);
                res.send(sectiondetail);
                res.end();
                return [2];
        }
    });
}); };
exports.updateDetail = updateDetail;
var getDetailsByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, sectiondetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getDetailsByBookReference(req.params.space, req.params.bookref, req.params.sectionref)];
            case 1:
                sectiondetail = _a.sent();
                res.status(200);
                res.send(sectiondetail);
                res.end();
                return [2];
        }
    });
}); };
exports.getDetailsByBookReference = getDetailsByBookReference;
var deleteDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteDetail(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteDetail = deleteDetail;


/***/ }),

/***/ "./src/modules/book/service.ts":
/*!*************************************!*\
  !*** ./src/modules/book/service.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteBookByReference = exports.deleteBook = exports.searchBook = exports.getBookByReference = exports.getBookById = exports.getLibraries = exports.getBook = exports.getCoverImages = exports.updateBook = exports.createBook = exports.validateBook = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/helper.ts"));
var validateBook = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.validateBook(req.body, userId)];
            case 1:
                response = _a.sent();
                res.status(200);
                res.send(response);
                res.end();
                return [2];
        }
    });
}); };
exports.validateBook = validateBook;
var createBook = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, book;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createBook(req.params.space, req.body, userId)];
            case 1:
                book = _a.sent();
                res.status(200).send(book);
                return [2];
        }
    });
}); };
exports.createBook = createBook;
var updateBook = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, book;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateBook(req.params.space, req.params.id, req.body, userId)];
            case 1:
                book = _a.sent();
                res.status(200);
                res.send(book);
                res.end();
                return [2];
        }
    });
}); };
exports.updateBook = updateBook;
var getCoverImages = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log("**");
                userId = req.user.user_id;
                return [4, Helper.getCoverImages(req.params.space, req.params.reference, userId)];
            case 1:
                data = _a.sent();
                res.status(200).send(data);
                return [2];
        }
    });
}); };
exports.getCoverImages = getCoverImages;
var getBook = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBook(req.params.space)];
            case 1:
                bookList = _a.sent();
                res.status(200);
                res.send(bookList);
                res.end();
                return [2];
        }
    });
}); };
exports.getBook = getBook;
var getLibraries = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getLibraries(req.params.space)];
            case 1:
                bookList = _a.sent();
                res.status(200);
                res.send(bookList);
                res.end();
                return [2];
        }
    });
}); };
exports.getLibraries = getLibraries;
var getBookById = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, book;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookById(req.params.space, req.params.id)];
            case 1:
                book = _a.sent();
                res.status(200);
                res.send(book);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookById = getBookById;
var getBookByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, book;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookByReference(req.params.space, req.params.reference)];
            case 1:
                book = _a.sent();
                res.status(200);
                res.send(book);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookByReference = getBookByReference;
var searchBook = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, book;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.searchBook(req.params.space, req.body.text, req.body.textList, req.body.searchPref)];
            case 1:
                book = _a.sent();
                res.status(200);
                res.send(book);
                res.end();
                return [2];
        }
    });
}); };
exports.searchBook = searchBook;
var deleteBook = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBook(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBook = deleteBook;
var deleteBookByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookByReference(req.params.space, req.params.reference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookByReference = deleteBookByReference;


/***/ }),

/***/ "./src/modules/book/shortform/helper.ts":
/*!**********************************************!*\
  !*** ./src/modules/book/shortform/helper.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteShortform = exports.getShortformsByBookReference = exports.updateShortform = exports.createShortform = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/shortform/model.ts");
var BookHelper = __importStar(__webpack_require__(/*! ../helper */ "./src/modules/book/helper.ts"));
var ConceptHelper = __importStar(__webpack_require__(/*! ../concept/helper */ "./src/modules/book/concept/helper.ts"));
var NoteHelper = __importStar(__webpack_require__(/*! ../../note/helper */ "./src/modules/note/helper.ts"));
var Gptutils = __importStar(__webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/shortform/prompt.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var createShortform = function (space, bookref, payload, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var book, notes, notesList, concepts, keyInsightsList, gptResponseText, gptResponse, model, shortform;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _a.sent();
                return [4, NoteHelper.getNoteByBookref(space, bookref)];
            case 2:
                notes = _a.sent();
                notesList = [];
                notes.forEach(function (item) { return notesList.push(item.content); });
                return [4, ConceptHelper.getBookConceptsByBookReference(space, bookref)];
            case 3:
                concepts = _a.sent();
                keyInsightsList = [];
                concepts.forEach(function (item) {
                    keyInsightsList.push(item.name);
                });
                return [4, Gptutils.predict((0, prompt_1.getBookShortFormPrompt)(payload === null || payload === void 0 ? void 0 : payload.type, book.title, book.primaryAuthor, notesList, keyInsightsList))];
            case 4:
                gptResponseText = _a.sent();
                console.log(gptResponseText);
                gptResponse = JSON.parse(gptResponseText);
                model = getCollection(space, model_1.shortformCollection, model_1.shortformSchema);
                return [4, model.create({
                        type: payload.type,
                        customTitle: payload.sectionTitle,
                        customDescription: payload.sectionDescription,
                        bookref: bookref,
                        content: gptResponse,
                    })];
            case 5:
                shortform = _a.sent();
                return [2, shortform];
        }
    });
}); };
exports.createShortform = createShortform;
var updateShortform = function (space, reload, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, shortformResponse, shortform;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.shortformCollection, model_1.shortformSchema);
                response = null;
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, data, {
                        new: true,
                        upsert: true,
                    })];
            case 1:
                response = _a.sent();
                return [3, 4];
            case 2: return [4, model.create(__assign({}, data))];
            case 3:
                response = _a.sent();
                _a.label = 4;
            case 4: return [4, model.find({
                    reference: response.reference,
                })];
            case 5:
                shortformResponse = _a.sent();
                shortform = null;
                if (shortformResponse.length > 0) {
                    shortform = shortformResponse[0];
                }
                return [2, {
                        shortform: shortform,
                    }];
        }
    });
}); };
exports.updateShortform = updateShortform;
var getShortformsByBookReference = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.shortformCollection, model_1.shortformSchema);
                return [4, model.find({ bookref: bookref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getShortformsByBookReference = getShortformsByBookReference;
var deleteShortform = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.shortformCollection, model_1.shortformSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { shortform: _id }];
        }
    });
}); };
exports.deleteShortform = deleteShortform;


/***/ }),

/***/ "./src/modules/book/shortform/model.ts":
/*!*********************************************!*\
  !*** ./src/modules/book/shortform/model.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shortformCollection = exports.shortformSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var shortformSchema = new Schema({
    customTitle: { type: String },
    customDescription: { type: String },
    type: { type: String },
    bookref: { type: String },
    content: { type: JSON },
}, { timestamps: true, strict: false, strictQuery: false });
exports.shortformSchema = shortformSchema;
var shortformCollection = "book.shortform";
exports.shortformCollection = shortformCollection;


/***/ }),

/***/ "./src/modules/book/shortform/prompt.ts":
/*!**********************************************!*\
  !*** ./src/modules/book/shortform/prompt.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBookShortFormPrompt = void 0;
var Handlebars = __importStar(__webpack_require__(/*! handlebars */ "handlebars"));
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME_GPT4_MINI = "gpt-4o-mini";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
var getBookShortFormPrompt = function (type, bookName, authorName, notesList, keyInsightsList) {
    var keyInsights = keyInsightsList.join(", ");
    var notes = notesList.join(", ");
    var prompt = (0, lodash_1.cloneDeep)(_SHORTFORM_PROMPT);
    for (var i = 0; i < prompt.messages.length; i++) {
        prompt.messages[i].content = Handlebars.compile(prompt.messages[i].content)({
            bookName: bookName,
            authorName: authorName,
            notes: notes,
            keyInsights: keyInsights,
        });
    }
    console.log(prompt);
    return prompt;
};
exports.getBookShortFormPrompt = getBookShortFormPrompt;
var _SHORTFORM_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: 'You are an AI assistant tasked with creating a comprehensive analysis of a book in JSON format. The output should be detailed, covering a word count of 2500-3000 words. The structure of the JSON should be as follows: \n\n{\n  "bookOverview": {\n    "overview": "string",\n    "authorInfo": "string"\n  },\n  "keyInsights": [\n    {"title": "string", "description": "html"},\n    {"title": "string", "description": "html"},\n    ...\n  ]\n}.\n\nInstructions:\n\n1. For the "bookOverview":\n- Provide a detailed summary of the book\'s main premise and significance (4-5 sentences).\n- Mention the author\'s background and expertise relevant to the book\'s topic (2-3 sentences).\n\n2. For "keyInsights":\n- Each key insight should have a title and a detailed description.\n- The description must be in HTML format, with each paragraph enclosed within <p> tags. Only <p>, <b>, and <i> tags are allowed.\n- The description should include an in-depth explanation of the insight (4-5 paragraphs), practical examples or applications (2-3 paragraphs), and any relevant statistics or research mentioned in the book.\n\nGuidelines:\n- Ensure that the total word count of the output is between 2500 and 3000 words.\n- Ensure that text is paraphrased to avoid direct quotes from the book.\n- Focus on presenting content in a structured and detailed manner with thorough explanations and examples.',
        },
        {
            role: "assistant",
            content: "Ensure that each key insight is elaborated with multiple paragraphs and detailed explanations, with each paragraph enclosed in <p> tags. For each key insight in {{keyInsights}}, provide a comprehensive analysis that includes examples, applications, and supporting evidence to meet the 2500-3000 word range.",
        },
        {
            role: "user",
            content: "The book is '{{bookName}}' by {{authorName}}. The key insights are: {{keyInsights}}.",
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/shortform/route.ts":
/*!*********************************************!*\
  !*** ./src/modules/book/shortform/route.ts ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/shortform/service.ts");
module.exports = function (router) {
    router.put("/book/shortform/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateShortform));
    router.post("/book/shortform/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createShortform));
    router.get("/book/shortform/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getShortformsByBookReference));
    router.delete("/book/shortform/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteShortform));
};


/***/ }),

/***/ "./src/modules/book/shortform/service.ts":
/*!***********************************************!*\
  !*** ./src/modules/book/shortform/service.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteShortform = exports.getShortformsByBookReference = exports.updateShortform = exports.createShortform = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/shortform/helper.ts"));
var createShortform = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, shortform;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createShortform(req.params.space, req.params.bookref, req.body, userId)];
            case 1:
                shortform = _a.sent();
                res.status(200);
                res.send(shortform);
                res.end();
                return [2];
        }
    });
}); };
exports.createShortform = createShortform;
var updateShortform = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, shortform;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateShortform(req.params.space, req.query.reload, req.body, userId)];
            case 1:
                shortform = _a.sent();
                res.status(200);
                res.send(shortform);
                res.end();
                return [2];
        }
    });
}); };
exports.updateShortform = updateShortform;
var getShortformsByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, shortform;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getShortformsByBookReference(req.params.space, req.params.bookref)];
            case 1:
                shortform = _a.sent();
                res.status(200);
                res.send(shortform);
                res.end();
                return [2];
        }
    });
}); };
exports.getShortformsByBookReference = getShortformsByBookReference;
var deleteShortform = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteShortform(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteShortform = deleteShortform;


/***/ }),

/***/ "./src/modules/book/subtheme/helper.ts":
/*!*********************************************!*\
  !*** ./src/modules/book/subtheme/helper.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addSubthemes = exports.deleteBookSubthemeByReference = exports.deleteBookSubtheme = exports.getBookSubthemeById = exports.getBookSubthemeByBookReference = exports.getBookSubthemesByThemeReference = exports.getBookSubthemesByBookReference = exports.getBookSubtheme = exports.updateBookSubtheme = exports.createBookSubtheme = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/subtheme/model.ts");
var service_1 = __webpack_require__(/*! ../../sequence/service */ "./src/modules/sequence/service.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var SIMILARITY_ALGORITHM = "similarity";
var createBookSubtheme = function (space_1, _a, userId_1) { return __awaiter(void 0, [space_1, _a, userId_1], void 0, function (space, _b, userId) {
    var model, response;
    var bookSubtheme = _b.bookSubtheme, meta = _b.meta;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                response = null;
                return [4, model.create(__assign({}, bookSubtheme))];
            case 1:
                response = _c.sent();
                return [2, response];
        }
    });
}); };
exports.createBookSubtheme = createBookSubtheme;
var updateBookSubtheme = function (space, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, bookSubthemeResponse, bookSubtheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                response = null;
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, data, {
                        new: true,
                        upsert: true,
                    })];
            case 1:
                response = _a.sent();
                return [3, 4];
            case 2: return [4, model.create(__assign({}, data))];
            case 3:
                response = _a.sent();
                _a.label = 4;
            case 4: return [4, model.find({
                    reference: response.reference,
                })];
            case 5:
                bookSubthemeResponse = _a.sent();
                bookSubtheme = null;
                if (bookSubthemeResponse.length > 0) {
                    bookSubtheme = bookSubthemeResponse[0];
                }
                return [2, {
                        bookSubtheme: bookSubtheme,
                    }];
        }
    });
}); };
exports.updateBookSubtheme = updateBookSubtheme;
var _ai_populate_for_subtheme = function (space, bookref, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log(bookref, reference);
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios.get("".concat(AI_API, "/").concat(SIMILARITY_ALGORITHM, "/").concat(space, "/populate-subtheme/").concat(bookref, "/").concat(reference), {})];
            case 2:
                _a.sent();
                console.log("populated keywords for " + bookref + ", " + reference);
                return [3, 4];
            case 3:
                err_1 = _a.sent();
                console.log(err_1);
                return [3, 4];
            case 4: return [2];
        }
    });
}); };
var getBookSubtheme = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                return [4, model.find()];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.getBookSubtheme = getBookSubtheme;
var getBookSubthemesByBookReference = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                return [4, model.find({ bookref: bookref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getBookSubthemesByBookReference = getBookSubthemesByBookReference;
var getBookSubthemesByThemeReference = function (space, bookref, conceptref, themeref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                console.log(bookref, conceptref, themeref);
                return [4, model.find({ bookref: bookref, conceptref: conceptref, themeref: themeref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getBookSubthemesByThemeReference = getBookSubthemesByThemeReference;
var getBookSubthemeByBookReference = function (space, bookref, conceptref, subthemeref) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                return [4, model.find({
                        bookref: bookref,
                        conceptref: conceptref,
                        reference: subthemeref,
                    })];
            case 1:
                response = _a.sent();
                if (response.length > 0) {
                    return [2, response[0]];
                }
                return [2, null];
        }
    });
}); };
exports.getBookSubthemeByBookReference = getBookSubthemeByBookReference;
var getBookSubthemeById = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                return [4, model.find({ _id: _id })];
            case 1:
                res = _a.sent();
                if (res.length > 0) {
                    return [2, res[0]];
                }
                return [2];
        }
    });
}); };
exports.getBookSubthemeById = getBookSubthemeById;
var deleteBookSubtheme = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { bookSubtheme: _id }];
        }
    });
}); };
exports.deleteBookSubtheme = deleteBookSubtheme;
var deleteBookSubthemeByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                return [4, model.deleteMany({ reference: reference })];
            case 1:
                _a.sent();
                return [2, { bookSubtheme: reference }];
        }
    });
}); };
exports.deleteBookSubthemeByReference = deleteBookSubthemeByReference;
var addSubthemes = function (space, bookref, conceptref, subthemes) { return __awaiter(void 0, void 0, void 0, function () {
    var model, _payload, i, _a, _b, _c;
    var _d, _e, _f;
    return __generator(this, function (_g) {
        switch (_g.label) {
            case 0:
                model = getCollection(space, model_1.bookSubthemeCollection, model_1.bookSubthemeSchema);
                _payload = [];
                i = 0;
                _g.label = 1;
            case 1:
                if (!(i < subthemes.length)) return [3, 4];
                _b = (_a = _payload).push;
                _d = {};
                _e = {
                    filter: {
                        bookref: bookref,
                        conceptref: conceptref,
                        title: subthemes[i].title,
                    }
                };
                _c = [__assign({}, subthemes[i])];
                _f = {};
                return [4, (0, service_1.nextval)("subthemeId", conceptref, space)];
            case 2:
                _b.apply(_a, [(_d.updateOne = (_e.update = __assign.apply(void 0, _c.concat([(_f.reference = _g.sent(), _f)])),
                        _e.upsert = true,
                        _e),
                        _d)]);
                _g.label = 3;
            case 3:
                i++;
                return [3, 1];
            case 4: return [4, model.bulkWrite(_payload)];
            case 5: return [2, _g.sent()];
        }
    });
}); };
exports.addSubthemes = addSubthemes;


/***/ }),

/***/ "./src/modules/book/subtheme/model.ts":
/*!********************************************!*\
  !*** ./src/modules/book/subtheme/model.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bookSubthemeCollection = exports.bookSubthemeSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var bookSubthemeSchema = new Schema({
    name: { type: String },
    description: { type: String },
    reference: { type: String },
    bookref: { type: String },
    conceptref: { type: String },
    themeref: { type: String },
}, { timestamps: true, strict: false, strictQuery: false });
exports.bookSubthemeSchema = bookSubthemeSchema;
var bookSubthemeCollection = "book.subtheme";
exports.bookSubthemeCollection = bookSubthemeCollection;


/***/ }),

/***/ "./src/modules/book/subtheme/route.ts":
/*!********************************************!*\
  !*** ./src/modules/book/subtheme/route.ts ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/subtheme/service.ts");
module.exports = function (router) {
    router.put("/book/subtheme/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateBookSubtheme));
    router.post("/book/subtheme/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createBookSubtheme));
    router.get("/book/subtheme/:space/id/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookSubthemeById));
    router.get("/book/subtheme/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookSubthemesByBookReference));
    router.get("/book/subtheme/:space/:bookref/:conceptref/:subthemeref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookSubthemeByBookReference));
    router.delete("/book/subtheme/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookSubtheme));
    router.delete("/book/subtheme/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookSubthemeByReference));
};


/***/ }),

/***/ "./src/modules/book/subtheme/service.ts":
/*!**********************************************!*\
  !*** ./src/modules/book/subtheme/service.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteBookSubthemeByReference = exports.deleteBookSubtheme = exports.getBookSubthemeByBookReference = exports.getBookSubthemesByBookReference = exports.getBookSubthemeById = exports.getBookSubtheme = exports.updateBookSubtheme = exports.createBookSubtheme = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/subtheme/helper.ts"));
var createBookSubtheme = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSubtheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createBookSubtheme(req.params.space, req.body, userId)];
            case 1:
                bookSubtheme = _a.sent();
                res.status(200);
                res.send(bookSubtheme);
                res.end();
                return [2];
        }
    });
}); };
exports.createBookSubtheme = createBookSubtheme;
var updateBookSubtheme = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSubtheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateBookSubtheme(req.params.space, req.body, userId)];
            case 1:
                bookSubtheme = _a.sent();
                res.status(200);
                res.send(bookSubtheme);
                res.end();
                return [2];
        }
    });
}); };
exports.updateBookSubtheme = updateBookSubtheme;
var getBookSubtheme = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSubthemeList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookSubtheme(req.params.space)];
            case 1:
                bookSubthemeList = _a.sent();
                res.status(200);
                res.send(bookSubthemeList);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookSubtheme = getBookSubtheme;
var getBookSubthemeById = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSubtheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookSubthemeById(req.params.space, req.params.id)];
            case 1:
                bookSubtheme = _a.sent();
                res.status(200);
                res.send(bookSubtheme);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookSubthemeById = getBookSubthemeById;
var getBookSubthemesByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSubtheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookSubthemesByBookReference(req.params.space, req.params.bookref)];
            case 1:
                bookSubtheme = _a.sent();
                res.status(200);
                res.send(bookSubtheme);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookSubthemesByBookReference = getBookSubthemesByBookReference;
var getBookSubthemeByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookSubtheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookSubthemeByBookReference(req.params.space, req.params.bookref, req.params.conceptref, req.params.subthemeref)];
            case 1:
                bookSubtheme = _a.sent();
                res.status(200);
                res.send(bookSubtheme);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookSubthemeByBookReference = getBookSubthemeByBookReference;
var deleteBookSubtheme = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookSubtheme(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookSubtheme = deleteBookSubtheme;
var deleteBookSubthemeByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookSubthemeByReference(req.params.space, req.params.reference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookSubthemeByReference = deleteBookSubthemeByReference;


/***/ }),

/***/ "./src/modules/book/theme/helper.ts":
/*!******************************************!*\
  !*** ./src/modules/book/theme/helper.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addThemes = exports.deleteBookThemeByReference = exports.deleteBookTheme = exports.getBookThemeById = exports.getBookThemeByBookReference = exports.getBookThemesByConceptReference = exports.getBookThemesByBookReference = exports.getBookTheme = exports.updateBookTheme = exports.createBookTheme = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/theme/model.ts");
var service_1 = __webpack_require__(/*! ../../sequence/service */ "./src/modules/sequence/service.ts");
var model_2 = __webpack_require__(/*! ../subtheme/model */ "./src/modules/book/subtheme/model.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var SIMILARITY_ALGORITHM = "similarity";
var createBookTheme = function (space_1, _a, userId_1) { return __awaiter(void 0, [space_1, _a, userId_1], void 0, function (space, _b, userId) {
    var model, response;
    var bookTheme = _b.bookTheme, meta = _b.meta;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                response = null;
                return [4, model.create(__assign({}, bookTheme))];
            case 1:
                response = _c.sent();
                return [2, response];
        }
    });
}); };
exports.createBookTheme = createBookTheme;
var updateBookTheme = function (space, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, bookThemeResponse, bookTheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                response = null;
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, data, {
                        new: true,
                        upsert: true,
                    })];
            case 1:
                response = _a.sent();
                return [3, 4];
            case 2: return [4, model.create(__assign({}, data))];
            case 3:
                response = _a.sent();
                _a.label = 4;
            case 4: return [4, model.find({
                    reference: response.reference,
                })];
            case 5:
                bookThemeResponse = _a.sent();
                bookTheme = null;
                if (bookThemeResponse.length > 0) {
                    bookTheme = bookThemeResponse[0];
                }
                return [2, {
                        bookTheme: bookTheme,
                    }];
        }
    });
}); };
exports.updateBookTheme = updateBookTheme;
var _ai_populate_for_theme = function (space, bookref, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log(bookref, reference);
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios.get("".concat(AI_API, "/").concat(SIMILARITY_ALGORITHM, "/").concat(space, "/populate-theme/").concat(bookref, "/").concat(reference), {})];
            case 2:
                _a.sent();
                console.log("populated keywords for " + bookref + ", " + reference);
                return [3, 4];
            case 3:
                err_1 = _a.sent();
                console.log(err_1);
                return [3, 4];
            case 4: return [2];
        }
    });
}); };
var getBookTheme = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                return [4, model.find()];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.getBookTheme = getBookTheme;
var getBookThemesByBookReference = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                return [4, model.find({ bookref: bookref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getBookThemesByBookReference = getBookThemesByBookReference;
var getBookThemesByConceptReference = function (space, bookref, conceptref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                return [4, model.find({ bookref: bookref, conceptref: conceptref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getBookThemesByConceptReference = getBookThemesByConceptReference;
var getBookThemeByBookReference = function (space, bookref, conceptref, themeref) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                return [4, model.find({
                        bookref: bookref,
                        conceptref: conceptref,
                        reference: themeref,
                    })];
            case 1:
                response = _a.sent();
                if (response.length > 0) {
                    return [2, response[0]];
                }
                return [2, null];
        }
    });
}); };
exports.getBookThemeByBookReference = getBookThemeByBookReference;
var getBookThemeById = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                return [4, model.find({ _id: _id })];
            case 1:
                res = _a.sent();
                if (res.length > 0) {
                    return [2, res[0]];
                }
                return [2];
        }
    });
}); };
exports.getBookThemeById = getBookThemeById;
var deleteBookTheme = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { bookTheme: _id }];
        }
    });
}); };
exports.deleteBookTheme = deleteBookTheme;
var deleteBookThemeByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                return [4, model.deleteMany({ reference: reference })];
            case 1:
                _a.sent();
                return [2, { bookTheme: reference }];
        }
    });
}); };
exports.deleteBookThemeByReference = deleteBookThemeByReference;
var addThemes = function (space, bookref, conceptref, themes) { return __awaiter(void 0, void 0, void 0, function () {
    var model, subThemeModel, _payload, _payloadSubThemes, i, reference, j, _a, _b, _c;
    var _d, _e, _f;
    var _g;
    return __generator(this, function (_h) {
        switch (_h.label) {
            case 0:
                model = getCollection(space, model_1.bookThemeCollection, model_1.bookThemeSchema);
                subThemeModel = getCollection(space, model_2.bookSubthemeCollection, model_2.bookSubthemeSchema);
                _payload = [];
                _payloadSubThemes = [];
                i = 0;
                _h.label = 1;
            case 1:
                if (!(i < themes.length)) return [3, 7];
                return [4, (0, service_1.nextval)("themeId", conceptref, space)];
            case 2:
                reference = _h.sent();
                _payload.push({
                    updateOne: {
                        filter: {
                            bookref: bookref,
                            conceptref: conceptref,
                            title: themes[i].title,
                        },
                        update: __assign(__assign({}, themes[i]), { reference: reference }),
                        upsert: true,
                    },
                });
                j = 0;
                _h.label = 3;
            case 3:
                if (!(j < ((_g = themes[i].subThemes) === null || _g === void 0 ? void 0 : _g.length))) return [3, 6];
                _b = (_a = _payloadSubThemes).push;
                _d = {};
                _e = {
                    filter: {
                        bookref: bookref,
                        conceptref: conceptref,
                        themeref: reference,
                        title: themes[i].title,
                    }
                };
                _c = [__assign({}, themes[i].subThemes[j])];
                _f = {};
                return [4, (0, service_1.nextval)("subThemeId", "".concat(bookref, "_").concat(conceptref, "_").concat(reference), space)];
            case 4:
                _b.apply(_a, [(_d.updateOne = (_e.update = __assign.apply(void 0, _c.concat([(_f.reference = _h.sent(), _f)])),
                        _e.upsert = true,
                        _e),
                        _d)]);
                _h.label = 5;
            case 5:
                j++;
                return [3, 3];
            case 6:
                i++;
                return [3, 1];
            case 7: return [4, subThemeModel.bulkWrite(_payloadSubThemes)];
            case 8:
                _h.sent();
                return [4, model.bulkWrite(_payload)];
            case 9: return [2, _h.sent()];
        }
    });
}); };
exports.addThemes = addThemes;


/***/ }),

/***/ "./src/modules/book/theme/model.ts":
/*!*****************************************!*\
  !*** ./src/modules/book/theme/model.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bookThemeCollection = exports.bookThemeSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var bookThemeSchema = new Schema({
    name: { type: String },
    description: { type: String },
    reference: { type: String },
    bookref: { type: String },
    conceptref: { type: String },
    subThemes: { type: Array },
}, { timestamps: true, strict: false, strictQuery: false });
exports.bookThemeSchema = bookThemeSchema;
var bookThemeCollection = "book.theme";
exports.bookThemeCollection = bookThemeCollection;


/***/ }),

/***/ "./src/modules/book/theme/route.ts":
/*!*****************************************!*\
  !*** ./src/modules/book/theme/route.ts ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/theme/service.ts");
module.exports = function (router) {
    router.put("/book/theme/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateBookTheme));
    router.post("/book/theme/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createBookTheme));
    router.get("/book/theme/:space/id/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookThemeById));
    router.get("/book/theme/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookThemesByBookReference));
    router.get("/book/theme/:space/:bookref/:conceptref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookThemesByConceptReference));
    router.get("/book/theme/:space/:bookref/:conceptref/:themeref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getBookThemeByBookReference));
    router.delete("/book/theme/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookTheme));
    router.delete("/book/theme/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteBookThemeByReference));
};


/***/ }),

/***/ "./src/modules/book/theme/service.ts":
/*!*******************************************!*\
  !*** ./src/modules/book/theme/service.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteBookThemeByReference = exports.deleteBookTheme = exports.getBookThemeByBookReference = exports.getBookThemesByConceptReference = exports.getBookThemesByBookReference = exports.getBookThemeById = exports.getBookTheme = exports.updateBookTheme = exports.createBookTheme = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/theme/helper.ts"));
var createBookTheme = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookTheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createBookTheme(req.params.space, req.body, userId)];
            case 1:
                bookTheme = _a.sent();
                res.status(200);
                res.send(bookTheme);
                res.end();
                return [2];
        }
    });
}); };
exports.createBookTheme = createBookTheme;
var updateBookTheme = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookTheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateBookTheme(req.params.space, req.body, userId)];
            case 1:
                bookTheme = _a.sent();
                res.status(200);
                res.send(bookTheme);
                res.end();
                return [2];
        }
    });
}); };
exports.updateBookTheme = updateBookTheme;
var getBookTheme = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookThemeList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookTheme(req.params.space)];
            case 1:
                bookThemeList = _a.sent();
                res.status(200);
                res.send(bookThemeList);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookTheme = getBookTheme;
var getBookThemeById = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookTheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookThemeById(req.params.space, req.params.id)];
            case 1:
                bookTheme = _a.sent();
                res.status(200);
                res.send(bookTheme);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookThemeById = getBookThemeById;
var getBookThemesByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookTheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookThemesByBookReference(req.params.space, req.params.bookref)];
            case 1:
                bookTheme = _a.sent();
                res.status(200);
                res.send(bookTheme);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookThemesByBookReference = getBookThemesByBookReference;
var getBookThemesByConceptReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookTheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookThemesByConceptReference(req.params.space, req.params.bookref, req.params.conceptref)];
            case 1:
                bookTheme = _a.sent();
                res.status(200);
                res.send(bookTheme);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookThemesByConceptReference = getBookThemesByConceptReference;
var getBookThemeByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, bookTheme;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getBookThemeByBookReference(req.params.space, req.params.bookref, req.params.conceptref, req.params.themeref)];
            case 1:
                bookTheme = _a.sent();
                res.status(200);
                res.send(bookTheme);
                res.end();
                return [2];
        }
    });
}); };
exports.getBookThemeByBookReference = getBookThemeByBookReference;
var deleteBookTheme = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookTheme(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookTheme = deleteBookTheme;
var deleteBookThemeByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteBookThemeByReference(req.params.space, req.params.reference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteBookThemeByReference = deleteBookThemeByReference;


/***/ }),

/***/ "./src/modules/book/themedetail/helper.ts":
/*!************************************************!*\
  !*** ./src/modules/book/themedetail/helper.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteThemeDetail = exports.getThemeDetailsByBookReferenceShortform = exports.getThemeDetailsByBookReference = exports.updateThemeDetail = exports.createThemeDetail = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/book/themedetail/model.ts");
var BookHelper = __importStar(__webpack_require__(/*! ../helper */ "./src/modules/book/helper.ts"));
var ThemeHelper = __importStar(__webpack_require__(/*! ../theme/helper */ "./src/modules/book/theme/helper.ts"));
var SubThemeHelper = __importStar(__webpack_require__(/*! ../subtheme/helper */ "./src/modules/book/subtheme/helper.ts"));
var ExtractHelper = __importStar(__webpack_require__(/*! ../extract/helper */ "./src/modules/book/extract/helper.ts"));
var NoteHelper = __importStar(__webpack_require__(/*! ../../note/helper */ "./src/modules/note/helper.ts"));
var Gptutils = __importStar(__webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/book/themedetail/prompt.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var createThemeDetail = function (space, bookref, conceptref, themeref, payload, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var book, model, contextList, gptResponseText, content, themeDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!(payload.type === "summary")) return [3, 2];
                return [4, _createSummary(space, bookref, conceptref, themeref)];
            case 1: return [2, _a.sent()];
            case 2: return [4, BookHelper.getBookByReference(space, bookref)];
            case 3:
                book = _a.sent();
                model = getCollection(space, model_1.themeDetailCollection, model_1.themeDetailSchema);
                return [4, model.find({
                        bookref: bookref,
                        conceptref: conceptref,
                        themeref: themeref,
                        type: "context",
                    })];
            case 4:
                contextList = _a.sent();
                if (contextList.length === 0) {
                    return [2, {}];
                }
                return [4, Gptutils.predict((0, prompt_1.getSecondarySectionPrompt)(payload.type, book.title, book.primaryAuthor, contextList[0].content))];
            case 5:
                gptResponseText = _a.sent();
                content = _processAiResponse(payload.type, gptResponseText);
                return [4, model.updateOne({
                        bookref: bookref,
                        conceptref: conceptref,
                        themeref: themeref,
                        type: payload.type,
                    }, {
                        $set: {
                            customTitle: payload.sectionTitle,
                            customDescription: payload.sectionDescription,
                            content: content,
                        },
                    }, { upsert: true })];
            case 6:
                themeDetail = _a.sent();
                return [2, themeDetail];
        }
    });
}); };
exports.createThemeDetail = createThemeDetail;
var _createSummary = function (space, bookref, conceptref, themeref) { return __awaiter(void 0, void 0, void 0, function () {
    var book, theme, notes, notesList, extracts, subThemesList, subThemes, gptResponseText, content, model, themeDetail, shorterSummary;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _a.sent();
                return [4, ThemeHelper.getBookThemeByBookReference(space, bookref, conceptref, themeref)];
            case 2:
                theme = _a.sent();
                return [4, NoteHelper.getNoteByBookref(space, bookref)];
            case 3:
                notes = _a.sent();
                notesList = [];
                _filterAndSortDomainByKeywordOverlap(theme.keywords, notes).forEach(function (item) { return notesList.push(item.content); });
                return [4, ExtractHelper.getExtractChunksByBookReference(space, bookref)];
            case 4:
                extracts = _a.sent();
                _filterAndSortDomainByKeywordOverlap(theme.keywords, extracts).forEach(function (item) { return notesList.push(item.summary); });
                return [4, SubThemeHelper.getBookSubthemesByThemeReference(space, bookref, conceptref, themeref)];
            case 5:
                subThemesList = _a.sent();
                subThemes = _formatThemesForPrompt(subThemesList);
                return [4, Gptutils.predict((0, prompt_1.getSummarySectionPrompt)(book.title, book.primaryAuthor, theme.title, theme.description, subThemes, notesList))];
            case 6:
                gptResponseText = _a.sent();
                content = _processAiResponse("summary", gptResponseText);
                model = getCollection(space, model_1.themeDetailCollection, model_1.themeDetailSchema);
                return [4, model.updateOne({
                        bookref: bookref,
                        conceptref: conceptref,
                        themeref: themeref,
                        type: "summary",
                    }, {
                        $set: {
                            content: content,
                        },
                    }, { upsert: true })];
            case 7:
                themeDetail = _a.sent();
                return [4, _generateShorterSummaryForContext(book.title, book.primaryAuthor, content)];
            case 8:
                shorterSummary = _a.sent();
                return [4, model.updateOne({
                        bookref: bookref,
                        conceptref: conceptref,
                        themeref: themeref,
                        type: "context",
                    }, {
                        $set: {
                            content: shorterSummary,
                        },
                    }, { upsert: true })];
            case 9:
                _a.sent();
                return [2, themeDetail];
        }
    });
}); };
var _generateShorterSummaryForContext = function (bookName, authorName, content) { return __awaiter(void 0, void 0, void 0, function () {
    var gptResponseText;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Gptutils.predict((0, prompt_1.getSecondarySectionPrompt)("context", bookName, authorName, content))];
            case 1:
                gptResponseText = _a.sent();
                return [2, gptResponseText];
        }
    });
}); };
var _processAiResponse = function (type, text) {
    var _a;
    console.log(text);
    var htmlString = "";
    var data = text;
    switch (type) {
        case "summary":
        case "alternate_takes":
            data = JSON.parse(text);
            break;
        default:
            break;
    }
    switch (type) {
        case "summary":
            htmlString = data.themeExploration;
            (_a = data.subThemes) === null || _a === void 0 ? void 0 : _a.forEach(function (subTheme) {
                htmlString += "<h4>".concat(subTheme.title, "</h4>").concat(subTheme.exploration);
            });
            break;
        case "alternate_takes":
            data.forEach(function (item) {
                htmlString += "<p><b>".concat(item.reference.author, "</b> in <i>").concat(item.reference.book, "</i></p>").concat(item.content);
            });
            break;
        default:
            htmlString = data;
            break;
    }
    return htmlString;
};
function _formatThemesForPrompt(themes) {
    return themes
        .map(function (theme) { return "<strong>".concat(theme.title, ":</strong> ").concat(theme.description); })
        .join(",");
}
var _filterAndSortDomainByKeywordOverlap = function (inputKeywords, data) {
    return data
        .filter(function (item) { var _a; return (_a = item.keywords) === null || _a === void 0 ? void 0 : _a.some(function (keyword) { return inputKeywords === null || inputKeywords === void 0 ? void 0 : inputKeywords.includes(keyword); }); })
        .sort(function (a, b) {
        var _a, _b;
        var overlapA = (_a = a.keywords) === null || _a === void 0 ? void 0 : _a.filter(function (keyword) {
            return inputKeywords.includes(keyword);
        }).length;
        var overlapB = (_b = b.keywords) === null || _b === void 0 ? void 0 : _b.filter(function (keyword) {
            return inputKeywords.includes(keyword);
        }).length;
        return overlapB - overlapA;
    });
};
var updateThemeDetail = function (space, id, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.themeDetailCollection, model_1.themeDetailSchema);
                response = null;
                return [4, model.findByIdAndUpdate(id, data, {})];
            case 1:
                response = _a.sent();
                return [2, response];
        }
    });
}); };
exports.updateThemeDetail = updateThemeDetail;
var getThemeDetailsByBookReference = function (space, bookref, conceptref, themeref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.themeDetailCollection, model_1.themeDetailSchema);
                return [4, model.find({ bookref: bookref, conceptref: conceptref, themeref: themeref })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getThemeDetailsByBookReference = getThemeDetailsByBookReference;
var getThemeDetailsByBookReferenceShortform = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.themeDetailCollection, model_1.themeDetailSchema);
                return [4, model.find({ bookref: bookref, type: "_shortform" })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getThemeDetailsByBookReferenceShortform = getThemeDetailsByBookReferenceShortform;
var deleteThemeDetail = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.themeDetailCollection, model_1.themeDetailSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { themeDetail: _id }];
        }
    });
}); };
exports.deleteThemeDetail = deleteThemeDetail;


/***/ }),

/***/ "./src/modules/book/themedetail/model.ts":
/*!***********************************************!*\
  !*** ./src/modules/book/themedetail/model.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.themeDetailCollection = exports.themeDetailSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var themeDetailSchema = new Schema({
    customTitle: { type: String },
    customDescription: { type: String },
    type: { type: String },
    themeref: { type: String },
    bookref: { type: String },
    content: { type: String },
    contentObject: { type: JSON },
}, { timestamps: true, strict: false, strictQuery: false });
exports.themeDetailSchema = themeDetailSchema;
var themeDetailCollection = "book.themedetail";
exports.themeDetailCollection = themeDetailCollection;


/***/ }),

/***/ "./src/modules/book/themedetail/prompt.ts":
/*!************************************************!*\
  !*** ./src/modules/book/themedetail/prompt.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSummarySectionPrompt = exports.getSecondarySectionPrompt = void 0;
var gptutils_1 = __webpack_require__(/*! ../../../lib/gptutils */ "./src/lib/gptutils.ts");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME_GPT4_MINI = "gpt-4o-mini";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
var getSecondarySectionPrompt = function (type, bookName, authorName, content) {
    switch (type) {
        case "alternate_takes":
            return (0, gptutils_1.getPrompt)(_ALTERNATE_TAKES_PROMPT, {
                bookName: bookName,
                authorName: authorName,
                content: content,
            });
        case "context":
            return (0, gptutils_1.getPrompt)(_SHORTEN_CONTENT_PROMPT, {
                bookName: bookName,
                authorName: authorName,
                content: content,
            });
        default:
            break;
    }
};
exports.getSecondarySectionPrompt = getSecondarySectionPrompt;
var getSummarySectionPrompt = function (bookName, authorName, themeTitle, themeDescription, subThemes, noteList) {
    var notes = noteList.join("/n");
    return (0, gptutils_1.getPrompt)(_SUMMARY_PROMPT, {
        bookName: bookName,
        authorName: authorName,
        themeTitle: themeTitle,
        themeDescription: themeDescription,
        notes: notes,
        subThemes: subThemes,
    });
};
exports.getSummarySectionPrompt = getSummarySectionPrompt;
var _SUMMARY_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI designed to provide a detailed, logically structured, and informative exploration of a theme from a book.",
                "Ensure that your explanation directly describes the theme without framing it as third-person commentary or narrative.",
                "Format the output as a JSON object with two fields: 'themeExploration' and 'subThemes'.",
                "'themeExploration' is a detailed study of the theme, and 'subThemes' is an array of objects with 'title' and 'exploration'.",
                "When exploring sub-themes, avoid quoting or paraphrasing their titles or descriptions again within the 'exploration'. Ensure that there are no self-references or phrases that explicitly point to the sub-theme or its title.",
                "Analyze how the sub-themes support, challenge, or interact with the main theme.",
                "If no sub-themes are provided by the user, return an empty array for 'subThemes'.",
                "Do not create or infer sub-themes unless they are explicitly provided in the input.",
                "Content should be in HTML format with paragraphs, bold, and italic tags.",
            ],
        },
        {
            role: "user",
            content: [
                "Explore the theme of {{themeTitle}} from the book {{bookName}} by {{authorName}}, formatted in JSON with HTML paragraphs, bold, and italic elements.",
                "{{themeDescription}}",
            ],
        },
        {
            role: "user",
            content: [
                "Use the following notes for contextual understanding only, and only where relevant to the book {{bookName}}, the author {{authorName}}, and theme {{themeTitle}}.",
                "Do not directly use these notes as a source for building your exploration:",
                "{{notes}}",
            ],
        },
        {
            role: "user",
            content: [
                "Here are the relevant sub-themes for context:",
                "{{subThemes}}",
            ],
        },
        {
            role: "assistant",
            content: '{"themeExploration":"<p>{{themeDescription}}</p><p>{ThemeDetailedExploration1}</p><p>{ThemeDetailedExploration2}</p>","subThemes":[{"title":"{SubThemeTitle1}","exploration":"<p>{DetailedSubThemeDescription1Paragraph1}</p><p>{DetailedSubThemeDescription1Paragraph2}</p><p>{DetailedSubThemeDescription1Paragraph3}</p>"},{"title":"{SubThemeTitle2}","exploration":"<p>{DetailedSubThemeDescription2Paragraph1}</p><p>{DetailedSubThemeDescription2Paragraph2}</p><p>{DetailedSubThemeDescription2Paragraph3}</p>"},{"title":"{SubThemeTitle3}","exploration":"<p>{DetailedSubThemeDescription3Paragraph1}</p><p>{DetailedSubThemeDescription3Paragraph2}</p><p>{DetailedSubThemeDescription3Paragraph3}</p>"},{"title":"{SubThemeTitle4}","exploration":"<p>{DetailedSubThemeDescription4Paragraph1}</p><p>{DetailedSubThemeDescription4Paragraph2}</p><p>{DetailedSubThemeDescription4Paragraph3}</p>"}]}',
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _SHORTEN_CONTENT_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI designed to provide a concise summary of the detailed exploration of a theme from a specific book.",
                "Your summary should capture the essence of the central theme and its sub-themes, while being brief and clear.",
                "Include references to the book name and author name to provide context for later prompts.",
                "Avoid unnecessary details and focus on the key points.",
                "When in doubt, it is safer to retain content rather than remove it. Ensure that important aspects of the theme and sub-themes are preserved.",
            ],
        },
        {
            role: "user",
            content: [
                "Summarize the following content into a shorter, concise version suitable for further analysis or interpretation. Include references to the book name {{bookName}} and author {{authorName}} in the summary:",
                "{{content}}",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _ALTERNATE_TAKES_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: [
                "You are an AI designed to provide alternate takes on specific topics covered in the provided content from the book {{bookName}} by {{authorName}}.",
                "Your task is to generate detailed explanations from other authors' perspectives on how their material relates to or contradicts the specific topics covered in the content.",
                "The output should be a list of JSON objects with two fields: 'reference' and 'content'.",
                "'reference' should be an object with 'book' and 'author' fields, indicating the book name and author name of the alternate perspective.",
                "'content' should be HTML formatted with a few paragraphs explaining deeply how the alternate material relates to or contradicts the specific topics covered.",
            ],
        },
        {
            role: "user",
            content: [
                "Provide alternate takes by other authors on the specific topics covered in the content from the book {{bookName}} by {{authorName}}. For each alternate take, include the following details:",
                "1. Reference as an object with 'book' and 'author' fields for the alternate perspective.",
                "2. HTML formatted content with a few paragraphs explaining how the alternate material relates to or contradicts the specific topics covered.",
                "Here is the content for reference:",
                "{{content}}",
            ],
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/book/themedetail/route.ts":
/*!***********************************************!*\
  !*** ./src/modules/book/themedetail/route.ts ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/book/themedetail/service.ts");
module.exports = function (router) {
    router.put("/book/theme-detail/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateThemeDetail));
    router.post("/book/theme-detail/:space/:bookref/:conceptref/:themeref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createThemeDetail));
    router.get("/book/theme-detail/:space/:bookref/:conceptref/:themeref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getThemeDetailsByBookReference));
    router.delete("/book/theme-detail/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteThemeDetail));
};


/***/ }),

/***/ "./src/modules/book/themedetail/service.ts":
/*!*************************************************!*\
  !*** ./src/modules/book/themedetail/service.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteThemeDetail = exports.getThemeDetailsByBookReferenceShortform = exports.getThemeDetailsByBookReference = exports.updateThemeDetail = exports.createThemeDetail = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/book/themedetail/helper.ts"));
var createThemeDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, themeDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createThemeDetail(req.params.space, req.params.bookref, req.params.conceptref, req.params.themeref, req.body, userId)];
            case 1:
                themeDetail = _a.sent();
                res.status(200);
                res.send(themeDetail);
                res.end();
                return [2];
        }
    });
}); };
exports.createThemeDetail = createThemeDetail;
var updateThemeDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, themeDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateThemeDetail(req.params.space, req.params.id, req.body, userId)];
            case 1:
                themeDetail = _a.sent();
                res.status(200);
                res.send(themeDetail);
                res.end();
                return [2];
        }
    });
}); };
exports.updateThemeDetail = updateThemeDetail;
var getThemeDetailsByBookReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, themeDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getThemeDetailsByBookReference(req.params.space, req.params.bookref, req.params.conceptref, req.params.themeref)];
            case 1:
                themeDetail = _a.sent();
                res.status(200);
                res.send(themeDetail);
                res.end();
                return [2];
        }
    });
}); };
exports.getThemeDetailsByBookReference = getThemeDetailsByBookReference;
var getThemeDetailsByBookReferenceShortform = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, themeDetail;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getThemeDetailsByBookReferenceShortform(req.params.space, req.params.bookref)];
            case 1:
                themeDetail = _a.sent();
                res.status(200);
                res.send(themeDetail);
                res.end();
                return [2];
        }
    });
}); };
exports.getThemeDetailsByBookReferenceShortform = getThemeDetailsByBookReferenceShortform;
var deleteThemeDetail = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteThemeDetail(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteThemeDetail = deleteThemeDetail;


/***/ }),

/***/ "./src/modules/colorfilter/helper.ts":
/*!*******************************************!*\
  !*** ./src/modules/colorfilter/helper.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.move = exports.deleteColorfilter = exports.getColorfilter = exports.updateColorfilterItem = exports.updateColorfilter = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/colorfilter/model.ts");
var getCollection = (__webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var updateColorfilter = function (space, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, order;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.colorfilterCollection, model_1.colorfilterSchema);
                response = null;
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, data, { new: true, upsert: true })];
            case 1:
                response = _a.sent();
                return [3, 5];
            case 2: return [4, model.find().count()];
            case 3:
                order = (_a.sent()) + 1;
                return [4, model.create(__assign(__assign({}, data), { order: order }))];
            case 4:
                response = _a.sent();
                _a.label = 5;
            case 5: return [4, (0, exports.getColorfilter)(space)];
            case 6: return [2, _a.sent()];
        }
    });
}); };
exports.updateColorfilter = updateColorfilter;
var updateColorfilterItem = function (space, data) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.colorfilterCollection, model_1.colorfilterSchema);
                response = null;
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, data, { new: true, upsert: true })];
            case 1:
                response = _a.sent();
                return [3, 4];
            case 2: return [4, model.create(data)];
            case 3:
                response = _a.sent();
                _a.label = 4;
            case 4: return [2, response];
        }
    });
}); };
exports.updateColorfilterItem = updateColorfilterItem;
var getColorfilter = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.colorfilterCollection, model_1.colorfilterSchema);
                return [4, model.find().sort({ order: "ascending" })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getColorfilter = getColorfilter;
var deleteColorfilter = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.colorfilterCollection, model_1.colorfilterSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { colorfilter: [_id] }];
        }
    });
}); };
exports.deleteColorfilter = deleteColorfilter;
var move = function (space, _id, mode) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data, currentItem, impactedItem;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.colorfilterCollection, model_1.colorfilterSchema);
                return [4, model.find()];
            case 1:
                data = _a.sent();
                currentItem = data.find(function (item) {
                    return item._id.toString() === _id;
                });
                if (!currentItem) {
                    return [2, { 'status': 'data not found' }];
                }
                return [4, model.findByIdAndUpdate(_id, { order: mode === 'up' ? currentItem.order - 1 : currentItem.order + 1 }, { new: true, upsert: true })];
            case 2:
                _a.sent();
                impactedItem = data.find(function (item) {
                    if (mode === 'up') {
                        return item.order === currentItem.order - 1;
                    }
                    else {
                        return item.order === currentItem.order + 1;
                    }
                });
                return [4, model.findByIdAndUpdate(impactedItem._id, { order: mode === 'up' ? impactedItem.order + 1 : impactedItem.order - 1 }, { new: true, upsert: true })];
            case 3:
                _a.sent();
                return [4, (0, exports.getColorfilter)(space)];
            case 4: return [2, _a.sent()];
        }
    });
}); };
exports.move = move;


/***/ }),

/***/ "./src/modules/colorfilter/model.ts":
/*!******************************************!*\
  !*** ./src/modules/colorfilter/model.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.colorfilterCollection = exports.colorfilterSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var colorfilterSchema = new Schema({
    name: { type: String },
    color: { type: String },
    text: { type: String },
    textList: { type: Array },
    searchPref: { type: Object },
    order: { type: Number }
}, { timestamps: true, minimize: false });
exports.colorfilterSchema = colorfilterSchema;
var colorfilterCollection = "colorfilter";
exports.colorfilterCollection = colorfilterCollection;


/***/ }),

/***/ "./src/modules/colorfilter/route.ts":
/*!******************************************!*\
  !*** ./src/modules/colorfilter/route.ts ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/colorfilter/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.put("/color-filter/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateColorfilter));
    router.get("/color-filter/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getColorfilter));
    router.delete("/color-filter/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteColorfilter));
    router.post("/color-filter/:space/up/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.moveUp));
    router.post("/color-filter/:space/down/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.moveDown));
};


/***/ }),

/***/ "./src/modules/colorfilter/service.ts":
/*!********************************************!*\
  !*** ./src/modules/colorfilter/service.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moveDown = exports.moveUp = exports.deleteColorfilter = exports.getColorfilter = exports.updateColorfilterItem = exports.updateColorfilter = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/colorfilter/helper.ts"));
var selfRealm = 100;
var updateColorfilter = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, colorfilter;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateColorfilter(req.params.space, req.body, userId)];
            case 1:
                colorfilter = _a.sent();
                res.status(200);
                res.send(colorfilter);
                res.end();
                return [2];
        }
    });
}); };
exports.updateColorfilter = updateColorfilter;
var updateColorfilterItem = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, colorfilter;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateColorfilterItem(req.params.space, req.body)];
            case 1:
                colorfilter = _a.sent();
                res.status(200);
                res.send(colorfilter);
                res.end();
                return [2];
        }
    });
}); };
exports.updateColorfilterItem = updateColorfilterItem;
var getColorfilter = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, colorfilterList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getColorfilter(req.params.space)];
            case 1:
                colorfilterList = _a.sent();
                res.status(200);
                res.send(colorfilterList);
                res.end();
                return [2];
        }
    });
}); };
exports.getColorfilter = getColorfilter;
var deleteColorfilter = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteColorfilter(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteColorfilter = deleteColorfilter;
var moveUp = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.move(req.params.space, req.params.id, 'up')];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.moveUp = moveUp;
var moveDown = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.move(req.params.space, req.params.id, 'down')];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.moveDown = moveDown;


/***/ }),

/***/ "./src/modules/company/helper.ts":
/*!***************************************!*\
  !*** ./src/modules/company/helper.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCompanyByIdList = exports.getCompanyByReference = exports.getCompany = exports.updateCompany = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/company/model.ts");
var dbutils_1 = __webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts");
var service_1 = __webpack_require__(/*! ../sequence/service */ "./src/modules/sequence/service.ts");
var StopwordsHelper = __importStar(__webpack_require__(/*! ../stopwords/helper */ "./src/modules/stopwords/helper.ts"));
var updateCompany = function (data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response_1, response, _a, _b, _c;
    var _d;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.companyCollection, model_1.companySchema);
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, __assign({}, data), { new: true, upsert: true })];
            case 1:
                response_1 = _e.sent();
                return [2, response_1];
            case 2:
                _b = (_a = model).create;
                _c = [__assign({}, data)];
                _d = {};
                return [4, (0, service_1.nextval)("companyId")];
            case 3: return [4, _b.apply(_a, [__assign.apply(void 0, _c.concat([(_d.reference = _e.sent(), _d)]))])];
            case 4:
                response = _e.sent();
                return [4, (0, service_1.create_sequence)("noteId", null, 1, response.reference)];
            case 5:
                _e.sent();
                return [4, (0, service_1.create_sequence)("libraryId", null, 1, response.reference)];
            case 6:
                _e.sent();
                return [4, StopwordsHelper.resetStopwords(response.reference)];
            case 7:
                _e.sent();
                return [2, response];
        }
    });
}); };
exports.updateCompany = updateCompany;
var getCompany = function () { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.companyCollection, model_1.companySchema);
                return [4, model.find()];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getCompany = getCompany;
var getCompanyByReference = function (reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.companyCollection, model_1.companySchema);
                return [4, model.findOne({ reference: reference })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getCompanyByReference = getCompanyByReference;
var getCompanyByIdList = function (idList) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.companyCollection, model_1.companySchema);
                return [4, model.find({ _id: { $in: idList } })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getCompanyByIdList = getCompanyByIdList;


/***/ }),

/***/ "./src/modules/company/model.ts":
/*!**************************************!*\
  !*** ./src/modules/company/model.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.companyCollection = exports.companySchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var companySchema = new Schema({
    name: { type: String },
    description: { type: String },
    reference: { type: Number },
    currency: { type: String },
    numberFormat: { type: String },
}, { timestamps: true });
exports.companySchema = companySchema;
var companyCollection = "company";
exports.companyCollection = companyCollection;


/***/ }),

/***/ "./src/modules/company/route.ts":
/*!**************************************!*\
  !*** ./src/modules/company/route.ts ***!
  \**************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/company/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.put("/company", middlewares_1.authorizeApi, service_1.updateCompany);
    router.get("/company", middlewares_1.authorizeApi, service_1.getCompany);
};


/***/ }),

/***/ "./src/modules/company/service.ts":
/*!****************************************!*\
  !*** ./src/modules/company/service.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCompanyByReference = exports.getCompany = exports.updateCompany = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/company/helper.ts"));
var userInviteService = __importStar(__webpack_require__(/*! ../user/invite/service */ "./src/modules/user/invite/service.ts"));
var PermissionHelper = __importStar(__webpack_require__(/*! ../permission/helper */ "./src/modules/permission/helper.ts"));
var selfRealm = 100;
var updateCompany = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, company;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateCompany(req.body, userId)];
            case 1:
                company = _a.sent();
                userInviteService.registerUserInvite(company._doc.reference, company._doc._id, userId, req.user.email);
                return [4, PermissionHelper.addRole(req.user.email, company._doc.reference)];
            case 2:
                _a.sent();
                res.status(200);
                res.send(company);
                res.end();
                return [2];
        }
    });
}); };
exports.updateCompany = updateCompany;
var getCompany = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, companyList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getCompany()];
            case 1:
                companyList = _a.sent();
                res.status(200);
                res.send(companyList);
                res.end();
                return [2];
        }
    });
}); };
exports.getCompany = getCompany;
var getCompanyByReference = function (reference) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.getCompanyByReference(reference)];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getCompanyByReference = getCompanyByReference;


/***/ }),

/***/ "./src/modules/flashcard/helper.ts":
/*!*****************************************!*\
  !*** ./src/modules/flashcard/helper.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.importFileForFlashcard = void 0;
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/flashcard/service.ts");
var Gptutils = __importStar(__webpack_require__(/*! ../../lib/gptutils */ "./src/lib/gptutils.ts"));
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/flashcard/prompt.ts");
var importFileForFlashcard = function (space, files, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var text, gptResponseText;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, (0, service_1.imageToText)(files)];
            case 1:
                text = _a.sent();
                return [4, Gptutils.predict((0, prompt_1.getCleanTextPrompt)(text))];
            case 2:
                gptResponseText = _a.sent();
                return [2, gptResponseText];
        }
    });
}); };
exports.importFileForFlashcard = importFileForFlashcard;


/***/ }),

/***/ "./src/modules/flashcard/prompt.ts":
/*!*****************************************!*\
  !*** ./src/modules/flashcard/prompt.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCleanTextPrompt = exports.getFlastCardPrompt = void 0;
var Handlebars = __importStar(__webpack_require__(/*! handlebars */ "handlebars"));
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
;
var getFlastCardPrompt = function (text) {
    var prompt = (0, lodash_1.cloneDeep)(_CLEAN_TEXT_PROMPT);
    for (var i = 0; i < prompt.messages.length; i++) {
        prompt.messages[i].content = Handlebars.compile(prompt.messages[i].content)({ text: text });
    }
    console.log(prompt);
    return prompt;
};
exports.getFlastCardPrompt = getFlastCardPrompt;
var getCleanTextPrompt = function (text) {
    var prompt = (0, lodash_1.cloneDeep)(_CLEAN_TEXT_PROMPT);
    for (var i = 0; i < prompt.messages.length; i++) {
        prompt.messages[i].content = Handlebars.compile(prompt.messages[i].content)({ text: text });
    }
    console.log(prompt);
    return prompt;
};
exports.getCleanTextPrompt = getCleanTextPrompt;
var _FLASH_CARD_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: "You are an AI assistant that will help with text extraction and creating educational materials. You should clean up and correct text extracted from a scanned copy of a book before generating flashcards. The response must be in JSON format only, without any additional text.",
        },
        {
            role: "user",
            content: "I have text content extracted from a scanned copy of a few pages of a book using tesseract.js. The extraction process was not accurate, so please correct and clean the text. After cleaning, generate a set of 25 flashcards to help me learn and understand the concept better. Each flashcard should be concise enough to fit onto a card and formatted as a JSON array of objects with the fields 'front' and 'back'. Here is the text: {{text}}",
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _CLEAN_TEXT_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: "You are ChatGPT, an advanced assistant. Your role is to take raw, unstructured text extracted from scanned book pages, correct any errors in the text, and rephrase it into a coherent, structured format suitable for study. After cleaning the text, interpret the subject matter in depth and generate a detailed, well-organized essay. The essay should be written in a series of simple paragraphs, covering the complete subject, without using headings or bullet points. The output should be in HTML format, utilizing only paragraph, bold, and italic tags to emphasize important points, ensuring it is easy to follow for a student.",
        },
        {
            role: "user",
            content: "{{text}}",
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/flashcard/route.ts":
/*!****************************************!*\
  !*** ./src/modules/flashcard/route.ts ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/flashcard/service.ts");
var multer = __webpack_require__(/*! multer */ "multer");
var storage = multer.memoryStorage();
var upload = multer({ storage: storage });
module.exports = function (router) {
    router.post("/flashcard/:space/upload", upload.array("files"), middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.importFileForFlashcard));
};


/***/ }),

/***/ "./src/modules/flashcard/service.ts":
/*!******************************************!*\
  !*** ./src/modules/flashcard/service.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.imageToText = exports.importFileForFlashcard = void 0;
var tesseract_js_1 = __importDefault(__webpack_require__(/*! tesseract.js */ "tesseract.js"));
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/flashcard/helper.ts"));
var selfRealm = 100;
var importFileForFlashcard = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log("*");
                userId = req.user.user_id;
                return [4, Helper.importFileForFlashcard(req.params.space, req.files, userId)];
            case 1:
                response = _a.sent();
                res.status(200);
                res.send(response);
                res.end();
                return [2];
        }
    });
}); };
exports.importFileForFlashcard = importFileForFlashcard;
var imageToText = function (files) { return __awaiter(void 0, void 0, void 0, function () {
    var cleanText, texts, i, text, error_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                cleanText = function (text) {
                    return text
                        .replace(/^\d+\s*\n/gm, "")
                        .replace(/^(Page \d+)\s*\n/gm, "")
                        .replace(/^\s*\n/gm, "")
                        .trim();
                };
                texts = "";
                _a.label = 1;
            case 1:
                _a.trys.push([1, 6, , 7]);
                i = 0;
                _a.label = 2;
            case 2:
                if (!(i < files.length)) return [3, 5];
                return [4, tesseract_js_1.default.recognize(files[i].buffer, "eng", {
                        logger: function (m) { return console.log(m); },
                    })];
            case 3:
                text = (_a.sent()).data.text;
                texts += "\n" + cleanText(text);
                _a.label = 4;
            case 4:
                i++;
                return [3, 2];
            case 5: return [3, 7];
            case 6:
                error_1 = _a.sent();
                console.error("Error processing files:", error_1);
                throw new Error("Failed to process files.");
            case 7: return [2, texts];
        }
    });
}); };
exports.imageToText = imageToText;


/***/ }),

/***/ "./src/modules/hello/helper.ts":
/*!*************************************!*\
  !*** ./src/modules/hello/helper.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.train_similarity_model = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var NoteHelper = __importStar(__webpack_require__(/*! ../note/helper */ "./src/modules/note/helper.ts"));
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var train_similarity_model = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log("admin training started");
                return [4, NoteHelper._ai_train(space)];
            case 1:
                _a.sent();
                console.log("admin populate started");
                return [4, NoteHelper._ai_populate(space)];
            case 2:
                _a.sent();
                console.log("admin training and populate finished");
                return [2, { "status": "success" }];
        }
    });
}); };
exports.train_similarity_model = train_similarity_model;


/***/ }),

/***/ "./src/modules/hello/route.ts":
/*!************************************!*\
  !*** ./src/modules/hello/route.ts ***!
  \************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/hello/service.ts");
module.exports = function (router) {
    router.get("/admin", function (_, res) {
        res.send("basic connection to server works. database connection is not validated");
        res.end();
    });
    router.get("/admin/:space/train", (0, handler_1.asyncHandler)(service_1.train_similarity_model));
};


/***/ }),

/***/ "./src/modules/hello/service.ts":
/*!**************************************!*\
  !*** ./src/modules/hello/service.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.train_similarity_model = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/hello/helper.ts"));
var selfRealm = 100;
var train_similarity_model = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var note;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.train_similarity_model(req.params.space)];
            case 1:
                note = _a.sent();
                res.status(200);
                res.send(note);
                res.end();
                return [2];
        }
    });
}); };
exports.train_similarity_model = train_similarity_model;


/***/ }),

/***/ "./src/modules/import/helper.ts":
/*!**************************************!*\
  !*** ./src/modules/import/helper.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.importExpense = exports.transformBudgetDataForExport = exports.transformIncomeDataForExport = exports.transformExpenseDataForExport = exports.exportData = exports.deleteTransaction = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var fs = __webpack_require__(/*! fs */ "fs");
var Papa = __importStar(__webpack_require__(/*! papaparse */ "papaparse"));
var date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
var uuid_1 = __webpack_require__(/*! uuid */ "uuid");
var LogHelper = __importStar(__webpack_require__(/*! ./log/helper */ "./src/modules/import/log/helper.ts"));
var NoteHelper = __importStar(__webpack_require__(/*! ../note/helper */ "./src/modules/note/helper.ts"));
var NotelinkHelper = __importStar(__webpack_require__(/*! ../notelink/helper */ "./src/modules/notelink/helper.ts"));
var refDate = new Date();
var deleteTransaction = function (space, transactionId, userId) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, LogHelper.deleteLogByTransactionId(space, transactionId)];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); };
exports.deleteTransaction = deleteTransaction;
var exportData = function (space, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var note, notelink, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, NoteHelper.getNote(space)];
            case 1:
                note = _a.sent();
                return [4, NotelinkHelper.getNotelink(space)];
            case 2:
                notelink = _a.sent();
                response = {
                    note: note,
                    notelink: notelink
                };
                return [2, response];
        }
    });
}); };
exports.exportData = exportData;
var transformExpenseDataForExport = function (expenseList, receiptMap, categoryMap) {
    return expenseList.map(function (item) {
        var _a, _b, _c, _d;
        return {
            type: "expense",
            category: ((_a = categoryMap[item.category]) === null || _a === void 0 ? void 0 : _a.name) || "",
            kakeibo: ((_b = categoryMap[item.category]) === null || _b === void 0 ? void 0 : _b.kakeibo) || "",
            date: item.billDate,
            description: item.description,
            amount: item.amount,
            billDescription: (_c = receiptMap[item.billId]) === null || _c === void 0 ? void 0 : _c.description,
            billNumber: (_d = receiptMap[item.billId]) === null || _d === void 0 ? void 0 : _d.number,
        };
    });
};
exports.transformExpenseDataForExport = transformExpenseDataForExport;
var transformIncomeDataForExport = function (incomeList, categoryMap) {
    return incomeList.map(function (item) {
        var _a;
        return {
            type: "income",
            category: ((_a = categoryMap[item.category]) === null || _a === void 0 ? void 0 : _a.name) || "",
            date: item.billDate,
            description: item.description,
            amount: item.amount,
        };
    });
};
exports.transformIncomeDataForExport = transformIncomeDataForExport;
var transformBudgetDataForExport = function (budgetList, categoryMap) {
    return budgetList.map(function (item) {
        var _a, _b;
        return {
            type: "budget",
            category: ((_a = categoryMap[item.categoryId]) === null || _a === void 0 ? void 0 : _a.name) || "",
            kakeibo: ((_b = categoryMap[item.categoryId]) === null || _b === void 0 ? void 0 : _b.kakeibo) || "",
            year: item.year,
            month: item.month,
            amount: item.amount,
        };
    });
};
exports.transformBudgetDataForExport = transformBudgetDataForExport;
var importExpense = function (space, file, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var content, expenseContent, incomeContent, budgetContent, transactionId, logResponse;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                content = Papa.parse(file.buffer.toString("utf8"), {
                    quoteChar: '"',
                    escapeChar: '"',
                    delimiter: ",",
                    header: true,
                    newline: "\r\n",
                    skipEmptyLines: true,
                    transformHeader: function (h) { return h.trim().replace(/"/g, ""); },
                });
                expenseContent = content.data.filter(function (item) { return !["income", "budget"].includes(item.type); });
                incomeContent = content.data.filter(function (item) { return item.type === "income"; });
                budgetContent = content.data.filter(function (item) { return item.type === "budget"; });
                transactionId = (0, uuid_1.v4)();
                return [4, LogHelper.addLog(space, transactionId, new Date())];
            case 1:
                logResponse = _a.sent();
                return [2, {
                        log: __assign(__assign({}, logResponse._doc), { transactionDate: (0, date_fns_1.format)(logResponse.transactionDate, "yyyy-MM-dd") }),
                    }];
        }
    });
}); };
exports.importExpense = importExpense;


/***/ }),

/***/ "./src/modules/import/log/helper.ts":
/*!******************************************!*\
  !*** ./src/modules/import/log/helper.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteLogByTransactionId = exports.addLog = exports.getLog = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/import/log/model.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var date_fns_1 = __webpack_require__(/*! date-fns */ "date-fns");
var getLog = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.importLogCollection, model_1.importLogSchema);
                return [4, model.find({}).sort({ transactionDate: -1 })];
            case 1:
                response = _a.sent();
                return [2, response.map(function (record) {
                        return __assign(__assign({}, record._doc), { _id: record._id, transactionDate: (0, date_fns_1.format)(record.transactionDate, "yyyy-MM-dd") });
                    })];
        }
    });
}); };
exports.getLog = getLog;
var addLog = function (space, transactionId, transactionDate) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.importLogCollection, model_1.importLogSchema);
                return [4, model.create({
                        transactionId: transactionId,
                        transactionDate: transactionDate,
                    })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.addLog = addLog;
var deleteLogByTransactionId = function (space, transactionId) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.importLogCollection, model_1.importLogSchema);
                return [4, model.deleteMany({
                        transactionId: transactionId,
                    })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.deleteLogByTransactionId = deleteLogByTransactionId;


/***/ }),

/***/ "./src/modules/import/log/model.ts":
/*!*****************************************!*\
  !*** ./src/modules/import/log/model.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.importLogCollection = exports.importLogSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var importLogSchema = new Schema({
    transactionId: { type: String },
    transactionDate: { type: Date },
    expenseRecords: { type: Number },
    expenseTotal: { type: Number },
    incomeRecords: { type: Number },
    incomeTotal: { type: Number },
    receiptRecords: { type: Number },
    receiptTotal: { type: Number },
    budgetRecords: { type: Number },
    budgetTotal: { type: Number },
    categoryRecords: { type: Number },
    incomeCategoryRecords: { type: Number },
    tagRecords: { type: Number },
}, { timestamps: true });
exports.importLogSchema = importLogSchema;
var importLogCollection = "import.log";
exports.importLogCollection = importLogCollection;


/***/ }),

/***/ "./src/modules/import/log/route.ts":
/*!*****************************************!*\
  !*** ./src/modules/import/log/route.ts ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/import/log/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.get("/import/log/:space", middlewares_1.authorizeApi, service_1.getLog);
};


/***/ }),

/***/ "./src/modules/import/log/service.ts":
/*!*******************************************!*\
  !*** ./src/modules/import/log/service.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLog = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/import/log/helper.ts"));
var selfRealm = 100;
var getLog = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, logList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getLog(req.params.space)];
            case 1:
                logList = _a.sent();
                res.status(200);
                res.send(logList);
                res.end();
                return [2];
        }
    });
}); };
exports.getLog = getLog;


/***/ }),

/***/ "./src/modules/import/route.ts":
/*!*************************************!*\
  !*** ./src/modules/import/route.ts ***!
  \*************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/import/service.ts");
var multer = __webpack_require__(/*! multer */ "multer");
var upload = multer();
var selfRealm = 100;
module.exports = function (router) {
    router.post("/import/:space", upload.single("file"), middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.importExpense));
    router.post("/export/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.exportData));
    router.delete("/import/:space/transaction/:transactionId", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteTransaction));
};


/***/ }),

/***/ "./src/modules/import/service.ts":
/*!***************************************!*\
  !*** ./src/modules/import/service.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteTransaction = exports.exportData = exports.importExpense = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/import/helper.ts"));
var selfRealm = 100;
var importExpense = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.importExpense(req.params.space, req.file, userId)];
            case 1:
                response = _a.sent();
                res.status(200);
                res.send(response);
                res.end();
                return [2];
        }
    });
}); };
exports.importExpense = importExpense;
var exportData = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.exportData(req.params.space, userId)];
            case 1:
                response = _a.sent();
                res.status(200);
                res.send(response);
                res.end();
                return [2];
        }
    });
}); };
exports.exportData = exportData;
var deleteTransaction = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteTransaction(req.params.space, req.params.transactionId, userId)];
            case 1:
                response = _a.sent();
                res.status(200);
                res.send(response);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteTransaction = deleteTransaction;


/***/ }),

/***/ "./src/modules/keywords/helper.ts":
/*!****************************************!*\
  !*** ./src/modules/keywords/helper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getKeywords = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/keywords/model.ts");
var getCollection = (__webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var getKeywords = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.keywordsCollection, model_1.keywordsSchema);
                return [4, model.find()];
            case 1:
                res = _a.sent();
                if (res.length > 0) {
                    return [2, res[0].data];
                }
                return [2, []];
        }
    });
}); };
exports.getKeywords = getKeywords;


/***/ }),

/***/ "./src/modules/keywords/model.ts":
/*!***************************************!*\
  !*** ./src/modules/keywords/model.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keywordsCollection = exports.keywordsSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var keywordsSchema = new Schema({
    data: { type: Array },
}, { timestamps: true, minimize: false });
exports.keywordsSchema = keywordsSchema;
var keywordsCollection = "keywords";
exports.keywordsCollection = keywordsCollection;


/***/ }),

/***/ "./src/modules/keywords/route.ts":
/*!***************************************!*\
  !*** ./src/modules/keywords/route.ts ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/keywords/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.get("/keywords/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getKeywords));
};


/***/ }),

/***/ "./src/modules/keywords/service.ts":
/*!*****************************************!*\
  !*** ./src/modules/keywords/service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getKeywords = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/keywords/helper.ts"));
var selfRealm = 100;
var getKeywords = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var keywords;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.getKeywords(req.params.space)];
            case 1:
                keywords = _a.sent();
                res.status(200);
                res.send(keywords);
                res.end();
                return [2];
        }
    });
}); };
exports.getKeywords = getKeywords;


/***/ }),

/***/ "./src/modules/label/helper.ts":
/*!*************************************!*\
  !*** ./src/modules/label/helper.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLabel = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var NoteTagHelper = __importStar(__webpack_require__(/*! ../note/tag/helper */ "./src/modules/note/tag/helper.ts"));
var NoteHelper = __importStar(__webpack_require__(/*! ../note/helper */ "./src/modules/note/helper.ts"));
var getLabel = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var noteTags, labels;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, NoteTagHelper.getTag(space)];
            case 1:
                noteTags = _a.sent();
                return [4, NoteHelper.getLabels(space)];
            case 2:
                labels = _a.sent();
                return [2, labels];
        }
    });
}); };
exports.getLabel = getLabel;


/***/ }),

/***/ "./src/modules/label/route.ts":
/*!************************************!*\
  !*** ./src/modules/label/route.ts ***!
  \************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/label/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.get("/label/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getLabel));
};


/***/ }),

/***/ "./src/modules/label/service.ts":
/*!**************************************!*\
  !*** ./src/modules/label/service.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLabel = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/label/helper.ts"));
var selfRealm = 100;
var getLabel = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, labelList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getLabel(req.params.space)];
            case 1:
                labelList = _a.sent();
                res.status(200);
                res.send(labelList);
                res.end();
                return [2];
        }
    });
}); };
exports.getLabel = getLabel;


/***/ }),

/***/ "./src/modules/metadata/definition/helper.ts":
/*!***************************************************!*\
  !*** ./src/modules/metadata/definition/helper.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteMetadataDefinition = exports.getMetadataDefinition = exports.updateMetadataDefinition = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/metadata/definition/model.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var updateMetadataDefinition = function (space, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, allRecords, responseList, idList, i, response_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.metadataDefinitionCollection, model_1.metadataDefinitionSchema);
                response = null;
                return [4, model.find()];
            case 1:
                allRecords = _a.sent();
                responseList = [];
                idList = [];
                i = 0;
                _a.label = 2;
            case 2:
                if (!(i < data.length)) return [3, 5];
                return [4, updateMetadataDefinitionItem(space, data[i], allRecords)];
            case 3:
                response_1 = _a.sent();
                responseList.push(response_1);
                idList.push(response_1._id);
                _a.label = 4;
            case 4:
                i++;
                return [3, 2];
            case 5: return [4, model.deleteMany({ _id: { $nin: idList } })];
            case 6:
                _a.sent();
                return [4, model.find().sort({ group: "ascending", name: "ascending" })];
            case 7: return [2, _a.sent()];
        }
    });
}); };
exports.updateMetadataDefinition = updateMetadataDefinition;
var updateMetadataDefinitionItem = function (space, data, allRecords) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.metadataDefinitionCollection, model_1.metadataDefinitionSchema);
                response = null;
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, __assign(__assign({}, data), { linkable: data.linkable && data.type === 'short-text' }), { new: true, upsert: true })];
            case 1:
                response = _a.sent();
                return [3, 4];
            case 2: return [4, model.create(__assign(__assign({}, data), { linkable: data.linkable && data.type === 'short-text' }))];
            case 3:
                response = _a.sent();
                _a.label = 4;
            case 4: return [2, response];
        }
    });
}); };
var getMetadataDefinition = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.metadataDefinitionCollection, model_1.metadataDefinitionSchema);
                return [4, model.find().sort({ group: "ascending", name: "ascending" })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getMetadataDefinition = getMetadataDefinition;
var deleteMetadataDefinition = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.metadataDefinitionCollection, model_1.metadataDefinitionSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { metadataDefinition: [_id] }];
        }
    });
}); };
exports.deleteMetadataDefinition = deleteMetadataDefinition;


/***/ }),

/***/ "./src/modules/metadata/definition/model.ts":
/*!**************************************************!*\
  !*** ./src/modules/metadata/definition/model.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.metadataDefinitionCollection = exports.metadataDefinitionSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var metadataDefinitionSchema = new Schema({
    reference: { type: String },
    name: { type: String },
    group: { type: String },
    type: { type: String },
    linkable: { type: Boolean }
}, { timestamps: true });
exports.metadataDefinitionSchema = metadataDefinitionSchema;
var metadataDefinitionCollection = "metadata.definition";
exports.metadataDefinitionCollection = metadataDefinitionCollection;


/***/ }),

/***/ "./src/modules/metadata/definition/route.ts":
/*!**************************************************!*\
  !*** ./src/modules/metadata/definition/route.ts ***!
  \**************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/metadata/definition/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.post("/metadata-definition/:space/full", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateMetadataDefinition));
    router.get("/metadata-definition/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getMetadataDefinition));
    router.delete("/metadata-definition/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteMetadataDefinition));
};


/***/ }),

/***/ "./src/modules/metadata/definition/service.ts":
/*!****************************************************!*\
  !*** ./src/modules/metadata/definition/service.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteMetadataDefinition = exports.getMetadataDefinition = exports.updateMetadataDefinition = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/metadata/definition/helper.ts"));
var selfRealm = 100;
var updateMetadataDefinition = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, metadataDefinition;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateMetadataDefinition(req.params.space, req.body, userId)];
            case 1:
                metadataDefinition = _a.sent();
                res.status(200);
                res.send(metadataDefinition);
                res.end();
                return [2];
        }
    });
}); };
exports.updateMetadataDefinition = updateMetadataDefinition;
var getMetadataDefinition = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, metadataDefinitionList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getMetadataDefinition(req.params.space)];
            case 1:
                metadataDefinitionList = _a.sent();
                res.status(200);
                res.send(metadataDefinitionList);
                res.end();
                return [2];
        }
    });
}); };
exports.getMetadataDefinition = getMetadataDefinition;
var deleteMetadataDefinition = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteMetadataDefinition(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteMetadataDefinition = deleteMetadataDefinition;


/***/ }),

/***/ "./src/modules/metadata/value/helper.ts":
/*!**********************************************!*\
  !*** ./src/modules/metadata/value/helper.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMetadataValue = void 0;
var model_1 = __webpack_require__(/*! ../../note/model */ "./src/modules/note/model.ts");
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var MetadataDefinitionHelper = __importStar(__webpack_require__(/*! ../definition/helper */ "./src/modules/metadata/definition/helper.ts"));
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var getMetadataValue = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, metadataDefinitionList, response, i, id, _a, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, MetadataDefinitionHelper.getMetadataDefinition(space)];
            case 1:
                metadataDefinitionList = _c.sent();
                response = {};
                i = 0;
                _c.label = 2;
            case 2:
                if (!(i < metadataDefinitionList.length)) return [3, 5];
                id = metadataDefinitionList[i]._id.toString();
                if (!metadataDefinitionList[i].linkable) return [3, 4];
                _a = response;
                _b = id;
                return [4, model.find().distinct(id)];
            case 3:
                _a[_b] = _c.sent();
                _c.label = 4;
            case 4:
                i++;
                return [3, 2];
            case 5: return [2, response];
        }
    });
}); };
exports.getMetadataValue = getMetadataValue;


/***/ }),

/***/ "./src/modules/metadata/value/route.ts":
/*!*********************************************!*\
  !*** ./src/modules/metadata/value/route.ts ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/metadata/value/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.get("/metadata-value/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getMetadataValue));
};


/***/ }),

/***/ "./src/modules/metadata/value/service.ts":
/*!***********************************************!*\
  !*** ./src/modules/metadata/value/service.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getMetadataValue = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/metadata/value/helper.ts"));
var selfRealm = 100;
var getMetadataValue = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, metadataValueList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getMetadataValue(req.params.space)];
            case 1:
                metadataValueList = _a.sent();
                res.status(200);
                res.send(metadataValueList);
                res.end();
                return [2];
        }
    });
}); };
exports.getMetadataValue = getMetadataValue;


/***/ }),

/***/ "./src/modules/note/helper.ts":
/*!************************************!*\
  !*** ./src/modules/note/helper.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.brainstormUsingAi = exports.getKeywords = exports.getLabels = exports._ai_populate = exports._ai_train = exports.browseNotes = exports.getNotesByMetadataValue = exports.searchNote = exports.searchNoteByText = exports.deleteNoteByReferenceList = exports.deleteNoteByReference = exports.deleteNote = exports.getNotesByReferenceList = exports.getNotesByFolderIdList = exports.deleteNotesByFolderIdList = exports.getNoteById = exports.getNoteByBookref = exports.getNoteByReference = exports.getRecentlyCreatedNote = exports.getNoteDictionary = exports.getNote = exports.createNote = exports.updateNote = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var Gptutils = __importStar(__webpack_require__(/*! ../../lib/gptutils */ "./src/lib/gptutils.ts"));
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/note/model.ts");
var getCollection = (__webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var service_1 = __webpack_require__(/*! ../sequence/service */ "./src/modules/sequence/service.ts");
var NotelinkHelper = __importStar(__webpack_require__(/*! ../notelink/helper */ "./src/modules/notelink/helper.ts"));
var MetadataDefinitionHelper = __importStar(__webpack_require__(/*! ../metadata/definition/helper */ "./src/modules/metadata/definition/helper.ts"));
var ColorfilterHelper = __importStar(__webpack_require__(/*! ../colorfilter/helper */ "./src/modules/colorfilter/helper.ts"));
var NotelinkAutoHelper = __importStar(__webpack_require__(/*! ../notelink/auto/helper */ "./src/modules/notelink/auto/helper.ts"));
var Utils_1 = __webpack_require__(/*! ../../lib/Utils */ "./src/lib/Utils.ts");
var prompt_1 = __webpack_require__(/*! ./prompt */ "./src/modules/note/prompt.ts");
var AI_API = process.env.AI_API || "http://localhost:5003/api";
var SIMILARITY_ALGORITHM = "similarity";
var updateNote = function (space, reload, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, response, contentText, _a, _b, _c, notelinks, noteResponse, note;
    var _d;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                response = null;
                contentText = data.content.replace(/<[^>]*>/g, "");
                if (!data._id) return [3, 2];
                return [4, model.findByIdAndUpdate(data._id, __assign(__assign({}, data), { contentText: contentText }), { new: true, upsert: true })];
            case 1:
                response = _e.sent();
                return [3, 5];
            case 2:
                _b = (_a = model).create;
                _c = [__assign({}, data)];
                _d = {};
                return [4, (0, service_1.nextval)("noteId", undefined, space)];
            case 3: return [4, _b.apply(_a, [__assign.apply(void 0, _c.concat([(_d.reference = _e.sent(), _d.contentText = contentText, _d)]))])];
            case 4:
                response = _e.sent();
                _e.label = 5;
            case 5: return [4, _calculateVectors(space, response.reference)];
            case 6:
                _e.sent();
                return [4, NotelinkAutoHelper.getNotelinkAutoByNoteRef(space, response.reference)];
            case 7:
                notelinks = _e.sent();
                return [4, model.find({ reference: response.reference })];
            case 8:
                noteResponse = _e.sent();
                note = null;
                if (noteResponse.length > 0) {
                    note = noteResponse[0];
                }
                return [2, {
                        notelinks: notelinks,
                        note: note,
                    }];
        }
    });
}); };
exports.updateNote = updateNote;
var createNote = function (space, reload, payload, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data, _a, response, _b, _c, _d, notelinks, noteResponse, note;
    var _e;
    return __generator(this, function (_f) {
        switch (_f.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                if (!payload.autoGenerateOtherDetails) return [3, 2];
                return [4, _enhanceNoteDataUsingAi(space, payload.note)];
            case 1:
                _a = _f.sent();
                return [3, 3];
            case 2:
                _a = _enhanceNoteData(payload.note);
                _f.label = 3;
            case 3:
                data = _a;
                if (!payload.autoGenerateOtherDetails) return [3, 5];
                return [4, _enhanceNoteDataWithMetadataFromRecentNote(space, data)];
            case 4:
                data = _f.sent();
                _f.label = 5;
            case 5:
                response = null;
                _c = (_b = model).create;
                _d = [__assign({}, data)];
                _e = {};
                return [4, (0, service_1.nextval)("noteId", undefined, space)];
            case 6: return [4, _c.apply(_b, [__assign.apply(void 0, _d.concat([(_e.reference = _f.sent(), _e)]))])];
            case 7:
                response = _f.sent();
                return [4, _calculateVectors(space, response.reference)];
            case 8:
                _f.sent();
                return [4, NotelinkAutoHelper.getNotelinkAutoByNoteRef(space, response.reference)];
            case 9:
                notelinks = _f.sent();
                return [4, model.find({ reference: response.reference })];
            case 10:
                noteResponse = _f.sent();
                note = null;
                if (noteResponse.length > 0) {
                    note = noteResponse[0];
                }
                return [2, {
                        notelinks: notelinks,
                        note: note,
                    }];
        }
    });
}); };
exports.createNote = createNote;
var getNote = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.find()];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.getNote = getNote;
var _calculateVectors = function (space, noteref) { return __awaiter(void 0, void 0, void 0, function () {
    var model, retrain, updateCount, notesCount;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                retrain = false;
                return [4, (0, service_1.nextval)("note_update_count", "ai", space)];
            case 1:
                updateCount = _a.sent();
                console.log(updateCount);
                if (updateCount <= 20) {
                    retrain = true;
                }
                if (updateCount > 20 && updateCount <= 100 && updateCount % 10 === 0) {
                    retrain = true;
                }
                if (updateCount > 100 && updateCount <= 500 && updateCount % 25 === 0) {
                    retrain = true;
                }
                if (updateCount > 500 && updateCount <= 1000 && updateCount % 50 === 0) {
                    retrain = true;
                }
                if (updateCount > 1000 && updateCount % 100 === 0) {
                    retrain = true;
                }
                if (!(updateCount % 200 === 0)) return [3, 4];
                return [4, model.find().estimatedDocumentCount()];
            case 2:
                notesCount = _a.sent();
                return [4, (0, service_1.resetval)(notesCount + 2, "note_update_count", "ai", space)];
            case 3:
                _a.sent();
                _a.label = 4;
            case 4:
                if (!retrain) return [3, 7];
                console.log("---retraining");
                return [4, (0, exports._ai_train)(space)];
            case 5:
                _a.sent();
                return [4, (0, exports._ai_populate)(space)];
            case 6:
                _a.sent();
                _a.label = 7;
            case 7: return [4, _ai_populate_for_note(space, noteref)];
            case 8:
                _a.sent();
                return [2];
        }
    });
}); };
var getNoteDictionary = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res, _a, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                _a = _enrichWithGroupColor;
                _b = [space];
                return [4, model.find()];
            case 1: return [4, _a.apply(void 0, _b.concat([_c.sent()]))];
            case 2:
                res = _c.sent();
                return [2, res.map(function (item) {
                        return {
                            _id: item._id,
                            name: item.name,
                            reference: item.reference,
                            summary: (0, Utils_1.isEmptyOrSpaces)(item.summary)
                                ? item.autoGeneratedSummary
                                : item.summary,
                            color: item.color,
                            labels: item.labels,
                        };
                    })];
        }
    });
}); };
exports.getNoteDictionary = getNoteDictionary;
var _enrichWithGroupColor = function (space, data) { return __awaiter(void 0, void 0, void 0, function () {
    var filterGroupList, response, j, _record, out, _filterGroupList, i, _filter, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, ColorfilterHelper.getColorfilter(space)];
            case 1:
                filterGroupList = _a.sent();
                response = [];
                j = 0;
                _a.label = 2;
            case 2:
                if (!(j < data.length)) return [3, 8];
                _record = data[j]._doc;
                out = __assign({}, _record);
                _filterGroupList = filterGroupList
                    .filter(function (filter) { return !(0, Utils_1.isEmptyOrSpaces)(filter._doc.color); })
                    .reverse();
                i = 0;
                _a.label = 3;
            case 3:
                if (!(i < _filterGroupList.length)) return [3, 6];
                _filter = _filterGroupList[i]._doc;
                return [4, _processFilterPerRecord(space, _record, _filter)];
            case 4:
                outcome = _a.sent();
                if (outcome) {
                    out.color = _filter.color;
                }
                _a.label = 5;
            case 5:
                i++;
                return [3, 3];
            case 6:
                response.push(out);
                _a.label = 7;
            case 7:
                j++;
                return [3, 2];
            case 8: return [2, response];
        }
    });
}); };
var _processFilterPerRecord = function (space_1, record_1, _a) { return __awaiter(void 0, [space_1, record_1, _a], void 0, function (space, record, _b) {
    var metadataDefinitionList, searchFields, outcome, isValidText, textRegexp;
    var text = _b.text, textList = _b.textList, searchPref = _b.searchPref;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4, MetadataDefinitionHelper.getMetadataDefinition(space)];
            case 1:
                metadataDefinitionList = _c.sent();
                searchFields = [];
                if (searchPref) {
                    Object.keys(searchPref).forEach(function (fieldName) {
                        if (searchPref[fieldName]) {
                            searchFields.push(fieldName);
                        }
                    });
                }
                outcome = false;
                isValidText = !(0, Utils_1.isEmptyOrSpaces)(text);
                textRegexp = new RegExp(text, "i");
                if (!isValidText && (searchFields.length !== 1 || textList.length === 0)) {
                    return [2, false];
                }
                if (isValidText &&
                    (searchFields.length === 0 || searchFields.includes("content"))) {
                    if (record.content.match(textRegexp)) {
                        return [2, true];
                    }
                }
                if (isValidText && searchFields.includes("name")) {
                    if (record.name.match(textRegexp)) {
                        return [2, true];
                    }
                }
                if (isValidText && searchFields.includes("labels")) {
                    if ((0, lodash_1.intersection)(record.labels, text.split(" ")).length > 0) {
                        return [2, true];
                    }
                }
                if (searchFields.length === 1 &&
                    searchFields.includes("labels") &&
                    textList.length > 0) {
                    if ((0, lodash_1.intersection)(record.labels, textList).length > 0) {
                        return [2, true];
                    }
                }
                metadataDefinitionList.forEach(function (item) {
                    if (isValidText && searchFields.includes(item._id.toString())) {
                        if (record[item._id.toString()].match(textRegexp)) {
                            return true;
                        }
                    }
                    if (searchFields.length === 1 &&
                        searchFields.includes(item._id.toString()) &&
                        textList.length > 0) {
                        if ((0, lodash_1.intersection)(record[item._id.toString()], textList).length > 0) {
                            return true;
                        }
                    }
                });
                return [2, false];
        }
    });
}); };
var getRecentlyCreatedNote = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.find().sort({ $natural: -1 }).limit(1)];
            case 1:
                res = _a.sent();
                if (res.length === 0) {
                    return [2, null];
                }
                return [2, res[0]];
        }
    });
}); };
exports.getRecentlyCreatedNote = getRecentlyCreatedNote;
var getNoteByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.find({ reference: reference })];
            case 1:
                res = _a.sent();
                if (res.length === 0) {
                    return [2, null];
                }
                return [2, res[0]];
        }
    });
}); };
exports.getNoteByReference = getNoteByReference;
var getNoteByBookref = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.find({ bookrefList: { $in: [bookref] } })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getNoteByBookref = getNoteByBookref;
var getNoteById = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.find({ _id: _id })];
            case 1:
                res = _a.sent();
                if (res.length > 0) {
                    return [2, res[0]];
                }
                return [2];
        }
    });
}); };
exports.getNoteById = getNoteById;
var deleteNotesByFolderIdList = function (space, folderIdList) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.deleteMany({ folderId: { $in: folderIdList } })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.deleteNotesByFolderIdList = deleteNotesByFolderIdList;
var getNotesByFolderIdList = function (space, folderIdList) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.find({ folderId: { $in: folderIdList } })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getNotesByFolderIdList = getNotesByFolderIdList;
var getNotesByReferenceList = function (space, refList) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.find({ reference: { $in: refList } })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getNotesByReferenceList = getNotesByReferenceList;
var deleteNote = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [2, { note: _id }];
        }
    });
}); };
exports.deleteNote = deleteNote;
var deleteNoteByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.deleteMany({ reference: reference })];
            case 1:
                _a.sent();
                return [4, NotelinkHelper.deleteNotelinkByReference(space, reference)];
            case 2:
                _a.sent();
                return [4, NotelinkAutoHelper.deleteNotelinkByReference(space, reference)];
            case 3:
                _a.sent();
                return [2, { note: reference }];
        }
    });
}); };
exports.deleteNoteByReference = deleteNoteByReference;
var deleteNoteByReferenceList = function (space, payload) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.deleteMany({ reference: { $in: payload } })];
            case 1:
                _a.sent();
                return [4, NotelinkHelper.deleteNotelinkByReferenceList(space, payload)];
            case 2:
                _a.sent();
                return [4, NotelinkAutoHelper.deleteNotelinkByReferenceList(space, payload)];
            case 3:
                _a.sent();
                return [2, { note: payload }];
        }
    });
}); };
exports.deleteNoteByReferenceList = deleteNoteByReferenceList;
var searchNoteByText = function (space, text) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.find({
                        $text: { $search: "\"".concat(text, "\""), $caseSensitive: false },
                    })];
            case 1:
                res = _a.sent();
                return [2, res];
        }
    });
}); };
exports.searchNoteByText = searchNoteByText;
var searchNote = function (space, text, textList, searchPref) { return __awaiter(void 0, void 0, void 0, function () {
    var _text, model, condition, res;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _text = (_a = text === null || text === void 0 ? void 0 : text.toLowerCase()) === null || _a === void 0 ? void 0 : _a.replace(/ +/g, " ");
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, _getSearchCondition(space, _text, textList, searchPref)];
            case 1:
                condition = _b.sent();
                return [4, model.find({ $or: condition }).sort({ createdAt: -1 })];
            case 2:
                res = _b.sent();
                return [2, res.map(function (item) {
                        return __assign(__assign({}, item._doc), { summary: (0, Utils_1.isEmptyOrSpaces)(item.summary)
                                ? item.autoGeneratedSummary
                                : item.summary });
                    })];
        }
    });
}); };
exports.searchNote = searchNote;
var _getSearchCondition = function (space, text, textList, searchPref) { return __awaiter(void 0, void 0, void 0, function () {
    var metadataDefinitionList, searchFields, condition, isValidText;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, MetadataDefinitionHelper.getMetadataDefinition(space)];
            case 1:
                metadataDefinitionList = _a.sent();
                searchFields = [];
                if (searchPref) {
                    Object.keys(searchPref).forEach(function (fieldName) {
                        if (searchPref[fieldName]) {
                            searchFields.push(fieldName);
                        }
                    });
                }
                condition = [];
                isValidText = !(0, Utils_1.isEmptyOrSpaces)(text);
                if (isValidText &&
                    (searchFields.length === 0 || searchFields.includes("content"))) {
                    condition.push({
                        content: new RegExp(text, "i"),
                    });
                }
                if (isValidText && searchFields.includes("name")) {
                    condition.push({
                        name: new RegExp(text, "i"),
                    });
                }
                if (isValidText && searchFields.includes("labels")) {
                    condition.push({
                        labels: {
                            $in: text.split(" "),
                        },
                    });
                }
                if (searchFields.length === 1 &&
                    searchFields.includes("labels") &&
                    textList.length > 0) {
                    condition.push({
                        labels: {
                            $in: textList,
                        },
                    });
                }
                metadataDefinitionList.forEach(function (item) {
                    var _a, _b;
                    if (isValidText && searchFields.includes(item._id.toString())) {
                        condition.push((_a = {},
                            _a[item._id.toString()] = new RegExp(text, "i"),
                            _a));
                    }
                    if (searchFields.length === 1 &&
                        searchFields.includes(item._id.toString()) &&
                        textList.length > 0) {
                        condition.push((_b = {},
                            _b[item._id.toString()] = {
                                $in: textList,
                            },
                            _b));
                    }
                });
                if (condition.length === 0) {
                    return [2, [{}]];
                }
                return [2, condition];
        }
    });
}); };
var getNotesByMetadataValue = function (space, metadataId, payload) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                res = [];
                if (!(metadataId === "label")) return [3, 2];
                return [4, model
                        .find({ labels: new RegExp(payload.value, "i") })
                        .sort({ createdAt: -1 })];
            case 1:
                res = _b.sent();
                return [3, 4];
            case 2: return [4, model
                    .find((_a = {}, _a[metadataId] = new RegExp(payload.value, "i"), _a))
                    .sort({ createdAt: -1 })];
            case 3:
                res = _b.sent();
                _b.label = 4;
            case 4: return [2, res.map(function (item) {
                    return __assign(__assign({}, item._doc), { summary: (0, Utils_1.isEmptyOrSpaces)(item.summary)
                            ? item.autoGeneratedSummary
                            : item.summary });
                })];
        }
    });
}); };
exports.getNotesByMetadataValue = getNotesByMetadataValue;
var browseNotes = function (space, payload) { return __awaiter(void 0, void 0, void 0, function () {
    var model, res, referenceNotes, referenceKeywords_1;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                res = [];
                if (!(payload.metadataId === "related")) return [3, 3];
                return [4, model.find({
                        reference: { $in: payload.metadataValue },
                    })];
            case 1:
                referenceNotes = _b.sent();
                referenceKeywords_1 = [];
                referenceNotes.forEach(function (item) {
                    referenceKeywords_1 = referenceKeywords_1.concat(item.keywords);
                });
                referenceKeywords_1 = (0, lodash_1.uniq)(referenceKeywords_1);
                return [4, model
                        .find({
                        keywords: { $in: referenceKeywords_1 },
                    })
                        .sort({ createdAt: -1 })];
            case 2:
                res = _b.sent();
                return [3, 5];
            case 3: return [4, model
                    .find((_a = {},
                    _a[payload.metadataId] = new RegExp(payload.metadataValue.toString(), "i"),
                    _a))
                    .sort({ createdAt: -1 })];
            case 4:
                res = _b.sent();
                _b.label = 5;
            case 5: return [2, res.map(function (item) {
                    return __assign(__assign({}, item._doc), { summary: (0, Utils_1.isEmptyOrSpaces)(item.summary)
                            ? item.autoGeneratedSummary
                            : item.summary });
                })];
        }
    });
}); };
exports.browseNotes = browseNotes;
var _ai_train = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                console.log("AI_API=", AI_API);
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios.get("".concat(AI_API, "/").concat(SIMILARITY_ALGORITHM, "/").concat(space, "/train"), {})];
            case 2:
                _a.sent();
                return [3, 4];
            case 3:
                err_1 = _a.sent();
                console.log(err_1);
                return [3, 4];
            case 4: return [2];
        }
    });
}); };
exports._ai_train = _ai_train;
var _ai_populate = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var err_2;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, axios.get("".concat(AI_API, "/").concat(SIMILARITY_ALGORITHM, "/").concat(space, "/populate"), {})];
            case 1:
                _a.sent();
                return [3, 3];
            case 2:
                err_2 = _a.sent();
                console.log(err_2);
                return [3, 3];
            case 3: return [2];
        }
    });
}); };
exports._ai_populate = _ai_populate;
var _ai_populate_for_note = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var err_3;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4, axios.get("".concat(AI_API, "/").concat(SIMILARITY_ALGORITHM, "/").concat(space, "/populate/").concat(reference), {})];
            case 1:
                _a.sent();
                return [3, 3];
            case 2:
                err_3 = _a.sent();
                console.log(err_3.data);
                return [3, 3];
            case 3: return [2];
        }
    });
}); };
var getLabels = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.distinct("labels")];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getLabels = getLabels;
var getKeywords = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteCollection, model_1.noteSchema);
                return [4, model.distinct("keywords")];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getKeywords = getKeywords;
var brainstormUsingAi = function (space, payload) { return __awaiter(void 0, void 0, void 0, function () {
    var gptResponse;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Gptutils.predict((0, prompt_1.getBrainstormPrompt)(payload.useBookMode, payload.text, payload.instructions, payload.bookName, payload.authorName))];
            case 1:
                gptResponse = _a.sent();
                console.log(gptResponse);
                return [2, gptResponse || payload.text];
        }
    });
}); };
exports.brainstormUsingAi = brainstormUsingAi;
var _enhanceNoteData = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var _data;
    return __generator(this, function (_a) {
        _data = (0, lodash_1.cloneDeep)(data);
        _data.contentText = _data.content.replace(/<[^>]*>/g, "");
        if ((0, Utils_1.isEmptyOrSpaces)(_data.summary)) {
            _data.summary = _data.contentText.substring(0, 250);
        }
        if ((0, Utils_1.isEmptyOrSpaces)(_data.name)) {
            _data.name = _data.contentText.substring(0, 250);
        }
        return [2, _data];
    });
}); };
var _enhanceNoteDataUsingAi = function (space, data) { return __awaiter(void 0, void 0, void 0, function () {
    var _data, gptResponseText, _a, _b, _c, _d, gptResponse;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0:
                _data = (0, lodash_1.cloneDeep)(data);
                _data.contentText = _data.content.replace(/<[^>]*>/g, "");
                if ((0, Utils_1.isEmptyOrSpaces)(_data.contentText) || _data.contentText.length <= 20) {
                    return [2, _enhanceNoteData(_data)];
                }
                _b = (_a = Gptutils).predict;
                _c = prompt_1.getAutoGeneratedAttributesPrompt;
                _d = [data.content];
                return [4, (0, exports.getLabels)(space)];
            case 1: return [4, _b.apply(_a, [_c.apply(void 0, _d.concat([_e.sent()]))])];
            case 2:
                gptResponseText = _e.sent();
                gptResponse = JSON.parse(gptResponseText);
                _data.name = gptResponse === null || gptResponse === void 0 ? void 0 : gptResponse.title;
                _data.summary = gptResponse === null || gptResponse === void 0 ? void 0 : gptResponse.summary;
                _data.labels = gptResponse === null || gptResponse === void 0 ? void 0 : gptResponse.labels;
                _data.primaryLabel = gptResponse === null || gptResponse === void 0 ? void 0 : gptResponse.primaryLabel;
                return [2, _data];
        }
    });
}); };
var _enhanceNoteDataWithMetadataFromRecentNote = function (space, data) { return __awaiter(void 0, void 0, void 0, function () {
    var recentNote, _a, _id, id, name, content, contentText, reference, labels, primaryLabel, summary, bookrefList, createdAt, updatedAt, __v, metadataFields, _data;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4, (0, exports.getRecentlyCreatedNote)(space)];
            case 1:
                recentNote = _b.sent();
                console.log(recentNote);
                if (!recentNote || !(recentNote === null || recentNote === void 0 ? void 0 : recentNote._doc)) {
                    return [2, data];
                }
                _a = recentNote._doc, _id = _a._id, id = _a.id, name = _a.name, content = _a.content, contentText = _a.contentText, reference = _a.reference, labels = _a.labels, primaryLabel = _a.primaryLabel, summary = _a.summary, bookrefList = _a.bookrefList, createdAt = _a.createdAt, updatedAt = _a.updatedAt, __v = _a.__v, metadataFields = __rest(_a, ["_id", "id", "name", "content", "contentText", "reference", "labels", "primaryLabel", "summary", "bookrefList", "createdAt", "updatedAt", "__v"]);
                _data = __assign(__assign({}, data), metadataFields);
                return [2, _data];
        }
    });
}); };


/***/ }),

/***/ "./src/modules/note/model.ts":
/*!***********************************!*\
  !*** ./src/modules/note/model.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.noteCollection = exports.noteSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var noteSchema = new Schema({
    name: { type: String },
    summary: { type: String },
    content: { type: String },
    contentText: { type: String },
    reference: { type: String },
    labels: { type: Array },
    primaryLabel: { type: String },
    type: { type: String },
    bookrefList: { type: Array },
}, { timestamps: true, strict: false, strictQuery: false });
exports.noteSchema = noteSchema;
noteSchema.index({ content: "text" });
var noteCollection = "note";
exports.noteCollection = noteCollection;


/***/ }),

/***/ "./src/modules/note/prompt.ts":
/*!************************************!*\
  !*** ./src/modules/note/prompt.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAutoGeneratedAttributesPrompt = exports.getBrainstormPrompt = void 0;
var Handlebars = __importStar(__webpack_require__(/*! handlebars */ "handlebars"));
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var _MODEL_NAME_GPT3 = "gpt-3.5-turbo";
var _MODEL_NAME_GPT4 = "gpt-4o";
var _MODEL_NAME = process.env.CHATGPT_MODEL_NAME || "gpt-4o-mini";
;
var getBrainstormPrompt = function (useBookMode, text, instructions, bookName, authorName) {
    var brainstormPrompt = useBookMode
        ? (0, lodash_1.cloneDeep)(_BRAINSTORM_WITH_BOOK_PROMPT)
        : (0, lodash_1.cloneDeep)(_BRAINSTORM_PROMPT);
    brainstormPrompt.messages[brainstormPrompt.messages.length - 1].content =
        Handlebars.compile(brainstormPrompt.messages[brainstormPrompt.messages.length - 1].content)({
            baseText: text,
            instructions: instructions,
            bookName: bookName,
            authorName: authorName,
            modelName: _MODEL_NAME,
        });
    console.log(brainstormPrompt);
    return brainstormPrompt;
};
exports.getBrainstormPrompt = getBrainstormPrompt;
var _PROMPT_SECTION_INTRODUCTION = {
    role: "system",
    content: "You are an expert in transforming freehanded base texts into concise and well-structured content. Your task is to modify the base text into clear and concise content according to the given instructions. Do not include any common heading or title in your response.",
};
var _PROMPT_SECTION_INTRODUCTION_WITH_BOOK = {
    role: "system",
    content: "You are an expert in transforming freehanded base texts into concise and well-structured content. Your task is to modify the base text into clear and concise content according to the given instructions, using the provided book details. Do not mention the book name or author name in the generated content.",
};
var _PROMPT_SECTION_HTML_ENCODING = {
    role: "system",
    content: "Always use raw HTML tags for formatting. For example, use <b> for bold, <i> for italic, etc. Do not use markdown syntax like ** for bold or * for italic.",
};
var _PROMPT_SECTION_HTML_SUPPORTED_FORMATS = {
    role: "system",
    content: "Limit HTML to basic formatting like bold, italic, underline, bullet lists, numbered lists, h4, and h5. Do not include any additional HTML document structure or prefixes like 'html\\n'.",
};
var _PROMPT_SECTION_INPUT_QUALITY_CHECK = {
    role: "system",
    content: "Carefully evaluate the instructions provided, including any numbers or details, to ensure they are relevant and meaningful for transforming the base text. If the instructions are unclear, irrelevant, or you cannot reliably generate content based on them, prefix your response with 'MORE_INFO_NEEDED' and ask for clarification.",
};
var _PROMPT_SECTION_BOOK_REFERENCE = {
    role: "system",
    content: "If the book name and author name are provided and matching books are found, proceed with the most relevant book without asking for additional details. If the book name is provided but the author name is missing and multiple books with the same name exist, prefix your response with 'BOOK_NOT_FOUND' and specify that the author name is needed. If the book name and/or author name cannot be found, prefix your response with 'BOOK_NOT_FOUND' and indicate that the book details could not be verified.",
};
var _PROMPT_SECTION_INPUT_MEANINGNESS_CHECK = {
    role: "system",
    content: "Do not return the base text unchanged. If the instructions do not allow for a meaningful transformation, indicate that by prefacing your response with 'MORE_INFO_NEEDED'.",
};
var _PROMPT_SECTION_FORM_WITHOUT_BOOK = {
    role: "user",
    content: "Base Text: {{baseText}}\nInstructions: {{instructions}}",
};
var _PROMPT_SECTION_FORM_WITH_BOOK = {
    role: "user",
    content: "Base Text: {{baseText}}\nInstructions: {{instructions}}\nBook: {{bookName}}, Author: {{authorName}}",
};
var _BRAINSTORM_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        _PROMPT_SECTION_INTRODUCTION,
        _PROMPT_SECTION_HTML_ENCODING,
        _PROMPT_SECTION_HTML_SUPPORTED_FORMATS,
        _PROMPT_SECTION_INPUT_QUALITY_CHECK,
        _PROMPT_SECTION_INPUT_MEANINGNESS_CHECK,
        _PROMPT_SECTION_FORM_WITHOUT_BOOK,
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var _BRAINSTORM_WITH_BOOK_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        _PROMPT_SECTION_INTRODUCTION_WITH_BOOK,
        _PROMPT_SECTION_HTML_ENCODING,
        _PROMPT_SECTION_HTML_SUPPORTED_FORMATS,
        _PROMPT_SECTION_INPUT_QUALITY_CHECK,
        _PROMPT_SECTION_BOOK_REFERENCE,
        _PROMPT_SECTION_INPUT_MEANINGNESS_CHECK,
        _PROMPT_SECTION_FORM_WITH_BOOK,
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};
var getAutoGeneratedAttributesPrompt = function (text, labels) {
    var prompt = (0, lodash_1.cloneDeep)(_AUTO_GENERATED_ATTRUBUTES_PROMPT);
    prompt.messages[prompt.messages.length - 1].content = Handlebars.compile(prompt.messages[prompt.messages.length - 1].content)({
        text: text,
        labels: labels,
        modelName: _MODEL_NAME,
    });
    return prompt;
};
exports.getAutoGeneratedAttributesPrompt = getAutoGeneratedAttributesPrompt;
var _AUTO_GENERATED_ATTRUBUTES_PROMPT = {
    model: _MODEL_NAME,
    messages: [
        {
            role: "system",
            content: "You are an AI that generates optimized content based on user inputs. Your task is to create a short title and summary for an essay provided by the user. The title should not contain a colon character (:). Additionally, you will evaluate a set of labels and select those relevant to the essay. If none of the provided labels are relevant, you will generate 2-3 new labels that better suit the essay. All labels, including the primary label, should be in lowercase, and the primary label must be selected from the relevant labels. The output should be a JSON object with the fields: title, summary, labels, and primaryLabel.",
        },
        {
            role: "system",
            content: "Please generate a short title and summary for the essay. Ensure the title does not contain a colon character (:). Choose relevant labels from the provided set, or generate new ones if necessary, and select a primary label. The output should be in a JSON object with the fields: title, summary, labels, and primaryLabel.",
        },
        {
            role: "user",
            content: "Essay Text: {{text}}\nLabels: {{labels}}",
        },
    ],
    temperature: 1,
    max_tokens: 4096,
    top_p: 1,
    frequency_penalty: 0,
    presence_penalty: 0,
};


/***/ }),

/***/ "./src/modules/note/route.ts":
/*!***********************************!*\
  !*** ./src/modules/note/route.ts ***!
  \***********************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/note/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.put("/note/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.updateNote));
    router.post("/note/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.createNote));
    router.post("/note/:space/search", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.searchNote));
    router.post("/note/:space/metadata/:metadataId", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getNotesByMetadataValue));
    router.post("/note/:space/browse", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.browseNotes));
    router.get("/note/:space/dictionary", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getNoteDictionary));
    router.get("/note/:space/recently-created", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getRecentlyCreatedNote));
    router.post("/note/:space/brainstorm", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.brainstormUsingAi));
    router.get("/note/:space/id/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getNoteById));
    router.get("/note/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getNoteByReference));
    router.delete("/note/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteNote));
    router.post("/note/:space/delete/byreference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteNoteByReferenceList));
    router.delete("/note/:space/reference/:reference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteNoteByReference));
};


/***/ }),

/***/ "./src/modules/note/service.ts":
/*!*************************************!*\
  !*** ./src/modules/note/service.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.brainstormUsingAi = exports.deleteNoteByReferenceList = exports.deleteNoteByReference = exports.deleteNote = exports.browseNotes = exports.getNotesByMetadataValue = exports.searchNote = exports.getNoteByReference = exports.getNoteById = exports.getRecentlyCreatedNote = exports.getNoteDictionary = exports.getNote = exports.createNote = exports.updateNote = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/note/helper.ts"));
var updateNote = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, note;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateNote(req.params.space, req.query.reload, req.body, userId)];
            case 1:
                note = _a.sent();
                res.status(200);
                res.send(note);
                res.end();
                return [2];
        }
    });
}); };
exports.updateNote = updateNote;
var createNote = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, note;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.createNote(req.params.space, req.query.reload, req.body, userId)];
            case 1:
                note = _a.sent();
                res.status(200);
                res.send(note);
                res.end();
                return [2];
        }
    });
}); };
exports.createNote = createNote;
var getNote = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, noteList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getNote(req.params.space)];
            case 1:
                noteList = _a.sent();
                res.status(200);
                res.send(noteList);
                res.end();
                return [2];
        }
    });
}); };
exports.getNote = getNote;
var getNoteDictionary = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, noteList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getNoteDictionary(req.params.space)];
            case 1:
                noteList = _a.sent();
                res.status(200);
                res.send(noteList);
                res.end();
                return [2];
        }
    });
}); };
exports.getNoteDictionary = getNoteDictionary;
var getRecentlyCreatedNote = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, noteList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getRecentlyCreatedNote(req.params.space)];
            case 1:
                noteList = _a.sent();
                res.status(200);
                res.send(noteList);
                res.end();
                return [2];
        }
    });
}); };
exports.getRecentlyCreatedNote = getRecentlyCreatedNote;
var getNoteById = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, note;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getNoteById(req.params.space, req.params.id)];
            case 1:
                note = _a.sent();
                res.status(200);
                res.send(note);
                res.end();
                return [2];
        }
    });
}); };
exports.getNoteById = getNoteById;
var getNoteByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, note;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getNoteByReference(req.params.space, req.params.reference)];
            case 1:
                note = _a.sent();
                res.status(200);
                res.send(note);
                res.end();
                return [2];
        }
    });
}); };
exports.getNoteByReference = getNoteByReference;
var searchNote = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, note;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.searchNote(req.params.space, req.body.text, req.body.textList, req.body.searchPref)];
            case 1:
                note = _a.sent();
                res.status(200);
                res.send(note);
                res.end();
                return [2];
        }
    });
}); };
exports.searchNote = searchNote;
var getNotesByMetadataValue = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, note;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getNotesByMetadataValue(req.params.space, req.params.metadataId, req.body)];
            case 1:
                note = _a.sent();
                res.status(200);
                res.send(note);
                res.end();
                return [2];
        }
    });
}); };
exports.getNotesByMetadataValue = getNotesByMetadataValue;
var browseNotes = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, note;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.browseNotes(req.params.space, req.body)];
            case 1:
                note = _a.sent();
                res.status(200);
                res.send(note);
                res.end();
                return [2];
        }
    });
}); };
exports.browseNotes = browseNotes;
var deleteNote = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteNote(req.params.space, req.params.id)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteNote = deleteNote;
var deleteNoteByReference = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteNoteByReference(req.params.space, req.params.reference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteNoteByReference = deleteNoteByReference;
var deleteNoteByReferenceList = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteNoteByReferenceList(req.params.space, req.body)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteNoteByReferenceList = deleteNoteByReferenceList;
var brainstormUsingAi = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, text;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.brainstormUsingAi(req.params.space, req.body)];
            case 1:
                text = _a.sent();
                res.status(200);
                res.send({ text: text });
                res.end();
                return [2];
        }
    });
}); };
exports.brainstormUsingAi = brainstormUsingAi;


/***/ }),

/***/ "./src/modules/note/tag/helper.ts":
/*!****************************************!*\
  !*** ./src/modules/note/tag/helper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addTagsForNoteRef = exports.deleteByNoteRef = exports.getTag = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/note/tag/model.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var getTag = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteTagCollection, model_1.noteTagSchema);
                return [4, model.find()];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getTag = getTag;
var deleteByNoteRef = function (space, noteRef) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteTagCollection, model_1.noteTagSchema);
                return [4, model.deleteMany({ noteRef: noteRef })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.deleteByNoteRef = deleteByNoteRef;
var addTagsForNoteRef = function (space, noteRef, tags) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.noteTagCollection, model_1.noteTagSchema);
                data = [];
                tags.forEach(function (name) {
                    data.push({
                        name: name.replace("#", ""),
                        noteRef: noteRef,
                    });
                });
                return [4, model.insertMany(data)];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.addTagsForNoteRef = addTagsForNoteRef;


/***/ }),

/***/ "./src/modules/note/tag/model.ts":
/*!***************************************!*\
  !*** ./src/modules/note/tag/model.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.noteTagCollection = exports.noteTagSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var noteTagSchema = new Schema({
    name: { type: String },
    noteRef: { type: String },
}, { timestamps: true });
exports.noteTagSchema = noteTagSchema;
var noteTagCollection = "note.tag";
exports.noteTagCollection = noteTagCollection;


/***/ }),

/***/ "./src/modules/note/tag/route.ts":
/*!***************************************!*\
  !*** ./src/modules/note/tag/route.ts ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/note/tag/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.get("/note/tag/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getTag));
};


/***/ }),

/***/ "./src/modules/note/tag/service.ts":
/*!*****************************************!*\
  !*** ./src/modules/note/tag/service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTag = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/note/tag/helper.ts"));
var selfRealm = 100;
var getTag = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, tagList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getTag(req.params.space)];
            case 1:
                tagList = _a.sent();
                res.status(200);
                res.send(tagList);
                res.end();
                return [2];
        }
    });
}); };
exports.getTag = getTag;


/***/ }),

/***/ "./src/modules/notelink/auto/helper.ts":
/*!*********************************************!*\
  !*** ./src/modules/notelink/auto/helper.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteNotelinkByReferenceList = exports.deleteNotelinkByReference = exports.getNotelinkAutoByNoteRef = exports.getNotelinkAuto = void 0;
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/notelink/auto/model.ts");
var getCollection = (__webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var getNotelinkAuto = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkAutoCollection, model_1.notelinkAutoSchema);
                return [4, model.find()];
            case 1:
                data = _a.sent();
                return [2, data];
        }
    });
}); };
exports.getNotelinkAuto = getNotelinkAuto;
var getNotelinkAutoByNoteRef = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkAutoCollection, model_1.notelinkAutoSchema);
                return [4, model.find({
                        $or: [{ sourceNoteRef: reference }, { linkedNoteRef: reference }],
                    })];
            case 1:
                data = _a.sent();
                return [2, data];
        }
    });
}); };
exports.getNotelinkAutoByNoteRef = getNotelinkAutoByNoteRef;
var deleteNotelinkByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkAutoCollection, model_1.notelinkAutoSchema);
                return [4, model.deleteMany({
                        $or: [{ sourceNoteRef: reference }, { linkedNoteRef: reference }],
                    })];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); };
exports.deleteNotelinkByReference = deleteNotelinkByReference;
var deleteNotelinkByReferenceList = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkAutoCollection, model_1.notelinkAutoSchema);
                return [4, model.deleteMany({
                        $or: [
                            { sourceNoteRef: { $in: reference } },
                            { linkedNoteRef: { $in: reference } },
                        ],
                    })];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); };
exports.deleteNotelinkByReferenceList = deleteNotelinkByReferenceList;


/***/ }),

/***/ "./src/modules/notelink/auto/model.ts":
/*!********************************************!*\
  !*** ./src/modules/notelink/auto/model.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notelinkAutoCollection = exports.notelinkAutoSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var notelinkAutoSchema = new Schema({
    sourceNoteRef: { type: String },
    linkedNoteRef: { type: String },
    count: { type: Number },
}, { timestamps: true });
exports.notelinkAutoSchema = notelinkAutoSchema;
var notelinkAutoCollection = "notelink.auto";
exports.notelinkAutoCollection = notelinkAutoCollection;


/***/ }),

/***/ "./src/modules/notelink/auto/route.ts":
/*!********************************************!*\
  !*** ./src/modules/notelink/auto/route.ts ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/notelink/auto/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.get("/notelink-auto/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getNotelinkAuto));
};


/***/ }),

/***/ "./src/modules/notelink/auto/service.ts":
/*!**********************************************!*\
  !*** ./src/modules/notelink/auto/service.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNotelinkAuto = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/notelink/auto/helper.ts"));
var getNotelinkAuto = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, notelinkAutoList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getNotelinkAuto(req.params.space)];
            case 1:
                notelinkAutoList = _a.sent();
                res.status(200);
                res.send(notelinkAutoList);
                res.end();
                return [2];
        }
    });
}); };
exports.getNotelinkAuto = getNotelinkAuto;


/***/ }),

/***/ "./src/modules/notelink/helper.ts":
/*!****************************************!*\
  !*** ./src/modules/notelink/helper.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteNotelinkByReferenceList = exports.deleteNotelinkByReference = exports.deleteNotelink = exports.saveNotelink = exports.addLinksForSourceNoteRef = exports.deleteBySourceNoteRef = exports.getBacklinksByReference = exports.getNotelinkOld = exports.getNotelinkByReference = exports.getNotelink = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/notelink/model.ts");
var getCollection = (__webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var NoteHelper = __importStar(__webpack_require__(/*! ../note/helper */ "./src/modules/note/helper.ts"));
var getNotelink = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.find()];
            case 1:
                data = _a.sent();
                return [2, data];
        }
    });
}); };
exports.getNotelink = getNotelink;
var getNotelinkByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.find({
                        $or: [{ sourceNoteRef: reference }, { linkedNoteRef: reference }],
                    })];
            case 1:
                data = _a.sent();
                return [2, data];
        }
    });
}); };
exports.getNotelinkByReference = getNotelinkByReference;
var getNotelinkOld = function (space, noteref, depth) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data, _nearestLinks;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.find()];
            case 1:
                data = _a.sent();
                if (!noteref || !depth) {
                    return [2, data];
                }
                _nearestLinks = _getNearestLinks(data, [noteref], parseInt(depth));
                return [2, _nearestLinks];
        }
    });
}); };
exports.getNotelinkOld = getNotelinkOld;
var _getNearestLinks = function (data, noteref, depth) {
    var nearestLinks = data.filter(function (item) {
        return noteref.includes(item.sourceNoteRef) ||
            noteref.includes(item.linkedNoteRef);
    });
    if (depth === 1) {
        return nearestLinks;
    }
    var nextNoteRef = [];
    nearestLinks.forEach(function (item) {
        nextNoteRef.push(item.sourceNoteRef);
        nextNoteRef.push(item.linkedNoteRef);
    });
    return __spreadArray(__spreadArray([], nearestLinks, true), _getNearestLinks(data, (0, lodash_1.uniq)(nextNoteRef), depth - 1), true);
};
var getBacklinksByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model, backlinks, linkedNoteRefList, noteList, noteMap, backlinkDetailList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.find({ linkedNoteRef: reference })];
            case 1:
                backlinks = _a.sent();
                linkedNoteRefList = [];
                if (backlinks.length === 0) {
                    return [2, []];
                }
                backlinks.forEach(function (item) {
                    linkedNoteRefList.push(item.sourceNoteRef);
                });
                return [4, NoteHelper.getNotesByReferenceList(space, linkedNoteRefList)];
            case 2:
                noteList = _a.sent();
                noteMap = {};
                noteList.forEach(function (item) {
                    noteMap[item.reference] = item;
                });
                backlinkDetailList = [];
                backlinks.forEach(function (item) {
                    if (noteMap[item.sourceNoteRef]) {
                        backlinkDetailList.push(__assign(__assign({}, item._doc), { sourceNote: noteMap[item.sourceNoteRef] }));
                    }
                });
                return [2, backlinkDetailList];
        }
    });
}); };
exports.getBacklinksByReference = getBacklinksByReference;
var deleteBySourceNoteRef = function (space, sourceNoteRef) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.deleteMany({ sourceNoteRef: sourceNoteRef })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.deleteBySourceNoteRef = deleteBySourceNoteRef;
var addLinksForSourceNoteRef = function (space, sourceNoteRef, linkedNoteRefList) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                data = [];
                linkedNoteRefList.forEach(function (linkedNoteRef) {
                    data.push({
                        sourceNoteRef: sourceNoteRef,
                        linkedNoteRef: linkedNoteRef,
                    });
                });
                return [4, model.insertMany(data)];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.addLinksForSourceNoteRef = addLinksForSourceNoteRef;
var saveNotelink = function (space, sourceNoteRef, linkedNoteRef) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.create({
                        sourceNoteRef: sourceNoteRef,
                        linkedNoteRef: linkedNoteRef,
                    })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.saveNotelink = saveNotelink;
var deleteNotelink = function (space, sourceNoteRef, linkedNoteRef) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.deleteMany({
                        sourceNoteRef: sourceNoteRef,
                        linkedNoteRef: linkedNoteRef,
                    })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.deleteNotelink = deleteNotelink;
var deleteNotelinkByReference = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.deleteMany({
                        $or: [{ sourceNoteRef: reference }, { linkedNoteRef: reference }],
                    })];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); };
exports.deleteNotelinkByReference = deleteNotelinkByReference;
var deleteNotelinkByReferenceList = function (space, reference) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.notelinkCollection, model_1.notelinkSchema);
                return [4, model.deleteMany({
                        $or: [
                            { sourceNoteRef: { $in: reference } },
                            { linkedNoteRef: { $in: reference } },
                        ],
                    })];
            case 1:
                _a.sent();
                return [2];
        }
    });
}); };
exports.deleteNotelinkByReferenceList = deleteNotelinkByReferenceList;


/***/ }),

/***/ "./src/modules/notelink/model.ts":
/*!***************************************!*\
  !*** ./src/modules/notelink/model.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notelinkCollection = exports.notelinkSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var notelinkSchema = new Schema({
    sourceNoteRef: { type: String },
    linkedNoteRef: { type: String },
}, { timestamps: true });
exports.notelinkSchema = notelinkSchema;
var notelinkCollection = "notelink";
exports.notelinkCollection = notelinkCollection;


/***/ }),

/***/ "./src/modules/notelink/route.ts":
/*!***************************************!*\
  !*** ./src/modules/notelink/route.ts ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/notelink/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.get("/notelink/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getNotelink));
    router.post("/notelink/:space/:sourceReference/:linkedReference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.saveNotelink));
    router.delete("/notelink/:space/:sourceReference/:linkedReference", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteNotelink));
};


/***/ }),

/***/ "./src/modules/notelink/service.ts":
/*!*****************************************!*\
  !*** ./src/modules/notelink/service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteNotelink = exports.saveNotelink = exports.getNotelink = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/notelink/helper.ts"));
var selfRealm = 100;
var getNotelink = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, notelinkList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getNotelink(req.params.space)];
            case 1:
                notelinkList = _a.sent();
                res.status(200);
                res.send(notelinkList);
                res.end();
                return [2];
        }
    });
}); };
exports.getNotelink = getNotelink;
var saveNotelink = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.saveNotelink(req.params.space, req.params.sourceReference, req.params.linkedReference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.saveNotelink = saveNotelink;
var deleteNotelink = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, outcome;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.deleteNotelink(req.params.space, req.params.sourceReference, req.params.linkedReference)];
            case 1:
                outcome = _a.sent();
                res.status(200);
                res.send(outcome);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteNotelink = deleteNotelink;


/***/ }),

/***/ "./src/modules/permission/helper.ts":
/*!******************************************!*\
  !*** ./src/modules/permission/helper.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addRole = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var ONEAUTH_API_KEY = process.env.ONEAUTH_API_KEY || "1d9524a6-30df-4b3c-9402-503f4011896c";
var addRole = function (email, companyId) { return __awaiter(void 0, void 0, void 0, function () {
    var response, err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                response = null;
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios.post("".concat(ONEAUTH_API, "/212/admin/permission"), {
                        action: "ADD",
                        userEmail: email,
                        roleName: "COMPANY_ADMIN",
                        scope: companyId
                    }, {
                        headers: {
                            authorization: ONEAUTH_API_KEY,
                        },
                    })];
            case 2:
                response = _a.sent();
                return [3, 4];
            case 3:
                err_1 = _a.sent();
                return [2, {}];
            case 4:
                if (response.status === 200) {
                    return [2, response.data || null];
                }
                return [2, null];
        }
    });
}); };
exports.addRole = addRole;


/***/ }),

/***/ "./src/modules/report/book_helper.ts":
/*!*******************************************!*\
  !*** ./src/modules/report/book_helper.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateReportForBook = void 0;
var BookHelper = __importStar(__webpack_require__(/*! ../book/helper */ "./src/modules/book/helper.ts"));
var BookSectionHelper = __importStar(__webpack_require__(/*! ../book/section/helper */ "./src/modules/book/section/helper.ts"));
var BookSectiondetailHelper = __importStar(__webpack_require__(/*! ../book/sectiondetail/helper */ "./src/modules/book/sectiondetail/helper.ts"));
var DateUtils_1 = __webpack_require__(/*! ../../lib/DateUtils */ "./src/lib/DateUtils.ts");
var SECTION_TYPE_MAP = {
    summary: "",
    themes: "Key themes and ideas",
    alternate_takes: "Alternate perspectives",
    purpose: "Thematic Significance",
};
var ejs = __webpack_require__(/*! ejs */ "ejs");
var jszip = __webpack_require__(/*! jszip */ "jszip");
var _get_template_path = function (name) {
    return process.cwd() + name;
};
var _get_zip_file = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var zip;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                zip = new jszip();
                zip.file("index.html", data);
                return [4, zip.generateAsync({ type: "base64", compression: "DEFLATE" })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
var generateReportForBook = function (space, bookref) { return __awaiter(void 0, void 0, void 0, function () {
    var book, bookSections, bookSectionMap, bookSectiondetailMap, i, bookSectiondetails, data, html;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, BookHelper.getBookByReference(space, bookref)];
            case 1:
                book = _a.sent();
                if (!book) {
                    return [2, "Book not found"];
                }
                return [4, BookSectionHelper.getBookSectionsByBookReference(space, bookref)];
            case 2:
                bookSections = _a.sent();
                bookSectionMap = {};
                bookSectiondetailMap = {};
                i = 0;
                _a.label = 3;
            case 3:
                if (!(i < bookSections.length)) return [3, 6];
                bookSectionMap[bookSections[i].reference] = bookSections[i];
                return [4, BookSectiondetailHelper.getDetailsByBookReference(space, bookref, bookSections[i].reference)];
            case 4:
                bookSectiondetails = _a.sent();
                bookSectiondetailMap[bookSections[i].reference] = bookSectiondetails.map(function (item) { return (__assign(__assign({}, item._doc), { type: SECTION_TYPE_MAP[item._doc.type] })); });
                console.log(bookSectiondetails.map(function (item) { return (__assign(__assign({}, item), { type: SECTION_TYPE_MAP[item.type] })); }));
                _a.label = 5;
            case 5:
                i++;
                return [3, 3];
            case 6:
                data = {
                    book: book,
                    bookSections: bookSections,
                    bookSectiondetailMap: bookSectiondetailMap,
                    createdAt: (0, DateUtils_1.formatDateText)(book.createdAt, DateUtils_1.FORMAT_FULL_DATE),
                };
                return [4, ejs.renderFile(_get_template_path("/src/templates/book/template.ejs"), data)];
            case 7:
                html = _a.sent();
                return [2, _get_zip_file(html)];
        }
    });
}); };
exports.generateReportForBook = generateReportForBook;
var _generateReportForSectiondetail = function (booksectiondetail) { return __awaiter(void 0, void 0, void 0, function () {
    var data, html;
    return __generator(this, function (_a) {
        data = {
            title: booksectiondetail.name,
            summary: booksectiondetail.summary,
            content: booksectiondetail.content,
            keywords: booksectiondetail.keywords,
            createdAt: (0, DateUtils_1.formatDateText)(booksectiondetail.createdAt, DateUtils_1.FORMAT_FULL_DATE),
        };
        html = ejs.renderFile(_get_template_path("/src/templates/book/partials/template_sectiondetail.ejs"), data);
        return [2, html];
    });
}); };


/***/ }),

/***/ "./src/modules/report/note_helper.ts":
/*!*******************************************!*\
  !*** ./src/modules/report/note_helper.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateReportForNoteRef = exports.generateReportForNote = exports.generateReport = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var lodash_1 = __webpack_require__(/*! lodash */ "lodash");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var MetadataDefinitionHelper = __importStar(__webpack_require__(/*! ../metadata/definition/helper */ "./src/modules/metadata/definition/helper.ts"));
var NoteLinkHelper = __importStar(__webpack_require__(/*! ../notelink/helper */ "./src/modules/notelink/helper.ts"));
var NoteLinkAutoHelper = __importStar(__webpack_require__(/*! ../notelink/auto/helper */ "./src/modules/notelink/auto/helper.ts"));
var NoteHelper = __importStar(__webpack_require__(/*! ../note/helper */ "./src/modules/note/helper.ts"));
var Utils_1 = __webpack_require__(/*! ../../lib/Utils */ "./src/lib/Utils.ts");
var DateUtils_1 = __webpack_require__(/*! ../../lib/DateUtils */ "./src/lib/DateUtils.ts");
var ejs = __webpack_require__(/*! ejs */ "ejs");
var jszip = __webpack_require__(/*! jszip */ "jszip");
var _get_template_path = function (name) {
    return process.cwd() + name;
};
var _get_zip_file = function (data) { return __awaiter(void 0, void 0, void 0, function () {
    var zip;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                zip = new jszip();
                zip.file("index.html", data);
                return [4, zip.generateAsync({ type: "base64", compression: "DEFLATE" })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
var generateReport = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var noteList, metadataDefinitionList, html, i, _a, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4, NoteHelper.getNote(space)];
            case 1:
                noteList = _c.sent();
                return [4, MetadataDefinitionHelper.getMetadataDefinition(space)];
            case 2:
                metadataDefinitionList = _c.sent();
                html = "";
                i = 0;
                _c.label = 3;
            case 3:
                if (!(i < noteList.length)) return [3, 7];
                _a = html;
                return [4, (0, exports.generateReportForNote)(space, noteList[i].reference, metadataDefinitionList)];
            case 4:
                html = _a + _c.sent();
                _b = html;
                return [4, ejs.renderFile(_get_template_path("/src/templates/note/partials/template_pagebreak.ejs"), {})];
            case 5:
                html = _b + _c.sent();
                _c.label = 6;
            case 6:
                i++;
                return [3, 3];
            case 7: return [2, _get_zip_file(html)];
        }
    });
}); };
exports.generateReport = generateReport;
var generateReportForNote = function (space, reference, metadataDefinitionList) { return __awaiter(void 0, void 0, void 0, function () {
    var note, _metadataDefinitionList, data, html, notelinks, notelinksAuto, _a, i, linkedNoteRef, refNote, _b, i, linkedNoteRef, refNote;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4, NoteHelper.getNoteByReference(space, reference)];
            case 1:
                note = _c.sent();
                if (!note) {
                    return [2, "Note not found"];
                }
                _metadataDefinitionList = metadataDefinitionList;
                if (!!_metadataDefinitionList) return [3, 3];
                return [4, MetadataDefinitionHelper.getMetadataDefinition(space)];
            case 2:
                _metadataDefinitionList =
                    _c.sent();
                _c.label = 3;
            case 3:
                data = {
                    title: note.name,
                    summary: note.summary,
                    content: note.content.replace(/<p><\/p>/gi, ""),
                    keywords: note.keywords,
                    labels: [],
                    createdAt: (0, DateUtils_1.formatDateText)(note.createdAt, DateUtils_1.FORMAT_FULL_DATE),
                };
                if (!(0, Utils_1.isEmptyOrSpaces)(note.primaryLabel)) {
                    data.labels = __spreadArray([
                        note.primaryLabel
                    ], note.labels.filter(function (item) { return item !== note.primaryLabel; }), true);
                }
                return [4, ejs.renderFile(_get_template_path("/src/templates/note/template_note.ejs"), data)];
            case 4:
                html = _c.sent();
                return [4, NoteLinkHelper.getNotelinkByReference(space, reference)];
            case 5:
                notelinks = _c.sent();
                return [4, NoteLinkAutoHelper.getNotelinkAutoByNoteRef(space, reference)];
            case 6:
                notelinksAuto = _c.sent();
                if (!(notelinks.length > 0)) return [3, 8];
                _a = html;
                return [4, ejs.renderFile(_get_template_path("/src/templates/note/partials/template_section_title.ejs"), { title: "References" })];
            case 7:
                html = _a + _c.sent();
                _c.label = 8;
            case 8:
                i = 0;
                _c.label = 9;
            case 9:
                if (!(i < notelinks.length)) return [3, 12];
                linkedNoteRef = notelinks[i].linkedNoteRef;
                if (linkedNoteRef === reference) {
                    linkedNoteRef = notelinks[i].sourceNoteRef;
                }
                return [4, (0, exports.generateReportForNoteRef)(space, linkedNoteRef, null, _metadataDefinitionList)];
            case 10:
                refNote = _c.sent();
                html += refNote;
                _c.label = 11;
            case 11:
                i++;
                return [3, 9];
            case 12:
                if (!(notelinksAuto.length > 0)) return [3, 14];
                _b = html;
                return [4, ejs.renderFile(_get_template_path("/src/templates/note/partials/template_section_title.ejs"), { title: "Auto linked References" })];
            case 13:
                html = _b + _c.sent();
                _c.label = 14;
            case 14:
                i = 0;
                _c.label = 15;
            case 15:
                if (!(i < notelinksAuto.length)) return [3, 18];
                linkedNoteRef = notelinksAuto[i].linkedNoteRef;
                if (linkedNoteRef === reference) {
                    linkedNoteRef = notelinksAuto[i].sourceNoteRef;
                }
                return [4, (0, exports.generateReportForNoteRef)(space, linkedNoteRef, note._doc.keywords, _metadataDefinitionList)];
            case 16:
                refNote = _c.sent();
                html += refNote;
                _c.label = 17;
            case 17:
                i++;
                return [3, 15];
            case 18: return [2, _get_zip_file(html)];
        }
    });
}); };
exports.generateReportForNote = generateReportForNote;
var generateReportForNoteRef = function (space, reference, sourceKeywords, metadataDefinitionList) { return __awaiter(void 0, void 0, void 0, function () {
    var note, data, metadata, html;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, NoteHelper.getNoteByReference(space, reference)];
            case 1:
                note = _a.sent();
                data = {
                    title: note.name,
                    summary: note.summary,
                    content: note.content,
                    keywords: note.keywords,
                    createdAt: (0, DateUtils_1.formatDateText)(note.createdAt, DateUtils_1.FORMAT_FULL_DATE),
                };
                metadata = [];
                metadataDefinitionList.forEach(function (item) {
                    metadata.push({
                        name: "".concat(item._doc.group, " | ").concat(item._doc.name),
                        value: note._doc[item._doc._id],
                    });
                });
                data.metadata = metadata;
                if (!(0, Utils_1.isEmptyOrSpaces)(note.primaryLabel)) {
                    data.labels = __spreadArray([
                        note.primaryLabel
                    ], note.labels.filter(function (item) { return item !== note.primaryLabel; }), true);
                }
                data.keywords = (0, lodash_1.intersection)(sourceKeywords, note._doc.keywords);
                html = ejs.renderFile(_get_template_path("/src/templates/note/partials/template_noteref.ejs"), data);
                return [2, html];
        }
    });
}); };
exports.generateReportForNoteRef = generateReportForNoteRef;


/***/ }),

/***/ "./src/modules/report/route.ts":
/*!*************************************!*\
  !*** ./src/modules/report/route.ts ***!
  \*************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/report/service.ts");
module.exports = function (router) {
    router.get("/report/:space/:noteRef", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.generateReportForNote));
    router.get("/report/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.generateReport));
    router.get("/report/book/:space/:bookref", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.generateReportForBook));
};


/***/ }),

/***/ "./src/modules/report/service.ts":
/*!***************************************!*\
  !*** ./src/modules/report/service.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateReportForBook = exports.generateReport = exports.generateReportForNote = void 0;
var NoteHelper = __importStar(__webpack_require__(/*! ./note_helper */ "./src/modules/report/note_helper.ts"));
var BookHelper = __importStar(__webpack_require__(/*! ./book_helper */ "./src/modules/report/book_helper.ts"));
var generateReportForNote = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var report;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, NoteHelper.generateReportForNote(req.params.space, req.params.noteRef)];
            case 1:
                report = _a.sent();
                res.status(200);
                res.send(report);
                res.end();
                return [2];
        }
    });
}); };
exports.generateReportForNote = generateReportForNote;
var generateReport = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var report;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, NoteHelper.generateReport(req.params.space)];
            case 1:
                report = _a.sent();
                res.status(200);
                res.send(report);
                res.end();
                return [2];
        }
    });
}); };
exports.generateReport = generateReport;
var generateReportForBook = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var report;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, BookHelper.generateReportForBook(req.params.space, req.params.bookref)];
            case 1:
                report = _a.sent();
                res.status(200);
                res.send(report);
                res.end();
                return [2];
        }
    });
}); };
exports.generateReportForBook = generateReportForBook;


/***/ }),

/***/ "./src/modules/sequence/service.ts":
/*!*****************************************!*\
  !*** ./src/modules/sequence/service.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resetval = exports.nextval = exports.create_sequence = void 0;
var _a = __webpack_require__(/*! ./model */ "./src/modules/sequence/model.js"), sequenceCollection = _a.sequenceCollection, sequenceSchema = _a.sequenceSchema;
var _b = __webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts"), getGlobalCollection = _b.getGlobalCollection, getCollection = _b.getCollection;
var create_sequence = function (field, context, factor, space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, existing_sequence;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (space) {
                    model = getCollection(space, sequenceCollection, sequenceSchema);
                }
                else {
                    model = getGlobalCollection(sequenceCollection, sequenceSchema);
                }
                return [4, model.findOne({ field: field, context: context })];
            case 1:
                existing_sequence = _a.sent();
                if (existing_sequence) {
                    return [2, existing_sequence];
                }
                return [4, model.findOneAndUpdate({ field: field, context: context }, { field: field, context: context, factor: factor, nextval: 1 }, { upsert: true, new: true })];
            case 2: return [2, _a.sent()];
        }
    });
}); };
exports.create_sequence = create_sequence;
var nextval = function (field, context, space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, sequence;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (space) {
                    model = getCollection(space, sequenceCollection, sequenceSchema);
                }
                else {
                    model = getGlobalCollection(sequenceCollection, sequenceSchema);
                }
                return [4, model.findOne({ field: field, context: context })];
            case 1:
                sequence = _a.sent();
                if (!!sequence) return [3, 4];
                return [4, (0, exports.create_sequence)(field, context || null, 1, space)];
            case 2:
                _a.sent();
                return [4, model.findOne({ field: field, context: context })];
            case 3:
                sequence = _a.sent();
                _a.label = 4;
            case 4: return [4, model.findOneAndUpdate({ field: field, context: context }, { nextval: sequence.nextval + sequence.factor }, { upsert: true, new: true })];
            case 5:
                _a.sent();
                return [2, sequence.nextval];
        }
    });
}); };
exports.nextval = nextval;
var resetval = function (value, field, context, space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, sequence;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (space) {
                    model = getCollection(space, sequenceCollection, sequenceSchema);
                }
                else {
                    model = getGlobalCollection(sequenceCollection, sequenceSchema);
                }
                return [4, model.findOne({ field: field, context: context })];
            case 1:
                sequence = _a.sent();
                if (!!sequence) return [3, 4];
                return [4, (0, exports.create_sequence)(field, context || null, 1, space)];
            case 2:
                _a.sent();
                return [4, model.findOne({ field: field, context: context })];
            case 3:
                sequence = _a.sent();
                _a.label = 4;
            case 4: return [4, model.findOneAndUpdate({ field: field, context: context }, { nextval: value }, { upsert: true, new: true })];
            case 5:
                _a.sent();
                return [2];
        }
    });
}); };
exports.resetval = resetval;


/***/ }),

/***/ "./src/modules/session/index.ts":
/*!**************************************!*\
  !*** ./src/modules/session/index.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolvers = exports.typeDefs = void 0;
var jsonwebtoken_1 = __importDefault(__webpack_require__(/*! jsonwebtoken */ "jsonwebtoken"));
var apollo_server_express_1 = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/session/model.ts");
var model_2 = __webpack_require__(/*! ../user/model */ "./src/modules/user/model.ts");
var getCollection = (__webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://127.0.0.1:8020";
var typeDefs = (0, apollo_server_express_1.gql)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  extend type Query {\n    session(id: ID!, space: String): UserSession\n  }\n\n  type Session {\n    id: ID!\n    sessionId: String!\n    token: String!\n  }\n\n  type UserSession {\n    id: ID!\n    firstName: String\n    lastName: String\n    email: String\n    token: String\n  }\n"], ["\n  extend type Query {\n    session(id: ID!, space: String): UserSession\n  }\n\n  type Session {\n    id: ID!\n    sessionId: String!\n    token: String!\n  }\n\n  type UserSession {\n    id: ID!\n    firstName: String\n    lastName: String\n    email: String\n    token: String\n  }\n"])));
exports.typeDefs = typeDefs;
var oaSession = function (space, id) { return __awaiter(void 0, void 0, void 0, function () {
    var response, user, model, data, error_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 5, , 6]);
                return [4, axios.get("".concat(ONEAUTH_API, "/auth/space/").concat(space, "/session/").concat(id))];
            case 1:
                response = _a.sent();
                if (!(response.status === 200)) return [3, 3];
                user = jsonwebtoken_1.default.verify(response.data.token, "jwtsecret");
                model = getCollection(space, model_2.userCollection, model_2.userSchema);
                return [4, model.findByIdAndUpdate(user.userId, __assign(__assign({}, user), { resolver: "oneauth_space" }), { new: true, upsert: true })];
            case 2:
                data = _a.sent();
                if (data) {
                    return [2, {
                            id: data._id,
                            firstName: data.firstName,
                            lastName: data.lastName,
                            email: data.email,
                            token: response.data.token,
                        }];
                }
                else {
                    return [2, null];
                }
                return [3, 4];
            case 3: return [2, null];
            case 4: return [3, 6];
            case 5:
                error_1 = _a.sent();
                return [2, null];
            case 6: return [2];
        }
    });
}); };
var emailOrExternSession = function (space, sessionId) { return __awaiter(void 0, void 0, void 0, function () {
    var model, session, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.sessionCollection, model_1.sessionSchema);
                return [4, model.findOne({ sessionId: sessionId })];
            case 1:
                session = _a.sent();
                if (!session) {
                    return [2, null];
                }
                return [4, jsonwebtoken_1.default.verify(session.token, "jwtsecret")];
            case 2:
                data = _a.sent();
                if (!data) {
                    return [2, null];
                }
                return [2, {
                        id: data.userId,
                        firstName: data.firstName,
                        lastName: data.lastName,
                        email: data.email,
                        token: session.token,
                    }];
        }
    });
}); };
var resolvers = {
    Query: {
        session: function (_1, _a) { return __awaiter(void 0, [_1, _a], void 0, function (_, _b) {
            var id = _b.id, space = _b.space;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4, oaSession(space, id)];
                    case 1: return [2, _c.sent()];
                }
            });
        }); },
    },
};
exports.resolvers = resolvers;
var templateObject_1;


/***/ }),

/***/ "./src/modules/session/model.ts":
/*!**************************************!*\
  !*** ./src/modules/session/model.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sessionCollection = exports.sessionSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var sessionSchema = new Schema({
    sessionId: { type: String },
    token: { type: String },
    type: { type: String },
}, { timestamps: true });
exports.sessionSchema = sessionSchema;
var sessionCollection = "session";
exports.sessionCollection = sessionCollection;


/***/ }),

/***/ "./src/modules/stopwords/helper.ts":
/*!*****************************************!*\
  !*** ./src/modules/stopwords/helper.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resetStopwords = exports.deleteStopword = exports.getStopwords = exports.toggleStopword = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/stopwords/model.ts");
var stopwords_1 = __webpack_require__(/*! ./stopwords */ "./src/modules/stopwords/stopwords.ts");
var getCollection = (__webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var toggleStopword = function (space, payload) { return __awaiter(void 0, void 0, void 0, function () {
    var _text, model, response, existingData;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _text = payload.text.toLowerCase();
                model = getCollection(space, model_1.stopwordsCollection, model_1.stopwordsSchema);
                response = null;
                return [4, model.find({ text: _text })];
            case 1:
                existingData = _a.sent();
                if (!(existingData.length > 0)) return [3, 3];
                return [4, model.findOneAndUpdate({ text: _text }, { enabled: !existingData[0].enabled }, { new: true, upsert: true })];
            case 2:
                response = _a.sent();
                return [3, 5];
            case 3: return [4, model.create({
                    text: _text, enabled: true
                })];
            case 4:
                response = _a.sent();
                _a.label = 5;
            case 5: return [4, (0, exports.getStopwords)(space)];
            case 6: return [2, _a.sent()];
        }
    });
}); };
exports.toggleStopword = toggleStopword;
var getStopwords = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.stopwordsCollection, model_1.stopwordsSchema);
                return [4, model.find().sort({ text: "ascending" })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getStopwords = getStopwords;
var deleteStopword = function (space, _id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.stopwordsCollection, model_1.stopwordsSchema);
                return [4, model.deleteMany({ _id: _id })];
            case 1:
                _a.sent();
                return [4, (0, exports.getStopwords)(space)];
            case 2: return [2, _a.sent()];
        }
    });
}); };
exports.deleteStopword = deleteStopword;
var resetStopwords = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var model, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = getCollection(space, model_1.stopwordsCollection, model_1.stopwordsSchema);
                data = [];
                stopwords_1.BASE_STOPWORDS_EN.forEach(function (text) {
                    data.push({
                        text: text,
                        enabled: true
                    });
                });
                return [4, model.deleteMany({})];
            case 1:
                _a.sent();
                return [4, model.insertMany(data)];
            case 2:
                _a.sent();
                return [4, (0, exports.getStopwords)(space)];
            case 3: return [2, _a.sent()];
        }
    });
}); };
exports.resetStopwords = resetStopwords;


/***/ }),

/***/ "./src/modules/stopwords/model.ts":
/*!****************************************!*\
  !*** ./src/modules/stopwords/model.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stopwordsCollection = exports.stopwordsSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var stopwordsSchema = new Schema({
    text: { type: String },
    enabled: { type: Boolean }
}, { timestamps: true, minimize: false });
exports.stopwordsSchema = stopwordsSchema;
var stopwordsCollection = "stopwords";
exports.stopwordsCollection = stopwordsCollection;


/***/ }),

/***/ "./src/modules/stopwords/route.ts":
/*!****************************************!*\
  !*** ./src/modules/stopwords/route.ts ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/stopwords/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.post("/stopwords/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.toggleStopword));
    router.post("/stopwords/:space/reset", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.resetStopwords));
    router.get("/stopwords/:space", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getStopwords));
    router.delete("/stopwords/:space/:id", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.deleteStopword));
};


/***/ }),

/***/ "./src/modules/stopwords/service.ts":
/*!******************************************!*\
  !*** ./src/modules/stopwords/service.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStopwords = exports.deleteStopword = exports.resetStopwords = exports.toggleStopword = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/stopwords/helper.ts"));
var selfRealm = 100;
var toggleStopword = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var stopwords;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.toggleStopword(req.params.space, req.body)];
            case 1:
                stopwords = _a.sent();
                res.status(200);
                res.send(stopwords);
                res.end();
                return [2];
        }
    });
}); };
exports.toggleStopword = toggleStopword;
var resetStopwords = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var stopwords;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.resetStopwords(req.params.space)];
            case 1:
                stopwords = _a.sent();
                res.status(200);
                res.send(stopwords);
                res.end();
                return [2];
        }
    });
}); };
exports.resetStopwords = resetStopwords;
var deleteStopword = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var response;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.deleteStopword(req.params.space, req.params.id)];
            case 1:
                response = _a.sent();
                res.status(200);
                res.send(response);
                res.end();
                return [2];
        }
    });
}); };
exports.deleteStopword = deleteStopword;
var getStopwords = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var stopwords;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.getStopwords(req.params.space)];
            case 1:
                stopwords = _a.sent();
                res.status(200);
                res.send(stopwords);
                res.end();
                return [2];
        }
    });
}); };
exports.getStopwords = getStopwords;


/***/ }),

/***/ "./src/modules/stopwords/stopwords.ts":
/*!********************************************!*\
  !*** ./src/modules/stopwords/stopwords.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BASE_STOPWORDS_EN = void 0;
exports.BASE_STOPWORDS_EN = [
    'x',
    'y',
    'your',
    'yours',
    'yourself',
    'yourselves',
    'you',
    'yond',
    'yonder',
    'yon',
    'ye',
    'yet',
    'z',
    'zillion',
    'j',
    'u',
    'umpteen',
    'usually',
    'us',
    'username',
    'uponed',
    'upons',
    'uponing',
    'upon',
    'ups',
    'upping',
    'upped',
    'up',
    'unto',
    'until',
    'unless',
    'unlike',
    'unliker',
    'unlikest',
    'under',
    'underneath',
    'use',
    'used',
    'usedest',
    'r',
    'rath',
    'rather',
    'rathest',
    'rathe',
    're',
    'relate',
    'related',
    'relatively',
    'regarding',
    'really',
    'res',
    'respecting',
    'respectively',
    'q',
    'quite',
    'que',
    'qua',
    'n',
    'neither',
    'neaths',
    'neath',
    'nethe',
    'nethermost',
    'necessary',
    'necessariest',
    'necessarier',
    'never',
    'nevertheless',
    'nigh',
    'nighest',
    'nigher',
    'nine',
    'noone',
    'nobody',
    'nobodies',
    'nowhere',
    'nowheres',
    'no',
    'noes',
    'nor',
    'nos',
    'no-one',
    'none',
    'not',
    'notwithstanding',
    'nothings',
    'nothing',
    'nathless',
    'natheless',
    't',
    'ten',
    'tills',
    'till',
    'tilled',
    'tilling',
    'to',
    'towards',
    'toward',
    'towardest',
    'towarder',
    'together',
    'too',
    'thy',
    'thyself',
    'thus',
    'than',
    'that',
    'those',
    'thou',
    'though',
    'thous',
    'thouses',
    'thoroughest',
    'thorougher',
    'thorough',
    'thoroughly',
    'thru',
    'thruer',
    'thruest',
    'thro',
    'through',
    'throughout',
    'throughest',
    'througher',
    'thine',
    'this',
    'thises',
    'they',
    'thee',
    'the',
    'then',
    'thence',
    'thenest',
    'thener',
    'them',
    'themselves',
    'these',
    'therer',
    'there',
    'thereby',
    'therest',
    'thereafter',
    'therein',
    'thereupon',
    'therefore',
    'their',
    'theirs',
    'thing',
    'things',
    'three',
    'two',
    'o',
    'oh',
    'owt',
    'owning',
    'owned',
    'own',
    'owns',
    'others',
    'other',
    'otherwise',
    'otherwisest',
    'otherwiser',
    'of',
    'often',
    'oftener',
    'oftenest',
    'off',
    'offs',
    'offest',
    'one',
    'ought',
    'oughts',
    'our',
    'ours',
    'ourselves',
    'ourself',
    'out',
    'outest',
    'outed',
    'outwith',
    'outs',
    'outside',
    'over',
    'overallest',
    'overaller',
    'overalls',
    'overall',
    'overs',
    'or',
    'orer',
    'orest',
    'on',
    'oneself',
    'onest',
    'ons',
    'onto',
    'a',
    'atween',
    'at',
    'athwart',
    'atop',
    'afore',
    'afterward',
    'afterwards',
    'after',
    'afterest',
    'afterer',
    'ain',
    'an',
    'any',
    'anything',
    'anybody',
    'anyone',
    'anyhow',
    'anywhere',
    'anent',
    'anear',
    'and',
    'andor',
    'another',
    'around',
    'ares',
    'are',
    'aest',
    'aer',
    'against',
    'again',
    'accordingly',
    'abaft',
    'abafter',
    'abaftest',
    'abovest',
    'above',
    'abover',
    'abouter',
    'aboutest',
    'about',
    'aid',
    'amidst',
    'amid',
    'among',
    'amongst',
    'apartest',
    'aparter',
    'apart',
    'appeared',
    'appears',
    'appear',
    'appearing',
    'appropriating',
    'appropriate',
    'appropriatest',
    'appropriates',
    'appropriater',
    'appropriated',
    'already',
    'always',
    'also',
    'along',
    'alongside',
    'although',
    'almost',
    'all',
    'allest',
    'aller',
    'allyou',
    'alls',
    'albeit',
    'awfully',
    'as',
    'aside',
    'asides',
    'aslant',
    'ases',
    'astrider',
    'astride',
    'astridest',
    'astraddlest',
    'astraddler',
    'astraddle',
    'availablest',
    'availabler',
    'available',
    'aughts',
    'aught',
    'vs',
    'v',
    'variousest',
    'variouser',
    'various',
    'via',
    'vis-a-vis',
    'vis-a-viser',
    'vis-a-visest',
    'viz',
    'very',
    'veriest',
    'verier',
    'versus',
    'k',
    'g',
    'go',
    'gone',
    'good',
    'got',
    'gotta',
    'gotten',
    'get',
    'gets',
    'getting',
    'b',
    'by',
    'byandby',
    'by-and-by',
    'bist',
    'both',
    'but',
    'buts',
    'be',
    'beyond',
    'because',
    'became',
    'becomes',
    'become',
    'becoming',
    'becomings',
    'becominger',
    'becomingest',
    'behind',
    'behinds',
    'before',
    'beforehand',
    'beforehandest',
    'beforehander',
    'bettered',
    'betters',
    'better',
    'bettering',
    'betwixt',
    'between',
    'beneath',
    'been',
    'below',
    'besides',
    'beside',
    'm',
    'my',
    'myself',
    'mucher',
    'muchest',
    'much',
    'must',
    'musts',
    'musths',
    'musth',
    'main',
    'make',
    'mayest',
    'many',
    'mauger',
    'maugre',
    'me',
    'meanwhiles',
    'meanwhile',
    'mostly',
    'most',
    'moreover',
    'more',
    'might',
    'mights',
    'midst',
    'midsts',
    'h',
    'huh',
    'humph',
    'he',
    'hers',
    'herself',
    'her',
    'hereby',
    'herein',
    'hereafters',
    'hereafter',
    'hereupon',
    'hence',
    'hadst',
    'had',
    'having',
    'haves',
    'have',
    'has',
    'hast',
    'hardly',
    'hae',
    'hath',
    'him',
    'himself',
    'hither',
    'hitherest',
    'hitherer',
    'his',
    'how-do-you-do',
    'however',
    'how',
    'howbeit',
    'howdoyoudo',
    'hoos',
    'hoo',
    'w',
    'woulded',
    'woulding',
    'would',
    'woulds',
    'was',
    'wast',
    'we',
    'wert',
    'were',
    'with',
    'withal',
    'without',
    'within',
    'why',
    'what',
    'whatever',
    'whateverer',
    'whateverest',
    'whatsoeverer',
    'whatsoeverest',
    'whatsoever',
    'whence',
    'whencesoever',
    'whenever',
    'whensoever',
    'when',
    'whenas',
    'whether',
    'wheen',
    'whereto',
    'whereupon',
    'wherever',
    'whereon',
    'whereof',
    'where',
    'whereby',
    'wherewithal',
    'wherewith',
    'whereinto',
    'wherein',
    'whereafter',
    'whereas',
    'wheresoever',
    'wherefrom',
    'which',
    'whichever',
    'whichsoever',
    'whilst',
    'while',
    'whiles',
    'whithersoever',
    'whither',
    'whoever',
    'whosoever',
    'whoso',
    'whose',
    'whomever',
    's',
    'syne',
    'syn',
    'shalling',
    'shall',
    'shalled',
    'shalls',
    'shoulding',
    'should',
    'shoulded',
    'shoulds',
    'she',
    'sayyid',
    'sayid',
    'said',
    'saider',
    'saidest',
    'same',
    'samest',
    'sames',
    'samer',
    'saved',
    'sans',
    'sanses',
    'sanserifs',
    'sanserif',
    'so',
    'soer',
    'soest',
    'sobeit',
    'someone',
    'somebody',
    'somehow',
    'some',
    'somewhere',
    'somewhat',
    'something',
    'sometimest',
    'sometimes',
    'sometimer',
    'sometime',
    'several',
    'severaler',
    'severalest',
    'serious',
    'seriousest',
    'seriouser',
    'senza',
    'send',
    'sent',
    'seem',
    'seems',
    'seemed',
    'seemingest',
    'seeminger',
    'seemings',
    'seven',
    'summat',
    'sups',
    'sup',
    'supping',
    'supped',
    'such',
    'since',
    'sine',
    'sines',
    'sith',
    'six',
    'stop',
    'stopped',
    'p',
    'plaintiff',
    'plenty',
    'plenties',
    'please',
    'pleased',
    'pleases',
    'per',
    'perhaps',
    'particulars',
    'particularly',
    'particular',
    'particularest',
    'particularer',
    'pro',
    'providing',
    'provides',
    'provided',
    'provide',
    'probably',
    'l',
    'layabout',
    'layabouts',
    'latter',
    'latterest',
    'latterer',
    'latterly',
    'latters',
    'lots',
    'lotting',
    'lotted',
    'lot',
    'lest',
    'less',
    'ie',
    'ifs',
    'if',
    'i',
    'info',
    'information',
    'itself',
    'its',
    'it',
    'is',
    'idem',
    'idemer',
    'idemest',
    'immediate',
    'immediately',
    'immediatest',
    'immediater',
    'in',
    'inwards',
    'inwardest',
    'inwarder',
    'inward',
    'inasmuch',
    'into',
    'instead',
    'insofar',
    'indicates',
    'indicated',
    'indicate',
    'indicating',
    'indeed',
    'inc',
    'f',
    'fact',
    'facts',
    'fs',
    'figupon',
    'figupons',
    'figuponing',
    'figuponed',
    'few',
    'fewer',
    'fewest',
    'frae',
    'from',
    'failing',
    'failings',
    'five',
    'furthers',
    'furtherer',
    'furthered',
    'furtherest',
    'further',
    'furthering',
    'furthermore',
    'fourscore',
    'followthrough',
    'for',
    'forwhy',
    'fornenst',
    'formerly',
    'former',
    'formerer',
    'formerest',
    'formers',
    'forbye',
    'forby',
    'fore',
    'forever',
    'forer',
    'fores',
    'four',
    'd',
    'ddays',
    'dday',
    'do',
    'doing',
    'doings',
    'doe',
    'does',
    'doth',
    'downwarder',
    'downwardest',
    'downward',
    'downwards',
    'downs',
    'done',
    'doner',
    'dones',
    'donest',
    'dos',
    'dost',
    'did',
    'differentest',
    'differenter',
    'different',
    'describing',
    'describe',
    'describes',
    'described',
    'despiting',
    'despites',
    'despited',
    'despite',
    'during',
    'c',
    'cum',
    'circa',
    'chez',
    'cer',
    'certain',
    'certainest',
    'certainer',
    'cest',
    'canst',
    'cannot',
    'cant',
    'cants',
    'canting',
    'cantest',
    'canted',
    'co',
    'could',
    'couldst',
    'comeon',
    'comeons',
    'come-ons',
    'come-on',
    'concerning',
    'concerninger',
    'concerningest',
    'consequently',
    'considering',
    'e',
    'eg',
    'eight',
    'either',
    'even',
    'evens',
    'evenser',
    'evensest',
    'evened',
    'evenest',
    'ever',
    'everyone',
    'everything',
    'everybody',
    'everywhere',
    'every',
    'ere',
    'each',
    'et',
    'etc',
    'elsewhere',
    'else',
    'ex',
    'excepted',
    'excepts',
    'except',
    'excepting',
    'exes',
    'enough',
    'away'
];


/***/ }),

/***/ "./src/modules/user/helper.ts":
/*!************************************!*\
  !*** ./src/modules/user/helper.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserById = exports.getUserByEmail = exports.getUsers = exports.validateSession = exports.getNewAccessToken = exports.decodeAccessToken = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/user/model.ts");
var model_2 = __webpack_require__(/*! ../user/invite/model */ "./src/modules/user/invite/model.ts");
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/user/helper.ts"));
var dbutils_1 = __webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts");
var helper_1 = __webpack_require__(/*! ../auth/helper */ "./src/modules/auth/helper.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/user/service.ts");
var decodeAccessToken = function (space, accessToken) { return __awaiter(void 0, void 0, void 0, function () {
    var decodedResponse, err_1, model, existingUserRecord, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                decodedResponse = null;
                _a.label = 1;
            case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, axios.get("".concat(ONEAUTH_API, "/auth/token/decode"), {
                        headers: {
                            authorization: accessToken,
                        },
                    })];
            case 2:
                decodedResponse = _a.sent();
                return [3, 4];
            case 3:
                err_1 = _a.sent();
                if (err_1.response.status === 401) {
                    return [2, "expired"];
                }
                return [2, "expired"];
            case 4:
                if (!(decodedResponse.status === 200)) return [3, 9];
                model = (0, dbutils_1.getGlobalCollection)(model_1.userCollection, model_1.userSchema);
                return [4, model.find({
                        email: decodedResponse.data.email,
                    })];
            case 5:
                existingUserRecord = _a.sent();
                return [4, model.findByIdAndUpdate(decodedResponse.data.user_id, __assign(__assign({}, decodedResponse.data), { resolver: "oneauth_space" }), { new: true, upsert: true })];
            case 6:
                data = _a.sent();
                if (!(existingUserRecord.length === 0)) return [3, 8];
                return [4, autoAcceptInvites(data)];
            case 7:
                _a.sent();
                _a.label = 8;
            case 8: return [2, decodedResponse.data || null];
            case 9: return [2, null];
        }
    });
}); };
exports.decodeAccessToken = decodeAccessToken;
var autoAcceptInvites = function (user) { return __awaiter(void 0, void 0, void 0, function () {
    var model, pendingInviteList, i, res;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_2.userInviteCollection, model_2.userInviteSchema);
                return [4, model.find({ email: user.email })];
            case 1:
                pendingInviteList = _a.sent();
                console.log(pendingInviteList);
                i = 0;
                _a.label = 2;
            case 2:
                if (!(i < pendingInviteList.length)) return [3, 5];
                return [4, model.findByIdAndUpdate(pendingInviteList[i]._id, __assign(__assign({}, pendingInviteList[i]._doc), { userId: user._id, accepted: true }), { new: true, upsert: true })];
            case 3:
                res = _a.sent();
                console.log(__assign(__assign({}, pendingInviteList[i]), { userId: user._id, accepted: true }));
                _a.label = 4;
            case 4:
                i++;
                return [3, 2];
            case 5: return [2];
        }
    });
}); };
var getNewAccessToken = function (space, refreshToken) { return __awaiter(void 0, void 0, void 0, function () {
    var refreshTokenResponse;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, axios.post("".concat(ONEAUTH_API, "/auth/token"), {
                    grant_type: "refresh_token",
                    realm: space,
                    refresh_token: refreshToken,
                })];
            case 1:
                refreshTokenResponse = _a.sent();
                if (refreshTokenResponse.status === 200) {
                    return [2, refreshTokenResponse.data];
                }
                return [2, null];
        }
    });
}); };
exports.getNewAccessToken = getNewAccessToken;
var validateSession = function (localAccessToken, refreshToken, appRealm) { return __awaiter(void 0, void 0, void 0, function () {
    var model, localTokenResponse, accessToken, localClaims, _a, _accessToken, _localClaims, accessTokenResponse, newAccessToken, newAccessTokenResponse;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.userCollection, model_1.userSchema);
                return [4, (0, helper_1.decodeAppToken)(localAccessToken)];
            case 1:
                localTokenResponse = _c.sent();
                accessToken = "";
                localClaims = {};
                if (!localTokenResponse.outcome) {
                    return [2, null];
                }
                _a = localTokenResponse.claims, _accessToken = _a.accessToken, _localClaims = __rest(_a, ["accessToken"]);
                accessToken = _accessToken;
                localClaims = {
                    space: _localClaims.space,
                    companyId: _localClaims.companyId,
                };
                return [4, Helper.decodeAccessToken(Number(appRealm), accessToken)];
            case 2:
                accessTokenResponse = _c.sent();
                if (accessTokenResponse !== "expired") {
                    return [2, {
                            accessToken: null,
                            claims: accessTokenResponse,
                            space: localClaims.space,
                        }];
                }
                return [4, Helper.getNewAccessToken(appRealm, refreshToken)];
            case 3:
                newAccessToken = _c.sent();
                if (!(newAccessToken === null || newAccessToken === void 0 ? void 0 : newAccessToken.access_token)) return [3, 6];
                return [4, Helper.decodeAccessToken(appRealm, newAccessToken.access_token)];
            case 4:
                newAccessTokenResponse = _c.sent();
                _b = {};
                return [4, (0, service_1.getLocalTokenImpl)(newAccessTokenResponse.user_id, newAccessToken.access_token)];
            case 5: return [2, (_b.accessToken = _c.sent(),
                    _b.claims = newAccessTokenResponse,
                    _b.space = localClaims.space,
                    _b)];
            case 6: return [2, null];
        }
    });
}); };
exports.validateSession = validateSession;
var getUsers = function () { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.userCollection, model_1.userSchema);
                return [4, model.find()];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getUsers = getUsers;
var getUserByEmail = function (email) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.userCollection, model_1.userSchema);
                return [4, model.findOne({ email: email.toLowerCase() })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getUserByEmail = getUserByEmail;
var getUserById = function (id) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.userCollection, model_1.userSchema);
                return [4, model.findById(id)];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getUserById = getUserById;


/***/ }),

/***/ "./src/modules/user/index.ts":
/*!***********************************!*\
  !*** ./src/modules/user/index.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolvers = exports.typeDefs = void 0;
var apollo_server_express_1 = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/user/model.ts");
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/user/helper.ts"));
var getCollection = (__webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts").getCollection);
var typeDefs = (0, apollo_server_express_1.gql)(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  type Query {\n    user: [User]\n    authorizeUser(\n      accessToken: String\n      refreshToken: String\n      space: String\n    ): AuthorizeResponse\n  }\n\n  type Mutation {\n    createEmailAccount(payload: UserPayload): User!\n  }\n\n  input UserPayload {\n    firstName: String!\n    lastName: String!\n    email: String!\n  }\n\n  type User {\n    id: ID!\n    given_name: String\n    family_name: String\n    name: String\n    nickname: String\n    email: String\n    resolver: String\n  }\n\n  type AuthorizeResponse {\n    accessToken: String\n    claims: JSON\n  }\n"], ["\n  type Query {\n    user: [User]\n    authorizeUser(\n      accessToken: String\n      refreshToken: String\n      space: String\n    ): AuthorizeResponse\n  }\n\n  type Mutation {\n    createEmailAccount(payload: UserPayload): User!\n  }\n\n  input UserPayload {\n    firstName: String!\n    lastName: String!\n    email: String!\n  }\n\n  type User {\n    id: ID!\n    given_name: String\n    family_name: String\n    name: String\n    nickname: String\n    email: String\n    resolver: String\n  }\n\n  type AuthorizeResponse {\n    accessToken: String\n    claims: JSON\n  }\n"])));
exports.typeDefs = typeDefs;
var resolvers = {
    Query: {
        user: function (_1, _a, _b) { return __awaiter(void 0, [_1, _a, _b], void 0, function (_, _c, _d) {
            var model;
            var email = _c.email;
            var space = _d.space, user = _d.user;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!space || !user) {
                            return [2, new apollo_server_express_1.AuthenticationError("Not authorized to access this content")];
                        }
                        model = getCollection(space, model_1.userCollection, model_1.userSchema);
                        return [4, model.find()];
                    case 1: return [2, _e.sent()];
                }
            });
        }); },
        authorizeUser: function (_1, _a, __1) { return __awaiter(void 0, [_1, _a, __1], void 0, function (_, _b, __) {
            var model, accessTokenResponse, newAccessToken, newAccessTokenResponse;
            var accessToken = _b.accessToken, refreshToken = _b.refreshToken, space = _b.space;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        model = getCollection(space, model_1.userCollection, model_1.userSchema);
                        return [4, Helper.decodeAccessToken(Number(space), accessToken)];
                    case 1:
                        accessTokenResponse = _c.sent();
                        if (accessTokenResponse !== "expired") {
                            return [2, {
                                    accessToken: null,
                                    claims: accessTokenResponse,
                                }];
                        }
                        return [4, Helper.getNewAccessToken(space, refreshToken)];
                    case 2:
                        newAccessToken = _c.sent();
                        if (!(newAccessToken === null || newAccessToken === void 0 ? void 0 : newAccessToken.access_token)) return [3, 4];
                        return [4, Helper.decodeAccessToken(space, newAccessToken.access_token)];
                    case 3:
                        newAccessTokenResponse = _c.sent();
                        return [2, {
                                accessToken: newAccessToken.access_token,
                                claims: newAccessTokenResponse,
                            }];
                    case 4: return [2, null];
                }
            });
        }); },
    },
    Mutation: {
        createEmailAccount: function (_1, args_1, _a) { return __awaiter(void 0, [_1, args_1, _a], void 0, function (_, args, _b) {
            var model, response;
            var space = _b.space, user = _b.user;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        model = getCollection(space, model_1.userCollection, model_1.userSchema);
                        return [4, model.findOneAndUpdate({ email: args.payload.email, resolver: "email" }, __assign(__assign({}, args.payload), { resolver: "email" }), { upsert: true, new: true, rawResult: true })];
                    case 1:
                        response = _c.sent();
                        return [2, response.value];
                }
            });
        }); },
    },
};
exports.resolvers = resolvers;
var templateObject_1;


/***/ }),

/***/ "./src/modules/user/invite/helper.ts":
/*!*******************************************!*\
  !*** ./src/modules/user/invite/helper.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserInviteByUserId = exports.registerUserInvite = exports.getUserInvite = exports.updateUserInvite = void 0;
var axios = __webpack_require__(/*! axios */ "axios");
var ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
var model_1 = __webpack_require__(/*! ./model */ "./src/modules/user/invite/model.ts");
var companyService = __importStar(__webpack_require__(/*! ../../company/service */ "./src/modules/company/service.ts"));
var userService = __importStar(__webpack_require__(/*! ../service */ "./src/modules/user/service.ts"));
var dbutils_1 = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");
var updateUserInvite = function (space, data, userId) { return __awaiter(void 0, void 0, void 0, function () {
    var company, model, user, payload, existingRecord;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, companyService.getCompanyByReference(space)];
            case 1:
                company = _a.sent();
                if (!company) {
                    return [2, null];
                }
                model = (0, dbutils_1.getGlobalCollection)(model_1.userInviteCollection, model_1.userInviteSchema);
                return [4, userService.getUserByEmail(data.email)];
            case 2:
                user = _a.sent();
                payload = __assign(__assign({}, data), { email: data.email.toLowerCase(), companyId: company._id, accepted: !!user, userId: user ? user._id : null });
                return [4, model.find({
                        email: payload.email.toLowerCase(),
                        companyId: company._id,
                    })];
            case 3:
                existingRecord = _a.sent();
                if ((existingRecord === null || existingRecord === void 0 ? void 0 : existingRecord.length) > 0) {
                    return [2, null];
                }
                return [4, model.create(payload)];
            case 4: return [2, _a.sent()];
        }
    });
}); };
exports.updateUserInvite = updateUserInvite;
var getUserInvite = function (space) { return __awaiter(void 0, void 0, void 0, function () {
    var company, model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, companyService.getCompanyByReference(space)];
            case 1:
                company = _a.sent();
                if (!company) {
                    return [2, []];
                }
                model = (0, dbutils_1.getGlobalCollection)(model_1.userInviteCollection, model_1.userInviteSchema);
                return [4, model.find({ companyId: company._id })];
            case 2: return [2, _a.sent()];
        }
    });
}); };
exports.getUserInvite = getUserInvite;
var registerUserInvite = function (space, companyId, userId, email) { return __awaiter(void 0, void 0, void 0, function () {
    var model, existingRecord;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.userInviteCollection, model_1.userInviteSchema);
                return [4, model.find({
                        email: email.toLowerCase(),
                        companyId: companyId,
                    })];
            case 1:
                existingRecord = _a.sent();
                if ((existingRecord === null || existingRecord === void 0 ? void 0 : existingRecord.length) > 0) {
                    return [2, null];
                }
                return [4, model.create({
                        companyId: companyId,
                        email: email.toLowerCase(),
                        userId: userId,
                        accepted: true,
                    })];
            case 2: return [2, _a.sent()];
        }
    });
}); };
exports.registerUserInvite = registerUserInvite;
var getUserInviteByUserId = function (userId) { return __awaiter(void 0, void 0, void 0, function () {
    var model;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                model = (0, dbutils_1.getGlobalCollection)(model_1.userInviteCollection, model_1.userInviteSchema);
                return [4, model.find({ userId: userId })];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getUserInviteByUserId = getUserInviteByUserId;


/***/ }),

/***/ "./src/modules/user/invite/model.ts":
/*!******************************************!*\
  !*** ./src/modules/user/invite/model.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.userInviteCollection = exports.userInviteSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var userInviteSchema = new Schema({
    email: { type: String },
    userId: { type: String },
    companyId: { type: String },
    accepted: { type: Boolean },
}, { timestamps: true });
exports.userInviteSchema = userInviteSchema;
var userInviteCollection = "user.permission";
exports.userInviteCollection = userInviteCollection;


/***/ }),

/***/ "./src/modules/user/invite/route.ts":
/*!******************************************!*\
  !*** ./src/modules/user/invite/route.ts ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var middlewares_1 = __webpack_require__(/*! ../../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/user/invite/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.post("/user/invite/:space", middlewares_1.authorizeApi, service_1.createUserInviteEndpoint);
    router.get("/user/invite/:space", middlewares_1.authorizeApi, service_1.getUserInvite);
};


/***/ }),

/***/ "./src/modules/user/invite/service.ts":
/*!********************************************!*\
  !*** ./src/modules/user/invite/service.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserInvite = exports.registerUserInvite = exports.createUserInviteEndpoint = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/user/invite/helper.ts"));
var selfRealm = 100;
var createUserInviteEndpoint = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, userInvite;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.updateUserInvite(req.params.space, req.body, userId)];
            case 1:
                userInvite = _a.sent();
                res.status(200);
                res.send(userInvite);
                res.end();
                return [2];
        }
    });
}); };
exports.createUserInviteEndpoint = createUserInviteEndpoint;
var registerUserInvite = function (space, companyId, userId, email) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.registerUserInvite(space, companyId, userId, email)];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.registerUserInvite = registerUserInvite;
var getUserInvite = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, userInviteList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getUserInvite(req.params.space)];
            case 1:
                userInviteList = _a.sent();
                res.status(200);
                res.send(userInviteList);
                res.end();
                return [2];
        }
    });
}); };
exports.getUserInvite = getUserInvite;


/***/ }),

/***/ "./src/modules/user/model.ts":
/*!***********************************!*\
  !*** ./src/modules/user/model.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.userCollection = exports.userSchema = void 0;
var mongoose = __webpack_require__(/*! mongoose */ "mongoose");
var Schema = mongoose.Schema;
var userSchema = new Schema({
    given_name: { type: String },
    family_name: { type: String },
    name: { type: String },
    nickname: { type: String },
    email: { type: String },
    resolver: { type: String },
}, { timestamps: true });
exports.userSchema = userSchema;
var userCollection = "user";
exports.userCollection = userCollection;


/***/ }),

/***/ "./src/modules/user/route.ts":
/*!***********************************!*\
  !*** ./src/modules/user/route.ts ***!
  \***********************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var handler_1 = __webpack_require__(/*! ../../handler */ "./src/handler.ts");
var middlewares_1 = __webpack_require__(/*! ../../middlewares */ "./src/middlewares.ts");
var service_1 = __webpack_require__(/*! ./service */ "./src/modules/user/service.ts");
var selfRealm = 100;
module.exports = function (router) {
    router.post("/user/:realmId/authorize_user", (0, handler_1.asyncHandler)(service_1.validateSession));
    router.get("/user/:realmId", middlewares_1.authorizeApi, (0, handler_1.asyncHandler)(service_1.getUsers));
    router.get("/user/token/local", middlewares_1.authorizeApiOneauth, (0, handler_1.asyncHandler)(service_1.getLocalToken));
};


/***/ }),

/***/ "./src/modules/user/service.ts":
/*!*************************************!*\
  !*** ./src/modules/user/service.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUserById = exports.getUserByEmail = exports.getLocalTokenImpl = exports.getLocalToken = exports.getUsers = exports.validateSession = void 0;
var Helper = __importStar(__webpack_require__(/*! ./helper */ "./src/modules/user/helper.ts"));
var userInviteHelper = __importStar(__webpack_require__(/*! ../user/invite/helper */ "./src/modules/user/invite/helper.ts"));
var companyHelper = __importStar(__webpack_require__(/*! ../company/helper */ "./src/modules/company/helper.ts"));
var helper_1 = __webpack_require__(/*! ../auth/helper */ "./src/modules/auth/helper.ts");
var selfRealm = 100;
var validateSession = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var session;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.validateSession(req.body.accessToken, req.body.refreshToken, req.params.realmId)];
            case 1:
                session = _a.sent();
                if (!session) {
                    res.status(404);
                    res.send("Session not found");
                    res.end();
                    return [2];
                }
                res.status(200);
                res.send(session);
                res.end();
                return [2];
        }
    });
}); };
exports.validateSession = validateSession;
var getUsers = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var userId, userList;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                userId = req.user.user_id;
                return [4, Helper.getUsers()];
            case 1:
                userList = _a.sent();
                res.status(200);
                res.send(userList);
                res.end();
                return [2];
        }
    });
}); };
exports.getUsers = getUsers;
var getLocalToken = function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
    var accessToken, appToken;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                accessToken = req.headers["authorization"];
                if (!accessToken) {
                    return [2, res.sendStatus(401)];
                }
                return [4, (0, exports.getLocalTokenImpl)(req.user.user_id, accessToken)];
            case 1:
                appToken = _a.sent();
                res.status(200);
                res.send({ token: appToken });
                res.end();
                return [2];
        }
    });
}); };
exports.getLocalToken = getLocalToken;
var getLocalTokenImpl = function (userId, accessToken) { return __awaiter(void 0, void 0, void 0, function () {
    var userInviteList, companyIdList, companyList, companyReferenceList, claims;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, userInviteHelper.getUserInviteByUserId(userId)];
            case 1:
                userInviteList = _a.sent();
                companyIdList = [];
                userInviteList.forEach(function (item) {
                    companyIdList.push(item.companyId);
                });
                return [4, companyHelper.getCompanyByIdList(companyIdList)];
            case 2:
                companyList = _a.sent();
                companyReferenceList = [];
                companyList.forEach(function (item) {
                    companyReferenceList.push(item.reference);
                });
                claims = {
                    accessToken: accessToken,
                    space: companyReferenceList,
                    companyId: companyIdList,
                };
                return [2, (0, helper_1.encodeAppToken)(claims)];
        }
    });
}); };
exports.getLocalTokenImpl = getLocalTokenImpl;
var getUserByEmail = function (email) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.getUserByEmail(email)];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getUserByEmail = getUserByEmail;
var getUserById = function (id) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4, Helper.getUserById(id)];
            case 1: return [2, _a.sent()];
        }
    });
}); };
exports.getUserById = getUserById;


/***/ }),

/***/ "./src/route.ts":
/*!**********************!*\
  !*** ./src/route.ts ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var express = __webpack_require__(/*! express */ "express");
var router = express.Router();
router.get("/", function (_, res) {
    res.send("v1.0.0");
    res.end();
});
__webpack_require__(/*! ./modules/hello/route */ "./src/modules/hello/route.ts")(router);
__webpack_require__(/*! ./modules/auth/route */ "./src/modules/auth/route.ts")(router);
__webpack_require__(/*! ./modules/note/route */ "./src/modules/note/route.ts")(router);
__webpack_require__(/*! ./modules/note/tag/route */ "./src/modules/note/tag/route.ts")(router);
__webpack_require__(/*! ./modules/user/route */ "./src/modules/user/route.ts")(router);
__webpack_require__(/*! ./modules/user/invite/route */ "./src/modules/user/invite/route.ts")(router);
__webpack_require__(/*! ./modules/company/route */ "./src/modules/company/route.ts")(router);
__webpack_require__(/*! ./modules/notelink/route */ "./src/modules/notelink/route.ts")(router);
__webpack_require__(/*! ./modules/notelink/auto/route */ "./src/modules/notelink/auto/route.ts")(router);
__webpack_require__(/*! ./modules/book/route */ "./src/modules/book/route.ts")(router);
__webpack_require__(/*! ./modules/book/chapter/route */ "./src/modules/book/chapter/route.ts")(router);
__webpack_require__(/*! ./modules/book/section/route */ "./src/modules/book/section/route.ts")(router);
__webpack_require__(/*! ./modules/book/sectiondetail/route */ "./src/modules/book/sectiondetail/route.ts")(router);
__webpack_require__(/*! ./modules/book/concept/route */ "./src/modules/book/concept/route.ts")(router);
__webpack_require__(/*! ./modules/book/conceptdetail/route */ "./src/modules/book/conceptdetail/route.ts")(router);
__webpack_require__(/*! ./modules/book/theme/route */ "./src/modules/book/theme/route.ts")(router);
__webpack_require__(/*! ./modules/book/themedetail/route */ "./src/modules/book/themedetail/route.ts")(router);
__webpack_require__(/*! ./modules/book/subtheme/route */ "./src/modules/book/subtheme/route.ts")(router);
__webpack_require__(/*! ./modules/book/shortform/route */ "./src/modules/book/shortform/route.ts")(router);
__webpack_require__(/*! ./modules/book/extract/route */ "./src/modules/book/extract/route.ts")(router);
__webpack_require__(/*! ./modules/book/log/route */ "./src/modules/book/log/route.ts")(router);
__webpack_require__(/*! ./modules/import/route */ "./src/modules/import/route.ts")(router);
__webpack_require__(/*! ./modules/import/log/route */ "./src/modules/import/log/route.ts")(router);
__webpack_require__(/*! ./modules/colorfilter/route */ "./src/modules/colorfilter/route.ts")(router);
__webpack_require__(/*! ./modules/metadata/definition/route */ "./src/modules/metadata/definition/route.ts")(router);
__webpack_require__(/*! ./modules/metadata/value/route */ "./src/modules/metadata/value/route.ts")(router);
__webpack_require__(/*! ./modules/stopwords/route */ "./src/modules/stopwords/route.ts")(router);
__webpack_require__(/*! ./modules/keywords/route */ "./src/modules/keywords/route.ts")(router);
__webpack_require__(/*! ./modules/label/route */ "./src/modules/label/route.ts")(router);
__webpack_require__(/*! ./modules/report/route */ "./src/modules/report/route.ts")(router);
__webpack_require__(/*! ./modules/flashcard/route */ "./src/modules/flashcard/route.ts")(router);
module.exports = router;


/***/ }),

/***/ "./src/startup.ts":
/*!************************!*\
  !*** ./src/startup.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initializeSequences = void 0;
var service_1 = __webpack_require__(/*! ./modules/sequence/service */ "./src/modules/sequence/service.ts");
var initializeSequences = function () {
    (0, service_1.create_sequence)("assetId", null, 1);
    (0, service_1.create_sequence)("companyId", null, 1);
};
exports.initializeSequences = initializeSequences;


/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!******************************************************!*\
  !*** ./node_modules/webpack/hot/log-apply-result.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

/**
 * @param {(string | number)[]} updatedModules updated modules
 * @param {(string | number)[] | null} renewedModules renewed modules
 */
module.exports = function (updatedModules, renewedModules) {
	var unacceptedModules = updatedModules.filter(function (moduleId) {
		return renewedModules && renewedModules.indexOf(moduleId) < 0;
	});
	var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

	if (unacceptedModules.length > 0) {
		log(
			"warning",
			"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)"
		);
		unacceptedModules.forEach(function (moduleId) {
			log("warning", "[HMR]  - " + moduleId);
		});
	}

	if (!renewedModules || renewedModules.length === 0) {
		log("info", "[HMR] Nothing hot updated.");
	} else {
		log("info", "[HMR] Updated modules:");
		renewedModules.forEach(function (moduleId) {
			if (typeof moduleId === "string" && moduleId.indexOf("!") !== -1) {
				var parts = moduleId.split("!");
				log.groupCollapsed("info", "[HMR]  - " + parts.pop());
				log("info", "[HMR]  - " + moduleId);
				log.groupEnd("info");
			} else {
				log("info", "[HMR]  - " + moduleId);
			}
		});
		var numberIds = renewedModules.every(function (moduleId) {
			return typeof moduleId === "number";
		});
		if (numberIds)
			log(
				"info",
				'[HMR] Consider using the optimization.moduleIds: "named" for module names.'
			);
	}
};


/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

/** @typedef {"info" | "warning" | "error"} LogLevel */

/** @type {LogLevel} */
var logLevel = "info";

function dummy() {}

/**
 * @param {LogLevel} level log level
 * @returns {boolean} true, if should log
 */
function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

/**
 * @param {(msg?: string) => void} logFn log function
 * @returns {(level: LogLevel, msg?: string) => void} function that logs when log level is sufficient
 */
function logGroup(logFn) {
	return function (level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

/**
 * @param {LogLevel} level log level
 * @param {string|Error} msg message
 */
module.exports = function (level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

/**
 * @param {LogLevel} level log level
 */
module.exports.setLogLevel = function (level) {
	logLevel = level;
};

/**
 * @param {Error} err error
 * @returns {string} formatted error
 */
module.exports.formatError = function (err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	}
	return stack;
};


/***/ }),

/***/ "./node_modules/webpack/hot/poll.js?1000":
/*!***********************************************!*\
  !*** ./node_modules/webpack/hot/poll.js?1000 ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __resourceQuery = "?1000";
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/* globals __resourceQuery */
if (true) {
	var hotPollInterval = +__resourceQuery.slice(1) || 0;
	var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");

	/**
	 * @param {boolean=} fromUpdate true when called from update
	 */
	var checkForUpdate = function checkForUpdate(fromUpdate) {
		if (module.hot.status() === "idle") {
			module.hot
				.check(true)
				.then(function (updatedModules) {
					if (!updatedModules) {
						if (fromUpdate) log("info", "[HMR] Update applied.");
						return;
					}
					__webpack_require__(/*! ./log-apply-result */ "./node_modules/webpack/hot/log-apply-result.js")(updatedModules, updatedModules);
					checkForUpdate(true);
				})
				.catch(function (err) {
					var status = module.hot.status();
					if (["abort", "fail"].indexOf(status) >= 0) {
						log("warning", "[HMR] Cannot apply update.");
						log("warning", "[HMR] " + log.formatError(err));
						log("warning", "[HMR] You need to restart the application!");
					} else {
						log("warning", "[HMR] Update failed: " + log.formatError(err));
					}
				});
		}
	};
	setInterval(checkForUpdate, hotPollInterval);
} else {}


/***/ }),

/***/ "./src/lib/authutils.js":
/*!******************************!*\
  !*** ./src/lib/authutils.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");

const isUnauthorized = (user) => {
  if (!user) {
    return new AuthenticationError("Not authorized to access this content");
  }
  return false;
};

module.exports = { isUnauthorized };


/***/ }),

/***/ "./src/modules/article/category/index.js":
/*!***********************************************!*\
  !*** ./src/modules/article/category/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { categoryCollection, categorySchema } = __webpack_require__(/*! ./model */ "./src/modules/article/category/model.js");
const { getCollection } = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");
const { isUnauthorized } = __webpack_require__(/*! ../../../lib/authutils */ "./src/lib/authutils.js");

const typeDefs = gql`
  extend type Query {
    articleCategory(id: ID!): ArticleCategory
    articleCategories: [ArticleCategory]
  }

  extend type Mutation {
    addArticleCategory(payload: ArticleCategoryPayload): ArticleCategory
  }

  input ArticleCategoryPayload {
    id: String
    name: String
  }

  extend type Article {
    category: ArticleCategory
  }

  type ArticleCategory {
    id: ID!
    name: String
    articles: Int
  }
`;

const resolvers = {
  Query: {
    articleCategory: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, categoryCollection, categorySchema);
      return await model.findById(id);
    },
    articleCategories: async (_, __, { user, asset }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, categoryCollection, categorySchema);
      return await model.find();
    },
  },

  Mutation: {
    addArticleCategory: async (_, args, { user, asset }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, categoryCollection, categorySchema);
      if (args.payload.id) {
        return await model.findByIdAndUpdate(args.payload.id, args.payload, {
          new: true,
        });
      } else {
        const data = new model(args.payload);
        return await data.save();
      }
    },
  },

  Article: {
    category: {
      resolve: async (parent, _args, { asset, user }, info) => {
        if (!asset || !user) {
          return new AuthenticationError(
            "Not authorized to access this content"
          );
        }
        const model = getCollection(asset, categoryCollection, categorySchema);
        return await model.findById(parent.categoryId);
      },
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/article/category/model.js":
/*!***********************************************!*\
  !*** ./src/modules/article/category/model.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const categorySchema = new Schema(
  {
    name: { type: String },
    // parentCategoryId: { type: String },
    articles: { type: Number, default: 0 },
  },
  { timestamps: true }
);

const categoryCollection = "article.category";

module.exports = { categorySchema, categoryCollection };


/***/ }),

/***/ "./src/modules/article/comment/feedback/index.js":
/*!*******************************************************!*\
  !*** ./src/modules/article/comment/feedback/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const {
  articleCommentFeedbackSchema,
  articleCommentFeedbackCollection,
} = __webpack_require__(/*! ./model */ "./src/modules/article/comment/feedback/model.js");
const { articleCommentSchema, articleCommentCollection } = __webpack_require__(/*! ../model */ "./src/modules/article/comment/model.js");
const { getCollection } = __webpack_require__(/*! ../../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    articleCommentFeedback(commentId: ID!): [ArticleCommentFeedback]
  }

  extend type Mutation {
    addArticleCommentFeedback(
      commentId: String!
      type: String!
    ): ArticleCommentFeedback
    removeArticleCommentFeedback(
      commentId: String!
      type: String!
    ): ArticleCommentFeedback
  }

  type ArticleCommentFeedback {
    id: ID!
    type: String
  }

  extend type ArticleComment {
    feedback: [ArticleCommentFeedback]
  }
`;

const resolvers = {
  Query: {
    articleCommentFeedback: async (_, { commentId }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentFeedbackCollection,
        articleCommentFeedbackSchema
      );
      return await model.find({ commentId: commentId, userId: user.userId });
    },
  },

  ArticleComment: {
    feedback: {
      resolve: async (parent, _args, { asset, user }) => {
        if (!asset || !user) {
          return new AuthenticationError(
            "Not authorized to access this content"
          );
        }
        const model = getCollection(
          asset,
          articleCommentFeedbackCollection,
          articleCommentFeedbackSchema
        );
        return await model.find({ commentId: parent.id, userId: user.userId });
      },
    },
  },

  Mutation: {
    addArticleCommentFeedback: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentFeedbackCollection,
        articleCommentFeedbackSchema
      );
      const response = await model.findOneAndUpdate(
        { commentId: args.commentId, userId: user.userId, type: args.type },
        { commentId: args.commentId, userId: user.userId, type: args.type },
        { upsert: true, new: true, rawResult: true }
      );
      if (!response.lastErrorObject.updatedExisting) {
        const articleCommentModel = getCollection(
          asset,
          articleCommentCollection,
          articleCommentSchema
        );
        await articleCommentModel.findByIdAndUpdate(
          args.commentId,
          {
            $inc: { [args.type]: 1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
    removeArticleCommentFeedback: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentFeedbackCollection,
        articleCommentFeedbackSchema
      );
      const response = await model.findOneAndDelete(
        { commentId: args.commentId, userId: user.userId, type: args.type },
        {
          rawResult: true,
        }
      );
      if (response.lastErrorObject.n > 0) {
        const articleCommentModel = getCollection(
          asset,
          articleCommentCollection,
          articleCommentSchema
        );
        await articleCommentModel.findByIdAndUpdate(
          args.commentId,
          {
            $inc: { [args.type]: -1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/article/comment/feedback/model.js":
/*!*******************************************************!*\
  !*** ./src/modules/article/comment/feedback/model.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const articleCommentFeedbackSchema = new Schema(
  {
    commentId: { type: String },
    type: { type: String },
    userId: { type: String },
  },
  { timestamps: true }
);

const articleCommentFeedbackCollection = "article.comment.feedback";

module.exports = {
  articleCommentFeedbackSchema,
  articleCommentFeedbackCollection,
};


/***/ }),

/***/ "./src/modules/article/comment/index.js":
/*!**********************************************!*\
  !*** ./src/modules/article/comment/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { articleCommentSchema, articleCommentCollection } = __webpack_require__(/*! ./model */ "./src/modules/article/comment/model.js");
const { articleSchema, articleCollection } = __webpack_require__(/*! ../model */ "./src/modules/article/model.js");
const { getCollection } = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    articleComments(
      articleId: String!
      pageSize: Int
      pageNo: Int
    ): ArticleCommentPaginated
    articleComment(id: ID!): ArticleComment
  }

  extend type Mutation {
    updateArticleComment(payload: ArticleCommentPayload!): ArticleComment
    markArticleCommentAsAnswer(id: ID!): ArticleComment
    unmarkArticleCommentAsAnswer(id: ID!): ArticleComment
  }

  type ArticleCommentPaginated {
    pageNo: Int
    hasMore: Boolean
    total: Int
    results: [ArticleComment]!
  }

  input ArticleCommentPayload {
    id: ID
    text: String
    parentId: String
    articleId: String!
  }

  type ArticleComment {
    id: ID!
    text: String
    parentId: String
    helpful: Int
    notHelpful: Int
    isAnswer: Boolean
    createdBy: String
    updatedBy: String
    createdAt: DateScalar
    updatedAt: DateScalar
  }

  extend type ArticleCommentFeedback {
    articleComment: ArticleComment
  }
`;

const resolvers = {
  Query: {
    articleComments: async (
      _,
      { articleId, pageSize = 0, pageNo = 0 },
      { asset, user }
    ) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentCollection,
        articleCommentSchema
      );
      const response = await model
        .find({ articleId: articleId })
        // .sort({ rootParentId: 1, parentId: 1, createdAt: 1 })
        .sort({ isAnswer: -1 })
        .sort({ createdAt: 1 })
        .skip(pageNo * pageSize)
        .limit(pageSize);
      return {
        results: response,
        pageNo: response.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: response.length === pageSize ? true : false,
      };
    },
    articleComment: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentCollection,
        articleCommentSchema
      );
      return await model.findById(id);
    },
  },

  ArticleCommentFeedback: {
    articleComment: async (parent, _, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentCollection,
        articleCommentSchema
      );
      return await model.findById(parent.commentId);
    },
  },

  Mutation: {
    updateArticleComment: async (_, { payload }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentCollection,
        articleCommentSchema
      );

      let id = payload.id;

      if (!payload.id) {
        const articleModel = getCollection(
          asset,
          articleCollection,
          articleSchema
        );
        await articleModel.findByIdAndUpdate(
          payload.articleId,
          { $inc: { comments: 1 } },
          { new: true }
        );
        const response = await new model({
          ...payload,
          createdBy: user.userId,
        }).save();
        id = response.id;
      }

      const parentFields = { parentId: payload.parentId || id };
      if (!payload.id) {
        const parentComment = await model.findById(payload.parentId);
        if (parentComment) {
          parentFields.rootParentId = parentComment.rootParentId;
        } else {
          parentFields.rootParentId = parentFields.parentId;
        }
      }

      return await model.findByIdAndUpdate(
        id,
        {
          ...payload,
          ...parentFields,
          updatedBy: user.userId,
        },
        {
          new: true,
        }
      );
    },
    markArticleCommentAsAnswer: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentCollection,
        articleCommentSchema
      );

      const response = await model.findByIdAndUpdate(
        id,
        {
          isAnswer: true,
          updatedBy: user.userId,
        },
        {
          new: true,
        }
      );

      await model.updateMany(
        { $and: [{ articleId: response.articleId }, { _id: { $ne: id } }] },
        {
          $set: {
            isAnswer: false,
          },
        },
        {
          new: true,
        }
      );

      const articleModel = getCollection(
        asset,
        articleCollection,
        articleSchema
      );
      await articleModel.findByIdAndUpdate(
        response.articleId,
        { isAnswered: true, answeredOn: new Date() },
        { new: true }
      );

      return response;
    },
    unmarkArticleCommentAsAnswer: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleCommentCollection,
        articleCommentSchema
      );

      const response = await model.findByIdAndUpdate(
        id,
        {
          isAnswer: false,
          updatedBy: user.userId,
        },
        {
          new: true,
        }
      );

      const articleModel = getCollection(
        asset,
        articleCollection,
        articleSchema
      );
      await articleModel.findByIdAndUpdate(
        response.articleId,
        { isAnswered: false, answeredOn: null },
        { new: true }
      );

      return response;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/article/comment/model.js":
/*!**********************************************!*\
  !*** ./src/modules/article/comment/model.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const articleCommentSchema = new Schema(
  {
    text: { type: String },
    parentId: { type: String },
    rootParentId: { type: String },
    articleId: { type: String },
    helpful: { type: Number, default: 0 },
    notHelpful: { type: Number, default: 0 },
    isAnswer: { type: Boolean, default: false },
    createdBy: { type: String },
    updatedBy: { type: String },
  },
  { timestamps: true }
);

const articleCommentCollection = "article.comment";

// module.exports = mongoose.model('bookmarks', postSchema);
module.exports = { articleCommentSchema, articleCommentCollection };


/***/ }),

/***/ "./src/modules/article/feedback/index.js":
/*!***********************************************!*\
  !*** ./src/modules/article/feedback/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { articleFeedbackSchema, articleFeedbackCollection } = __webpack_require__(/*! ./model */ "./src/modules/article/feedback/model.js");
const { articleSchema, articleCollection } = __webpack_require__(/*! ../model */ "./src/modules/article/model.js");
const { getCollection } = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    articleFeedback(articleId: ID!): [ArticleFeedback]
  }

  extend type Mutation {
    addArticleFeedback(articleId: String!, type: String!): ArticleFeedback
    removeArticleFeedback(articleId: String!, type: String!): ArticleFeedback
  }

  type ArticleFeedback {
    id: ID!
    type: String
  }

  extend type Article {
    feedback: [ArticleFeedback]
  }
`;

const resolvers = {
  Query: {
    articleFeedback: async (_, { articleId }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleFeedbackCollection,
        articleFeedbackSchema
      );
      return await model.find({ articleId: articleId, userId: user.userId });
    },
  },

  Article: {
    feedback: {
      resolve: async (parent, _args, { asset, user }) => {
        if (!asset || !user) {
          return new AuthenticationError(
            "Not authorized to access this content"
          );
        }
        const model = getCollection(
          asset,
          articleFeedbackCollection,
          articleFeedbackSchema
        );
        return await model.find({ articleId: parent.id, userId: user.userId });
      },
    },
  },

  Mutation: {
    addArticleFeedback: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleFeedbackCollection,
        articleFeedbackSchema
      );
      const response = await model.findOneAndUpdate(
        { articleId: args.articleId, userId: user.userId, type: args.type },
        { articleId: args.articleId, userId: user.userId, type: args.type },
        { upsert: true, new: true, rawResult: true }
      );
      if (!response.lastErrorObject.updatedExisting) {
        const articleModel = getCollection(
          asset,
          articleCollection,
          articleSchema
        );
        await articleModel.findByIdAndUpdate(
          args.articleId,
          {
            $inc: { [args.type]: 1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
    removeArticleFeedback: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleFeedbackCollection,
        articleFeedbackSchema
      );
      const response = await model.findOneAndDelete(
        { articleId: args.articleId, userId: user.userId, type: args.type },
        {
          rawResult: true,
        }
      );
      if (response.lastErrorObject.n > 0) {
        const articleModel = getCollection(
          asset,
          articleCollection,
          articleSchema
        );
        await articleModel.findByIdAndUpdate(
          args.articleId,
          {
            $inc: { [args.type]: -1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/article/feedback/model.js":
/*!***********************************************!*\
  !*** ./src/modules/article/feedback/model.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const articleFeedbackSchema = new Schema(
  {
    articleId: { type: String },
    type: { type: String },
    userId: { type: String },
  },
  { timestamps: true }
);

const articleFeedbackCollection = 'article.feedback';

module.exports = { articleFeedbackSchema, articleFeedbackCollection };


/***/ }),

/***/ "./src/modules/article/index.js":
/*!**************************************!*\
  !*** ./src/modules/article/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { GraphQLScalarType } = __webpack_require__(/*! graphql */ "graphql");
const { articleSchema, articleCollection } = __webpack_require__(/*! ./model */ "./src/modules/article/model.js");
const { articleTagSchema, articleTagCollection } = __webpack_require__(/*! ./tag/model */ "./src/modules/article/tag/model.js");
const { categorySchema, categoryCollection } = __webpack_require__(/*! ./category/model */ "./src/modules/article/category/model.js");
const { getCollection } = __webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  scalar DateScalar
  extend type Query {
    article(id: ID!): Article
    articles(categoryId: ID!, pageSize: Int, pageNo: Int): ArticlePaginated
    searchArticles(text: String, pageSize: Int, pageNo: Int): ArticlePaginated
    getArticles(
      text: String
      categoryId: String
      pageSize: Int
      pageNo: Int
    ): ArticlePaginated
  }

  extend type Mutation {
    addArticle(payload: ArticlePayload): Article
    deleteArticle(id: ID!): Article
  }

  input ArticlePayload {
    id: String
    title: JSON
    description: JSON
    categoryId: String
    addTags: [String]
    removeTags: [String]
  }

  type ArticlePaginated {
    pageNo: Int
    hasMore: Boolean
    total: Int
    results: [Article]!
  }

  type Article {
    id: ID!
    title: JSON
    description: JSON
    views: Int!
    comments: Int!
    isAnswered: Boolean!
    answeredOn: DateScalar
    helpful: Int!
    notHelpful: Int!
    createdAt: DateScalar
    updatedAt: DateScalar
  }

  extend type ArticleFeedback {
    article: Article
  }
  extend type ArticleTag {
    article: Article
  }
  extend type ArticleComment {
    article: Article
  }
`;

const resolvers = {
  DateScalar: new GraphQLScalarType({
    name: "DateScalar",
    description: "Date custom scalar type",
    parseValue(value) {
      return new Date(value); // value from the client
    },
    serialize(value) {
      return value.getTime(); // value sent to the client
    },
    parseLiteral(ast) {
      if (ast.kind === Kind.INT) {
        return new Date(+ast.value); // ast value is always in string format
      }
      return null;
    },
  }),
  Query: {
    article: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, articleCollection, articleSchema);
      response = await model.findByIdAndUpdate(
        id,
        { $inc: { views: 1 } },
        { new: true }
      );
      return response;
    },
    articles: async (
      _,
      { categoryId, pageSize = 0, pageNo = 0 },
      { asset, user }
    ) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      if (!categoryId) {
        return {
          results: [],
          pageNo: 0,
          hasMore: false,
        };
      }
      const model = getCollection(asset, articleCollection, articleSchema);
      const response = await model
        .find({ categoryId: categoryId })
        .skip(pageNo * pageSize)
        .limit(pageSize);
      return {
        results: response,
        pageNo: response.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: response.length === pageSize ? true : false,
      };
    },
    searchArticles: async (
      _,
      { text, pageSize = 0, pageNo = 0 },
      { asset, user }
    ) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      if (!text) {
        return {
          results: [],
          pageNo: 0,
          hasMore: false,
          total: 0,
        };
      }
      const model = getCollection(asset, articleCollection, articleSchema);
      const res = await model
        .find({
          $or: [
            { description: { $regex: new RegExp(text, "ig") } },
            { title: { $regex: new RegExp(text, "ig") } },
          ],
        })
        .skip(pageNo * pageSize)
        .limit(pageSize);

      return {
        results: res,
        pageNo: res.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: res.length === pageSize ? true : false,
      };
    },
    getArticles: async (
      _,
      { text, categoryId, pageSize = 0, pageNo = 0 },
      { asset, user }
    ) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, articleCollection, articleSchema);
      let res = [];
      if (text) {
        res = await model
          .find({
            $or: [
              { description: { $regex: new RegExp(text, "ig") } },
              { title: { $regex: new RegExp(text, "ig") } },
            ],
          })
          .skip(pageNo * pageSize)
          .limit(pageSize);
      } else if (categoryId) {
        res = await model
          .find({ categoryId: categoryId })
          .skip(pageNo * pageSize)
          .limit(pageSize);
      } else {
        res = await model
          .find()
          .skip(pageNo * pageSize)
          .limit(pageSize);
      }

      // return {
      //   results: [],
      //   pageNo: 0,
      //   hasMore: false,
      //   total: 0,
      // };
      return {
        results: res,
        pageNo: res.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: res.length === pageSize ? true : false,
      };
    },
  },

  ArticleFeedback: {
    article: async (parent, _, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, articleCollection, articleSchema);
      return await model.findById(parent.articleId);
    },
  },

  ArticleTag: {
    article: async (parent, _, { asset, user }) => {
      const model = getCollection(asset, articleCollection, articleSchema);
      return await model.findById(parent.articleId);
    },
  },

  ArticleComment: {
    article: async (parent, _, { asset, user }) => {
      const model = getCollection(asset, articleCollection, articleSchema);
      return await model.findById(parent.articleId);
    },
  },

  Mutation: {
    addArticle: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, articleCollection, articleSchema);
      const tagModel = getCollection(
        asset,
        articleTagCollection,
        articleTagSchema
      );
      let articleResponse;

      if (args.payload.id) {
        existingArticle = await model.findById(args.payload.id);
        if (existingArticle.categoryId !== args.payload.categoryId) {
          const categoryModel = getCollection(
            asset,
            categoryCollection,
            categorySchema
          );
          await categoryModel.findByIdAndUpdate(
            existingArticle.categoryId,
            { $inc: { articles: -1 } },
            { new: true }
          );
          await categoryModel.findByIdAndUpdate(
            args.payload.categoryId,
            { $inc: { articles: 1 } },
            { new: true }
          );
        }
        articleResponse = await model.findByIdAndUpdate(
          args.payload.id,
          args.payload,
          { new: true }
        );
      } else {
        const data = new model(args.payload);
        articleResponse = await data.save();
        const categoryModel = getCollection(
          asset,
          categoryCollection,
          categorySchema
        );
        await categoryModel.findByIdAndUpdate(
          args.payload.categoryId,
          { $inc: { articles: 1 } },
          { new: true }
        );
      }

      args.payload.addTags.forEach(async (item) => {
        const data = new tagModel({
          name: item,
          articleId: articleResponse._id,
        });
        await data.save();
      });

      args.payload.removeTags.forEach(async (item) => {
        await tagModel.deleteMany({
          articleId: articleResponse._id,
          name: item,
        });
      });

      // const categoryStat = await model.aggregate([
      //   {
      //     $group: {
      //       _id: '$categoryId',
      //       count: { $sum: 1 },
      //     },
      //   },
      // ]);

      return articleResponse;
    },
    deleteArticle: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, articleCollection, articleSchema);
      const tagModel = getCollection(
        asset,
        articleTagCollection,
        articleTagSchema
      );

      const res = await model.findByIdAndDelete(id);

      await tagModel.deleteMany({
        articleId: id,
      });

      return res;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/article/model.js":
/*!**************************************!*\
  !*** ./src/modules/article/model.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const articleSchema = new Schema(
  {
    title: { type: Array },
    description: { type: Array },
    categoryId: { type: String },
    views: { type: Number, default: 0 },
    comments: { type: Number, default: 0 },
    isAnswered: { type: Boolean, default: false },
    answeredOn: { type: Date },
    helpful: { type: Number, default: 0 },
    notHelpful: { type: Number, default: 0 },
  },
  { timestamps: true }
);

const articleCollection = "article";

// module.exports = mongoose.model('bookmarks', articleSchema);
module.exports = { articleSchema, articleCollection };


/***/ }),

/***/ "./src/modules/article/tag/index.js":
/*!******************************************!*\
  !*** ./src/modules/article/tag/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { articleTagSchema, articleTagCollection } = __webpack_require__(/*! ./model */ "./src/modules/article/tag/model.js");
const { getCollection } = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    articleTagCloud: [ArticleTagCloud]
    articlesByTag(tag: String!, pageSize: Int, pageNo: Int): ArticleTagPaginated
  }

  type ArticleTagPaginated {
    pageNo: Int
    hasMore: Boolean
    total: Int
    results: [ArticleTag]!
  }

  type ArticleTagCloud {
    name: String
    count: Int
  }

  type ArticleTag {
    id: ID!
    name: String
  }

  extend type Article {
    tags: [ArticleTag]
  }
`;

const resolvers = {
  Query: {
    articleTagCloud: async (_, __, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        articleTagCollection,
        articleTagSchema
      );
      return await model.aggregate([
        {
          $group: {
            _id: "$name",
            count: { $sum: 1 },
          },
        },
        {
          $project: {
            name: "$_id",
            count: "$count",
          },
        },
      ]);
    },
    articlesByTag: async (
      _,
      { tag, pageSize = 0, pageNo = 0 },
      { asset, user }
    ) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      if (!tag) {
        return {
          results: [],
          pageNo: 0,
          hasMore: false,
        };
      }
      const model = getCollection(
        asset,
        articleTagCollection,
        articleTagSchema
      );
      const response = await model
        .find({ name: tag })
        .skip(pageNo * pageSize)
        .limit(pageSize);
      return {
        results: response,
        pageNo: response.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: response.length === pageSize ? true : false,
      };
    },
    // tags: async (_, __, { user }) => {
    //   // if (!user) {
    //   //   return new AuthenticationError('Not authorized to access this content');
    //   // }
    //   const model = getCollection(210, articleTagCollection, articleTagSchema);
    //   return await model.find({});
    // },
  },

  Article: {
    tags: {
      resolve: async (parent, _args, { asset, user }, info) => {
        if (!asset || !user) {
          return new AuthenticationError(
            "Not authorized to access this content"
          );
        }
        const model = getCollection(
          asset,
          articleTagCollection,
          articleTagSchema
        );
        return await model.find({ articleId: parent.id });
      },
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/article/tag/model.js":
/*!******************************************!*\
  !*** ./src/modules/article/tag/model.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const articleTagSchema = new Schema(
  {
    name: { type: String },
    articleId: { type: String },
  },
  { timestamps: true }
);

const articleTagCollection = 'article.tag';

// module.exports = mongoose.model('bookmarks', articleSchema);
module.exports = { articleTagSchema, articleTagCollection };


/***/ }),

/***/ "./src/modules/asset/index.js":
/*!************************************!*\
  !*** ./src/modules/asset/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { assetCollection, assetSchema } = __webpack_require__(/*! ./model */ "./src/modules/asset/model.js");
const { getGlobalCollection } = __webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts");
const { isUnauthorized } = __webpack_require__(/*! ../../lib/authutils */ "./src/lib/authutils.js");
const { nextval } = __webpack_require__(/*! ../sequence/service */ "./src/modules/sequence/service.ts");

const typeDefs = gql`
  extend type Query {
    asset(assetId: String!): Asset
    assetById(id: ID!): Asset
    assets: [Asset]
  }

  extend type Mutation {
    updateAsset(payload: AssetPayload): Asset
    createAsset(payload: AssetPayload, addition: AssetAdditionPayload): Asset
  }

  input AssetPayload {
    id: String
    name: String
    section: JSON
    featuredTitle: String
    featuredSubtitle: String
    hero: JSON
    jwtPassword: String
    productionMode: Boolean
  }

  input AssetAdditionPayload {
    email: String
  }

  type Asset {
    id: ID!
    name: String
    section: JSON
    featuredTitle: String
    featuredSubtitle: String
    hero: JSON
    jwtPassword: String
    productionMode: Boolean
    assetId: String
  }
`;

const resolvers = {
  Query: {
    asset: async (_, { assetId }, { user }) => {
      // if (!user) {
      //   return new AuthenticationError('Not authorized to access this content');
      // }
      const model = getGlobalCollection(assetCollection, assetSchema);
      return await model.findOne({ assetId });
    },
    assets: async () => {
      // if (!user) {
      //   return new AuthenticationError('Not authorized to access this content');
      // }
      const model = getGlobalCollection(assetCollection, assetSchema);
      return await model.find();
    },
  },

  Mutation: {
    updateAsset: async (_, args, { user }) => {
      const model = getGlobalCollection(assetCollection, assetSchema);
      if (args.payload.id) {
        return await model.findByIdAndUpdate(args.payload.id, args.payload, {
          new: true,
        });
      } else if (args.payload.assetId) {
        return await model.findOneAndUpdate(
          { assetId: args.payload.assetId },
          args.payload,
          {
            new: true,
          }
        );
      } else {
        const data = new model({
          ...args.payload,
          assetId: `a${await nextval("assetId")}`,
        });
        return await data.save();
      }
    },
    createAsset: async (_, { payload, addition }, { user }) => {
      const model = getGlobalCollection(assetCollection, assetSchema);
      const data = new model({
        ...payload,
        assetId: `a${await nextval("assetId")}`,
      });
      console.log(
        `user account needs to be setup for ${addition.email} in ${payload.name}`
      );
      return await data.save();
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/asset/model.js":
/*!************************************!*\
  !*** ./src/modules/asset/model.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const assetSchema = new Schema(
  {
    name: { type: String },
    section: { type: Array },
    featuredTitle: { type: String },
    featuredSubtitle: { type: String },
    jwtPassword: { type: String },
    productionMode: { type: Boolean, default: false },
    assetId: { type: String },
    hero: { type: Object },
  },
  { timestamps: true }
);

const assetCollection = "asset";

module.exports = { assetSchema, assetCollection };


/***/ }),

/***/ "./src/modules/gql-scalar/index.js":
/*!*****************************************!*\
  !*** ./src/modules/gql-scalar/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const GraphQLJSON = __webpack_require__(/*! graphql-type-json */ "graphql-type-json");

const typeDefs = gql`
  scalar JSON
`;

const resolvers = {
  JSON: GraphQLJSON,
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/post/comment/feedback/index.js":
/*!****************************************************!*\
  !*** ./src/modules/post/comment/feedback/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const {
  postCommentFeedbackSchema,
  postCommentFeedbackCollection,
} = __webpack_require__(/*! ./model */ "./src/modules/post/comment/feedback/model.js");
const { postCommentSchema, postCommentCollection } = __webpack_require__(/*! ../model */ "./src/modules/post/comment/model.js");
const { getCollection } = __webpack_require__(/*! ../../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    postCommentFeedback(commentId: ID!): [PostCommentFeedback]
  }

  extend type Mutation {
    addPostCommentFeedback(
      commentId: String!
      type: String!
    ): PostCommentFeedback
    removePostCommentFeedback(
      commentId: String!
      type: String!
    ): PostCommentFeedback
  }

  type PostCommentFeedback {
    id: ID!
    type: String
  }

  extend type PostComment {
    feedback: [PostCommentFeedback]
  }
`;

const resolvers = {
  Query: {
    postCommentFeedback: async (_, { commentId }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentFeedbackCollection,
        postCommentFeedbackSchema
      );
      return await model.find({ commentId: commentId, userId: user.userId });
    },
  },

  PostComment: {
    feedback: {
      resolve: async (parent, _args, { asset, user }) => {
        if (!asset || !user) {
          return new AuthenticationError(
            "Not authorized to access this content"
          );
        }
        const model = getCollection(
          asset,
          postCommentFeedbackCollection,
          postCommentFeedbackSchema
        );
        return await model.find({ commentId: parent.id, userId: user.userId });
      },
    },
  },

  Mutation: {
    addPostCommentFeedback: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentFeedbackCollection,
        postCommentFeedbackSchema
      );
      const response = await model.findOneAndUpdate(
        { commentId: args.commentId, userId: user.userId, type: args.type },
        { commentId: args.commentId, userId: user.userId, type: args.type },
        { upsert: true, new: true, rawResult: true }
      );
      if (!response.lastErrorObject.updatedExisting) {
        const postCommentModel = getCollection(
          asset,
          postCommentCollection,
          postCommentSchema
        );
        await postCommentModel.findByIdAndUpdate(
          args.commentId,
          {
            $inc: { [args.type]: 1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
    removePostCommentFeedback: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentFeedbackCollection,
        postCommentFeedbackSchema
      );
      const response = await model.findOneAndDelete(
        { commentId: args.commentId, userId: user.userId, type: args.type },
        {
          rawResult: true,
        }
      );
      if (response.lastErrorObject.n > 0) {
        const postCommentModel = getCollection(
          asset,
          postCommentCollection,
          postCommentSchema
        );
        await postCommentModel.findByIdAndUpdate(
          args.commentId,
          {
            $inc: { [args.type]: -1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/post/comment/feedback/model.js":
/*!****************************************************!*\
  !*** ./src/modules/post/comment/feedback/model.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const postCommentFeedbackSchema = new Schema(
  {
    commentId: { type: String },
    type: { type: String },
    userId: { type: String },
  },
  { timestamps: true }
);

const postCommentFeedbackCollection = 'post.comment.feedback';

module.exports = { postCommentFeedbackSchema, postCommentFeedbackCollection };


/***/ }),

/***/ "./src/modules/post/comment/index.js":
/*!*******************************************!*\
  !*** ./src/modules/post/comment/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { postCommentSchema, postCommentCollection } = __webpack_require__(/*! ./model */ "./src/modules/post/comment/model.js");
const { postSchema, postCollection } = __webpack_require__(/*! ../model */ "./src/modules/post/model.js");
const { getCollection } = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    postComments(
      postId: String!
      pageSize: Int
      pageNo: Int
    ): PostCommentPaginated
    postComment(id: ID!): PostComment
  }

  extend type Mutation {
    updatePostComment(payload: PostCommentPayload!): PostComment
    markPostCommentAsAnswer(id: ID!): PostComment
    unmarkPostCommentAsAnswer(id: ID!): PostComment
  }

  type PostCommentPaginated {
    pageNo: Int
    hasMore: Boolean
    total: Int
    results: [PostComment]!
  }

  input PostCommentPayload {
    id: ID
    text: String
    parentId: String
    postId: String!
  }

  type PostComment {
    id: ID!
    text: String
    parentId: String
    helpful: Int
    notHelpful: Int
    isAnswer: Boolean
    createdBy: String
    updatedBy: String
    createdAt: DateScalar
    updatedAt: DateScalar
  }

  extend type PostCommentFeedback {
    postComment: PostComment
  }
`;

const resolvers = {
  Query: {
    postComments: async (
      _,
      { postId, pageSize = 0, pageNo = 0 },
      { asset, user }
    ) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentCollection,
        postCommentSchema
      );
      const response = await model
        .find({ postId: postId })
        // .sort({ rootParentId: 1, parentId: 1, createdAt: 1 })
        .sort({ isAnswer: -1 })
        .sort({ createdAt: 1 })
        .skip(pageNo * pageSize)
        .limit(pageSize);
      return {
        results: response,
        pageNo: response.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: response.length === pageSize ? true : false,
      };
    },
    postComment: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentCollection,
        postCommentSchema
      );
      return await model.findById(id);
    },
  },

  PostCommentFeedback: {
    postComment: async (parent, _, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentCollection,
        postCommentSchema
      );
      return await model.findById(parent.commentId);
    },
  },

  Mutation: {
    updatePostComment: async (_, { payload }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentCollection,
        postCommentSchema
      );

      let id = payload.id;

      if (!payload.id) {
        const postModel = getCollection(asset, postCollection, postSchema);
        await postModel.findByIdAndUpdate(
          payload.postId,
          { $inc: { comments: 1 } },
          { new: true }
        );
        const response = await new model({
          ...payload,
          createdBy: user.userId,
        }).save();
        id = response.id;
      }

      const parentFields = { parentId: payload.parentId || id };
      if (!payload.id) {
        const parentComment = await model.findById(payload.parentId);
        if (parentComment) {
          parentFields.rootParentId = parentComment.rootParentId;
        } else {
          parentFields.rootParentId = parentFields.parentId;
        }
      }

      return await model.findByIdAndUpdate(
        id,
        {
          ...payload,
          ...parentFields,
          updatedBy: user.userId,
        },
        {
          new: true,
        }
      );
    },
    markPostCommentAsAnswer: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentCollection,
        postCommentSchema
      );

      const response = await model.findByIdAndUpdate(
        id,
        {
          isAnswer: true,
          updatedBy: user.userId,
        },
        {
          new: true,
        }
      );

      await model.updateMany(
        { $and: [{ postId: response.postId }, { _id: { $ne: id } }] },
        {
          $set: {
            isAnswer: false,
          },
        },
        {
          new: true,
        }
      );

      const postModel = getCollection(asset, postCollection, postSchema);
      await postModel.findByIdAndUpdate(
        response.postId,
        { isAnswered: true, answeredOn: new Date() },
        { new: true }
      );

      return response;
    },
    unmarkPostCommentAsAnswer: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postCommentCollection,
        postCommentSchema
      );

      const response = await model.findByIdAndUpdate(
        id,
        {
          isAnswer: false,
          updatedBy: user.userId,
        },
        {
          new: true,
        }
      );

      const postModel = getCollection(asset, postCollection, postSchema);
      await postModel.findByIdAndUpdate(
        response.postId,
        { isAnswered: false, answeredOn: null },
        { new: true }
      );

      return response;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/post/comment/model.js":
/*!*******************************************!*\
  !*** ./src/modules/post/comment/model.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const postCommentSchema = new Schema(
  {
    text: { type: String },
    parentId: { type: String },
    rootParentId: { type: String },
    postId: { type: String },
    helpful: { type: Number, default: 0 },
    notHelpful: { type: Number, default: 0 },
    isAnswer: { type: Boolean, default: false },
    createdBy: { type: String },
    updatedBy: { type: String },
  },
  { timestamps: true }
);

const postCommentCollection = 'post.comment';

// module.exports = mongoose.model('bookmarks', postSchema);
module.exports = { postCommentSchema, postCommentCollection };


/***/ }),

/***/ "./src/modules/post/feedback/index.js":
/*!********************************************!*\
  !*** ./src/modules/post/feedback/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { postFeedbackSchema, postFeedbackCollection } = __webpack_require__(/*! ./model */ "./src/modules/post/feedback/model.js");
const { postSchema, postCollection } = __webpack_require__(/*! ../model */ "./src/modules/post/model.js");
const { getCollection } = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    postFeedback(postId: ID!): [PostFeedback]
  }

  extend type Mutation {
    addPostFeedback(postId: String!, type: String!): PostFeedback
    removePostFeedback(postId: String!, type: String!): PostFeedback
  }

  type PostFeedback {
    id: ID!
    type: String
  }

  extend type Post {
    feedback: [PostFeedback]
  }
`;

const resolvers = {
  Query: {
    postFeedback: async (_, { postId }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postFeedbackCollection,
        postFeedbackSchema
      );
      return await model.find({ postId: postId, userId: user.userId });
    },
  },

  Post: {
    feedback: {
      resolve: async (parent, _args, { asset, user }) => {
        if (!asset || !user) {
          return new AuthenticationError(
            "Not authorized to access this content"
          );
        }
        const model = getCollection(
          asset,
          postFeedbackCollection,
          postFeedbackSchema
        );
        return await model.find({ postId: parent.id, userId: user.userId });
      },
    },
  },

  Mutation: {
    addPostFeedback: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postFeedbackCollection,
        postFeedbackSchema
      );
      const response = await model.findOneAndUpdate(
        { postId: args.postId, userId: user.userId, type: args.type },
        { postId: args.postId, userId: user.userId, type: args.type },
        { upsert: true, new: true, rawResult: true }
      );
      if (!response.lastErrorObject.updatedExisting) {
        const postModel = getCollection(asset, postCollection, postSchema);
        await postModel.findByIdAndUpdate(
          args.postId,
          {
            $inc: { [args.type]: 1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
    removePostFeedback: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postFeedbackCollection,
        postFeedbackSchema
      );
      const response = await model.findOneAndDelete(
        { postId: args.postId, userId: user.userId, type: args.type },
        {
          rawResult: true,
        }
      );
      if (response.lastErrorObject.n > 0) {
        const postModel = getCollection(asset, postCollection, postSchema);
        await postModel.findByIdAndUpdate(
          args.postId,
          {
            $inc: { [args.type]: -1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/post/feedback/model.js":
/*!********************************************!*\
  !*** ./src/modules/post/feedback/model.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const postFeedbackSchema = new Schema(
  {
    postId: { type: String },
    type: { type: String },
    userId: { type: String },
  },
  { timestamps: true }
);

const postFeedbackCollection = 'post.feedback';

module.exports = { postFeedbackSchema, postFeedbackCollection };


/***/ }),

/***/ "./src/modules/post/follower/index.js":
/*!********************************************!*\
  !*** ./src/modules/post/follower/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { postFollowerSchema, postFollowerCollection } = __webpack_require__(/*! ./model */ "./src/modules/post/follower/model.js");
const { postSchema, postCollection } = __webpack_require__(/*! ./../model */ "./src/modules/post/model.js");
const { getCollection } = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  type PostFollower {
    id: ID!
    userId: String
    postId: String
  }

  extend type Post {
    followerList: [PostFollower]
  }

  extend type Mutation {
    followPost(postId: String!): PostFollower
    unfollowPost(postId: String!): PostFollower
  }
`;

const resolvers = {
  Post: {
    followerList: {
      resolve: async (parent, _args, { asset, user }, info) => {
        if (!asset || !user) {
          return new AuthenticationError(
            "Not authorized to access this content"
          );
        }
        const model = getCollection(
          asset,
          postFollowerCollection,
          postFollowerSchema
        );
        return await model.find({ postId: parent.id });
      },
    },
  },

  Mutation: {
    followPost: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postFollowerCollection,
        postFollowerSchema
      );
      const response = await model.findOneAndUpdate(
        { postId: args.postId, userId: user.userId },
        { postId: args.postId, userId: user.userId },
        { upsert: true, new: true, rawResult: true }
      );
      if (!response.lastErrorObject.updatedExisting) {
        const postModel = getCollection(asset, postCollection, postSchema);
        await postModel.findByIdAndUpdate(
          args.postId,
          {
            $inc: { followers: 1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
    unfollowPost: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(
        asset,
        postFollowerCollection,
        postFollowerSchema
      );
      const response = await model.findOneAndDelete(
        { postId: args.postId, userId: user.userId },
        {
          rawResult: true,
        }
      );
      if (response.lastErrorObject.n > 0) {
        const postModel = getCollection(asset, postCollection, postSchema);
        await postModel.findByIdAndUpdate(
          args.postId,
          {
            $inc: { followers: -1 },
          },
          { new: true }
        );
      }
      return response.value;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/post/follower/model.js":
/*!********************************************!*\
  !*** ./src/modules/post/follower/model.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const postFollowerSchema = new Schema(
  {
    postId: { type: String },
    userId: { type: String },
  },
  { timestamps: true }
);

const postFollowerCollection = 'post.follower';

// module.exports = mongoose.model('bookmarks', postSchema);
module.exports = { postFollowerSchema, postFollowerCollection };


/***/ }),

/***/ "./src/modules/post/index.js":
/*!***********************************!*\
  !*** ./src/modules/post/index.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { GraphQLScalarType } = __webpack_require__(/*! graphql */ "graphql");
const { postSchema, postCollection } = __webpack_require__(/*! ./model */ "./src/modules/post/model.js");
const { postTagSchema, postTagCollection } = __webpack_require__(/*! ./tag/model */ "./src/modules/post/tag/model.js");
const {
  postFollowerSchema,
  postFollowerCollection,
} = __webpack_require__(/*! ./follower/model */ "./src/modules/post/follower/model.js");
const { getCollection } = __webpack_require__(/*! ../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    post(id: ID!): Post
    posts(pageSize: Int, pageNo: Int): PostPaginated
    searchPosts(text: String, pageSize: Int, pageNo: Int): PostPaginated
    myPosts(pageSize: Int, pageNo: Int): PostPaginated
  }

  extend type Mutation {
    addPost(payload: PostPayload): Post
    deletePost(id: ID!): Post
  }

  input PostPayload {
    id: String
    title: String
    description: String
    addTags: [String]
    removeTags: [String]
  }

  type PostPaginated {
    pageNo: Int
    hasMore: Boolean
    total: Int
    results: [Post]!
  }

  type Post {
    id: ID!
    title: String
    description: String
    views: Int!
    comments: Int!
    isAnswered: Boolean!
    answeredOn: DateScalar
    followers: Int!
    helpful: Int!
    notHelpful: Int!
    createdAt: DateScalar
    updatedAt: DateScalar
    createdBy: String
    updatedBy: String
  }

  extend type PostFeedback {
    post: Post
  }
  extend type PostTag {
    post: Post
  }
  extend type PostFollower {
    post: Post
  }
  extend type PostComment {
    post: Post
  }
`;

const resolvers = {
  Query: {
    post: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, postCollection, postSchema);
      response = await model.findByIdAndUpdate(
        id,
        { $inc: { views: 1 } },
        { new: true }
      );
      return response;
    },
    posts: async (_, { pageSize = 0, pageNo = 0 }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, postCollection, postSchema);
      const response = await model
        .find({})
        .skip(pageNo * pageSize)
        .limit(pageSize);
      return {
        results: response,
        pageNo: response.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: response.length === pageSize ? true : false,
      };
    },
    searchPosts: async (
      _,
      { text, pageSize = 0, pageNo = 0 },
      { asset, user }
    ) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      if (!text) {
        return {
          results: [],
          pageNo: 0,
          hasMore: false,
          total: 0,
        };
      }
      const model = getCollection(asset, postCollection, postSchema);
      const res = await model
        .find({
          $or: [
            { description: { $regex: new RegExp(text, "ig") } },
            { title: { $regex: new RegExp(text, "ig") } },
          ],
        })
        .skip(pageNo * pageSize)
        .limit(pageSize);

      return {
        results: res,
        pageNo: res.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: res.length === pageSize ? true : false,
      };
    },
    myPosts: async (_, { pageSize = 0, pageNo = 0 }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, postCollection, postSchema);
      const res = await model
        .find({
          createdBy: user.userId,
        })
        .skip(pageNo * pageSize)
        .limit(pageSize);

      return {
        results: res,
        pageNo: res.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: res.length === pageSize ? true : false,
      };
    },
  },

  PostFeedback: {
    post: async (parent, _, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, postCollection, postSchema);
      return await model.findById(parent.postId);
    },
  },

  PostTag: {
    post: async (parent, _, { asset, user }) => {
      const model = getCollection(asset, postCollection, postSchema);
      return await model.findById(parent.postId);
    },
  },

  PostFollower: {
    post: async (parent, _, { asset, user }) => {
      const model = getCollection(asset, postCollection, postSchema);
      return await model.findById(parent.postId);
    },
  },

  PostComment: {
    post: async (parent, _, { asset, user }) => {
      const model = getCollection(asset, postCollection, postSchema);
      return await model.findById(parent.postId);
    },
  },

  Mutation: {
    addPost: async (_, args, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, postCollection, postSchema);
      const tagModel = getCollection(asset, postTagCollection, postTagSchema);
      const followerModel = getCollection(
        asset,
        postFollowerCollection,
        postFollowerSchema
      );
      let postResponse;

      if (args.payload.id) {
        existingPost = await model.findById(args.payload.id);
        postResponse = await model.findByIdAndUpdate(
          args.payload.id,
          { ...args.payload, updatedBy: user.userId },
          { new: true }
        );
      } else {
        const data = new model({
          ...args.payload,
          followers: 1,
          createdBy: user.userId,
          updatedBy: user.userId,
        });
        postResponse = await data.save();

        await followerModel.findOneAndUpdate(
          { postId: postResponse.id, userId: user.userId },
          { postId: postResponse.id, userId: user.userId },
          { upsert: true, new: true, rawResult: true }
        );
      }

      args.payload.addTags.forEach(async (item) => {
        const data = new tagModel({
          name: item,
          postId: postResponse._id,
        });
        await data.save();
      });

      args.payload.removeTags.forEach(async (item) => {
        await tagModel.deleteMany({
          postId: postResponse._id,
          name: item,
        });
      });

      return postResponse;
    },
    deletePost: async (_, { id }, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, postCollection, postSchema);
      const tagModel = getCollection(asset, postTagCollection, postTagSchema);

      const res = await model.findByIdAndDelete(id);

      await tagModel.deleteMany({
        postId: id,
      });

      return res;
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/post/model.js":
/*!***********************************!*\
  !*** ./src/modules/post/model.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const postSchema = new Schema(
  {
    title: { type: String },
    description: { type: String },
    views: { type: Number, default: 0 },
    isAnswered: { type: Boolean, default: false },
    answeredOn: { type: Date },
    followers: { type: Number, default: 0 },
    comments: { type: Number, default: 0 },
    helpful: { type: Number, default: 0 },
    notHelpful: { type: Number, default: 0 },
    createdBy: { type: String },
    updatedBy: { type: String },
  },
  { timestamps: true }
);

const postCollection = 'post';

// module.exports = mongoose.model('bookmarks', postSchema);
module.exports = { postSchema, postCollection };


/***/ }),

/***/ "./src/modules/post/tag/index.js":
/*!***************************************!*\
  !*** ./src/modules/post/tag/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { gql, AuthenticationError } = __webpack_require__(/*! apollo-server-express */ "apollo-server-express");
const { postTagSchema, postTagCollection } = __webpack_require__(/*! ./model */ "./src/modules/post/tag/model.js");
const { getCollection } = __webpack_require__(/*! ../../../lib/dbutils */ "./src/lib/dbutils.ts");

const typeDefs = gql`
  extend type Query {
    postTagCloud: [PostTagCloud]
    postsByTag(tag: String!, pageSize: Int, pageNo: Int): PostTagPaginated
  }

  type PostTagPaginated {
    pageNo: Int
    hasMore: Boolean
    total: Int
    results: [PostTag]!
  }

  type PostTagCloud {
    name: String
    count: Int
  }

  type PostTag {
    id: ID!
    name: String
  }

  extend type Post {
    tags: [PostTag]
  }
`;

const resolvers = {
  Query: {
    postTagCloud: async (_, __, { asset, user }) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      const model = getCollection(asset, postTagCollection, postTagSchema);
      return await model.aggregate([
        {
          $group: {
            _id: "$name",
            count: { $sum: 1 },
          },
        },
        {
          $project: {
            name: "$_id",
            count: "$count",
          },
        },
      ]);
    },
    postsByTag: async (
      _,
      { tag, pageSize = 0, pageNo = 0 },
      { asset, user }
    ) => {
      if (!asset || !user) {
        return new AuthenticationError("Not authorized to access this content");
      }
      if (!tag) {
        return {
          results: [],
          pageNo: 0,
          hasMore: false,
        };
      }
      const model = getCollection(asset, postTagCollection, postTagSchema);
      const response = await model
        .find({ name: tag })
        .skip(pageNo * pageSize)
        .limit(pageSize);
      return {
        results: response,
        pageNo: response.length === pageSize ? pageNo + 1 : pageNo,
        hasMore: response.length === pageSize ? true : false,
      };
    },
    // tags: async (_, __, { user }) => {
    //   // if (!user) {
    //   //   return new AuthenticationError('Not authorized to access this content');
    //   // }
    //   const model = getCollection(210, postTagCollection, postTagSchema);
    //   return await model.find({});
    // },
  },

  Post: {
    tags: {
      resolve: async (parent, _args, { asset, user }, info) => {
        if (!asset || !user) {
          return new AuthenticationError(
            "Not authorized to access this content"
          );
        }
        const model = getCollection(asset, postTagCollection, postTagSchema);
        return await model.find({ postId: parent.id });
      },
    },
  },
};

module.exports = { typeDefs, resolvers };


/***/ }),

/***/ "./src/modules/post/tag/model.js":
/*!***************************************!*\
  !*** ./src/modules/post/tag/model.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const postTagSchema = new Schema(
  {
    name: { type: String },
    postId: { type: String },
  },
  { timestamps: true }
);

const postTagCollection = 'post.tag';

// module.exports = mongoose.model('bookmarks', postSchema);
module.exports = { postTagSchema, postTagCollection };


/***/ }),

/***/ "./src/modules/sequence/model.js":
/*!***************************************!*\
  !*** ./src/modules/sequence/model.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mongoose = __webpack_require__(/*! mongoose */ "mongoose");

const Schema = mongoose.Schema;
const sequenceSchema = new Schema(
  {
    field: { type: String },
    context: { type: String },
    nextval: { type: Number },
    factor: { type: Number },
  },
  { timestamps: true }
);

const sequenceCollection = 'sequence';

module.exports = { sequenceSchema, sequenceCollection };


/***/ }),

/***/ "aihub":
/*!************************!*\
  !*** external "aihub" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("aihub");

/***/ }),

/***/ "apollo-server-express":
/*!****************************************!*\
  !*** external "apollo-server-express" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("apollo-server-express");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("axios");

/***/ }),

/***/ "bcrypt":
/*!*************************!*\
  !*** external "bcrypt" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("bcrypt");

/***/ }),

/***/ "cors":
/*!***********************!*\
  !*** external "cors" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("cors");

/***/ }),

/***/ "date-fns":
/*!***************************!*\
  !*** external "date-fns" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("date-fns");

/***/ }),

/***/ "ejs":
/*!**********************!*\
  !*** external "ejs" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("ejs");

/***/ }),

/***/ "express":
/*!**************************!*\
  !*** external "express" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("express");

/***/ }),

/***/ "graphql":
/*!**************************!*\
  !*** external "graphql" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("graphql");

/***/ }),

/***/ "graphql-type-json":
/*!************************************!*\
  !*** external "graphql-type-json" ***!
  \************************************/
/***/ ((module) => {

"use strict";
module.exports = require("graphql-type-json");

/***/ }),

/***/ "handlebars":
/*!*****************************!*\
  !*** external "handlebars" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("handlebars");

/***/ }),

/***/ "jsonwebtoken":
/*!*******************************!*\
  !*** external "jsonwebtoken" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("jsonwebtoken");

/***/ }),

/***/ "jszip":
/*!************************!*\
  !*** external "jszip" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("jszip");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("lodash");

/***/ }),

/***/ "moment":
/*!*************************!*\
  !*** external "moment" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("moment");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("mongoose");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("multer");

/***/ }),

/***/ "papaparse":
/*!****************************!*\
  !*** external "papaparse" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("papaparse");

/***/ }),

/***/ "tesseract.js":
/*!*******************************!*\
  !*** external "tesseract.js" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("tesseract.js");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("uuid");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("8fe32a2061d96325b665")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = __webpack_require__.hmrS_require = __webpack_require__.hmrS_require || {
/******/ 			"main": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		
/******/ 		// no chunk loading
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var update = require("./" + __webpack_require__.hu(chunkId));
/******/ 			var updatedModules = update.modules;
/******/ 			var runtime = update.runtime;
/******/ 			for(var moduleId in updatedModules) {
/******/ 				if(__webpack_require__.o(updatedModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = updatedModules[moduleId];
/******/ 					if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.requireHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.require = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.require = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.requireHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = function() {
/******/ 			return Promise.resolve().then(function() {
/******/ 				return require("./" + __webpack_require__.hmrF());
/******/ 			})['catch'](function(err) { if(err.code !== 'MODULE_NOT_FOUND') throw err; });
/******/ 		}
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./node_modules/webpack/hot/poll.js?1000");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7OztVQ0FBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0Esc0JBQXNCO1VBQ3RCLG9EQUFvRCx1QkFBdUI7VUFDM0U7VUFDQTtVQUNBLEdBQUc7VUFDSDtVQUNBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOzs7OztXQ3hDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ0pBOzs7OztXQ0FBOzs7OztXQ0FBOzs7OztXQ0FBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxDQUFDOztXQUVEO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxLQUFLO1dBQ0w7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLDJCQUEyQjtXQUMzQiw0QkFBNEI7V0FDNUIsMkJBQTJCO1dBQzNCO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtX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RztXQUNIO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLG1CQUFtQiwyQkFBMkI7V0FDOUM7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTDtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0Esa0JBQWtCLGNBQWM7V0FDaEM7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBLGNBQWMsTUFBTTtXQUNwQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxjQUFjLGFBQWE7V0FDM0I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQSxpQkFBaUIsNEJBQTRCO1dBQzdDO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxJQUFJO1dBQ0o7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLElBQUk7V0FDSjs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7O1dBRUE7V0FDQTtXQUNBLGdCQUFnQiw0QkFBNEI7V0FDNUM7V0FDQTtXQUNBOztXQUVBO1dBQ0E7O1dBRUE7V0FDQTs7V0FFQTtXQUNBOztXQUVBO1dBQ0EsZ0JBQWdCLDRCQUE0QjtXQUM1QztXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxrQkFBa0IsdUNBQXVDO1dBQ3pEO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0EsbUJBQW1CLGlDQUFpQztXQUNwRDtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esc0JBQXNCLHVDQUF1QztXQUM3RDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxzQkFBc0Isc0JBQXNCO1dBQzVDO1dBQ0E7V0FDQSxTQUFTO1dBQ1Q7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFdBQVc7V0FDWCxXQUFXO1dBQ1g7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxZQUFZO1dBQ1o7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsVUFBVTtXQUNWO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFdBQVc7V0FDWDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBLG1CQUFtQix3Q0FBd0M7V0FDM0Q7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNO1dBQ047V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLFFBQVE7V0FDUixRQUFRO1dBQ1I7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsU0FBUztXQUNUO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLE9BQU87V0FDUDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsUUFBUTtXQUNSO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxFQUFFLElBQUk7V0FDTjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsSUFBSTtXQUNKO1dBQ0E7V0FDQSxFQUFFO1dBQ0Y7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0EsRUFBRSwyQkFBMkIsZ0RBQWdEO1dBQzdFOzs7OztVRTFkQTtVQUNBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9lbnYuanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvaGFuZGxlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9saWIvRGF0ZVV0aWxzLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL2xpYi9VdGlscy50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9saWIvZGJ1dGlscy50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9saWIvZ3B0dXRpbHMudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbGliL3ZhbGlkYXRpb24udHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbWFpbi50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9taWRkbGV3YXJlcy50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2F1dGgvaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYXV0aC9yb3V0ZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2F1dGgvc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svY2hhcHRlci9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2NoYXB0ZXIvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2NoYXB0ZXIvcHJvbXB0LnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9jaGFwdGVyL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9jaGFwdGVyL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2NvbmNlcHQvaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9jb25jZXB0L21vZGVsLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9jb25jZXB0L3Byb21wdC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svY29uY2VwdC9yb3V0ZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svY29uY2VwdC9zZXJ2aWNlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9jb25jZXB0ZGV0YWlsL2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svY29uY2VwdGRldGFpbC9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svY29uY2VwdGRldGFpbC9wcm9tcHQudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2NvbmNlcHRkZXRhaWwvcm91dGUudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2NvbmNlcHRkZXRhaWwvc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svZXh0cmFjdC9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2V4dHJhY3QvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2V4dHJhY3QvcHJvbXB0LnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9leHRyYWN0L3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9leHRyYWN0L3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2dvb2dsZV9ib29rX2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9sb2cvaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9sb2cvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL2xvZy9yb3V0ZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svbG9nL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL21vZGVsLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9wcm9tcHQudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9zZWN0aW9uL2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svc2VjdGlvbi9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svc2VjdGlvbi9wcm9tcHQudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3NlY3Rpb24vcm91dGUudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3NlY3Rpb24vc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svc2VjdGlvbmRldGFpbC9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3NlY3Rpb25kZXRhaWwvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3NlY3Rpb25kZXRhaWwvcHJvbXB0LnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9zZWN0aW9uZGV0YWlsL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9zZWN0aW9uZGV0YWlsL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3Nob3J0Zm9ybS9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3Nob3J0Zm9ybS9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svc2hvcnRmb3JtL3Byb21wdC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svc2hvcnRmb3JtL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9zaG9ydGZvcm0vc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svc3VidGhlbWUvaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay9zdWJ0aGVtZS9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svc3VidGhlbWUvcm91dGUudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3N1YnRoZW1lL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3RoZW1lL2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Jvb2svdGhlbWUvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3RoZW1lL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay90aGVtZS9zZXJ2aWNlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay90aGVtZWRldGFpbC9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3RoZW1lZGV0YWlsL21vZGVsLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay90aGVtZWRldGFpbC9wcm9tcHQudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ib29rL3RoZW1lZGV0YWlsL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYm9vay90aGVtZWRldGFpbC9zZXJ2aWNlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvY29sb3JmaWx0ZXIvaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvY29sb3JmaWx0ZXIvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9jb2xvcmZpbHRlci9yb3V0ZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2NvbG9yZmlsdGVyL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9jb21wYW55L2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2NvbXBhbnkvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9jb21wYW55L3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvY29tcGFueS9zZXJ2aWNlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvZmxhc2hjYXJkL2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2ZsYXNoY2FyZC9wcm9tcHQudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9mbGFzaGNhcmQvcm91dGUudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9mbGFzaGNhcmQvc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2hlbGxvL2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2hlbGxvL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvaGVsbG8vc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2ltcG9ydC9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9pbXBvcnQvbG9nL2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2ltcG9ydC9sb2cvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9pbXBvcnQvbG9nL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvaW1wb3J0L2xvZy9zZXJ2aWNlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvaW1wb3J0L3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvaW1wb3J0L3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9rZXl3b3Jkcy9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9rZXl3b3Jkcy9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2tleXdvcmRzL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMva2V5d29yZHMvc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2xhYmVsL2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2xhYmVsL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvbGFiZWwvc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL21ldGFkYXRhL2RlZmluaXRpb24vaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvbWV0YWRhdGEvZGVmaW5pdGlvbi9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL21ldGFkYXRhL2RlZmluaXRpb24vcm91dGUudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9tZXRhZGF0YS9kZWZpbml0aW9uL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9tZXRhZGF0YS92YWx1ZS9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9tZXRhZGF0YS92YWx1ZS9yb3V0ZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL21ldGFkYXRhL3ZhbHVlL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ub3RlL2hlbHBlci50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL25vdGUvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ub3RlL3Byb21wdC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL25vdGUvcm91dGUudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ub3RlL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ub3RlL3RhZy9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ub3RlL3RhZy9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL25vdGUvdGFnL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvbm90ZS90YWcvc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL25vdGVsaW5rL2F1dG8vaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvbm90ZWxpbmsvYXV0by9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL25vdGVsaW5rL2F1dG8vcm91dGUudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ub3RlbGluay9hdXRvL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ub3RlbGluay9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9ub3RlbGluay9tb2RlbC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL25vdGVsaW5rL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvbm90ZWxpbmsvc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Blcm1pc3Npb24vaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvcmVwb3J0L2Jvb2tfaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvcmVwb3J0L25vdGVfaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvcmVwb3J0L3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvcmVwb3J0L3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9zZXF1ZW5jZS9zZXJ2aWNlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvc2Vzc2lvbi9pbmRleC50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Nlc3Npb24vbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9zdG9wd29yZHMvaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvc3RvcHdvcmRzL21vZGVsLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvc3RvcHdvcmRzL3JvdXRlLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvc3RvcHdvcmRzL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9zdG9wd29yZHMvc3RvcHdvcmRzLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvdXNlci9oZWxwZXIudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy91c2VyL2luZGV4LnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvdXNlci9pbnZpdGUvaGVscGVyLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvdXNlci9pbnZpdGUvbW9kZWwudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy91c2VyL2ludml0ZS9yb3V0ZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3VzZXIvaW52aXRlL3NlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy91c2VyL21vZGVsLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvdXNlci9yb3V0ZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3VzZXIvc2VydmljZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9yb3V0ZS50cyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9zdGFydHVwLnRzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L2xvZy1hcHBseS1yZXN1bHQuanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L3BvbGwuanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbGliL2F1dGh1dGlscy5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2FydGljbGUvY2F0ZWdvcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9hcnRpY2xlL2NhdGVnb3J5L21vZGVsLmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYXJ0aWNsZS9jb21tZW50L2ZlZWRiYWNrL2luZGV4LmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYXJ0aWNsZS9jb21tZW50L2ZlZWRiYWNrL21vZGVsLmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYXJ0aWNsZS9jb21tZW50L2luZGV4LmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYXJ0aWNsZS9jb21tZW50L21vZGVsLmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYXJ0aWNsZS9mZWVkYmFjay9pbmRleC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2FydGljbGUvZmVlZGJhY2svbW9kZWwuanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9hcnRpY2xlL2luZGV4LmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYXJ0aWNsZS9tb2RlbC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2FydGljbGUvdGFnL2luZGV4LmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvYXJ0aWNsZS90YWcvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9hc3NldC9pbmRleC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL2Fzc2V0L21vZGVsLmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvZ3FsLXNjYWxhci9pbmRleC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Bvc3QvY29tbWVudC9mZWVkYmFjay9pbmRleC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Bvc3QvY29tbWVudC9mZWVkYmFjay9tb2RlbC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Bvc3QvY29tbWVudC9pbmRleC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Bvc3QvY29tbWVudC9tb2RlbC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Bvc3QvZmVlZGJhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9wb3N0L2ZlZWRiYWNrL21vZGVsLmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvcG9zdC9mb2xsb3dlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Bvc3QvZm9sbG93ZXIvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9wb3N0L2luZGV4LmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvcG9zdC9tb2RlbC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci8uL3NyYy9tb2R1bGVzL3Bvc3QvdGFnL2luZGV4LmpzIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyLy4vc3JjL21vZHVsZXMvcG9zdC90YWcvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvLi9zcmMvbW9kdWxlcy9zZXF1ZW5jZS9tb2RlbC5qcyIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcImFpaHViXCIiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJhcG9sbG8tc2VydmVyLWV4cHJlc3NcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcImF4aW9zXCIiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJiY3J5cHRcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcImNvcnNcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcImRhdGUtZm5zXCIiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJlanNcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcImV4cHJlc3NcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcImdyYXBocWxcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcImdyYXBocWwtdHlwZS1qc29uXCIiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJoYW5kbGViYXJzXCIiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJqc29ud2VidG9rZW5cIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcImpzemlwXCIiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJsb2Rhc2hcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcIm1vbWVudFwiIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyL2V4dGVybmFsIGNvbW1vbmpzIFwibW9uZ29vc2VcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcIm11bHRlclwiIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyL2V4dGVybmFsIGNvbW1vbmpzIFwicGFwYXBhcnNlXCIiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvZXh0ZXJuYWwgY29tbW9uanMgXCJ0ZXNzZXJhY3QuanNcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBjb21tb25qcyBcInV1aWRcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiZnNcIiIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci93ZWJwYWNrL3J1bnRpbWUvZ2V0IGphdmFzY3JpcHQgdXBkYXRlIGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyL3dlYnBhY2svcnVudGltZS9nZXQgdXBkYXRlIG1hbmlmZXN0IGZpbGVuYW1lIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyL3dlYnBhY2svcnVudGltZS9nZXRGdWxsSGFzaCIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyL3dlYnBhY2svcnVudGltZS9ob3QgbW9kdWxlIHJlcGxhY2VtZW50Iiwid2VicGFjazovL2VjaG8tZ3JhcGgtc2VydmVyL3dlYnBhY2svcnVudGltZS9yZXF1aXJlIGNodW5rIGxvYWRpbmciLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9lY2hvLWdyYXBoLXNlcnZlci93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vZWNoby1ncmFwaC1zZXJ2ZXIvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENIQVRHUFRfQVBJX0tFWTpcbiAgICAgICAgcHJvY2Vzcy5lbnYuQ0hBVEdQVF9BUElfS0VZIHx8XG4gICAgICAgIFwic2stcHJvai15cHVqWVp2cjFSRGttcDNabFVtdFQzQmxia0ZKZFJiV0Q5Y3ZhS0ppWGJaM09aNlpcIixcbiAgICBHRU1JTklfQVBJX0tFWTpcbiAgICAgICAgcHJvY2Vzcy5lbnYuR0VNSU5JX0FQSV9LRVkgfHwgXCJBSXphU3lBcTFnUWVrcnljeVUwd3A1bjlJRklNS01aa3RPX3JYNjhcIixcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzeW5jSGFuZGxlciA9IHZvaWQgMDtcbnZhciBhc3luY0hhbmRsZXIgPSBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uIChyZXEsIHJlcywgbmV4dCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZm4ocmVxLCByZXMsIG5leHQpKS5jYXRjaChuZXh0KTtcbn07IH07XG5leHBvcnRzLmFzeW5jSGFuZGxlciA9IGFzeW5jSGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mb3JtYXREYXRlVGV4dCA9IGV4cG9ydHMuRk9STUFUX01PTlRIX0FORF9ZRUFSID0gZXhwb3J0cy5GT1JNQVRfRlVMTF9EQVRFID0gdm9pZCAwO1xudmFyIG1vbWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtb21lbnRcIikpO1xuZXhwb3J0cy5GT1JNQVRfRlVMTF9EQVRFID0gXCJEbyBNTU0gWVlZWVwiO1xuZXhwb3J0cy5GT1JNQVRfTU9OVEhfQU5EX1lFQVIgPSBcIk1NTU0gWVlZWVwiO1xudmFyIGZvcm1hdERhdGVUZXh0ID0gZnVuY3Rpb24gKGRhdGVUZXh0LCBmb3JtYXQpIHtcbiAgICBpZiAoZGF0ZVRleHQpIHtcbiAgICAgICAgdmFyIGRhdGUgPSAoMCwgbW9tZW50XzEuZGVmYXVsdCkoZGF0ZVRleHQsICdZWVlZLU1NLUREVEhIOm1tOnNzWicpO1xuICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoZm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiXCI7XG59O1xuZXhwb3J0cy5mb3JtYXREYXRlVGV4dCA9IGZvcm1hdERhdGVUZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzRW1wdHlPclNwYWNlcyA9IGlzRW1wdHlPclNwYWNlcztcbmV4cG9ydHMuaXNFbXB0eUF0dHJpYnV0ZXMgPSBpc0VtcHR5QXR0cmlidXRlcztcbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbmV4cG9ydHMuc29ydCA9IHNvcnQ7XG5leHBvcnRzLmh0bWxUb1RleHQgPSBodG1sVG9UZXh0O1xuZnVuY3Rpb24gaXNFbXB0eU9yU3BhY2VzKHN0cikge1xuICAgIHJldHVybiAhc3RyIHx8IHN0ci5tYXRjaCgvXiAqJC8pICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNFbXB0eUF0dHJpYnV0ZXMob2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhT2JqZWN0LmtleXMob2JqZWN0KS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKG9iamVjdFtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXRjaCh0ZXh0LCB3b3Jkcykge1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIGlmICh3b3Jkcykge1xuICAgICAgICB3b3Jkcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LnRvU3RyaW5nKCkubWF0Y2gobmV3IFJlZ0V4cChcIihcXFxcdypcIi5jb25jYXQod29yZCwgXCJcXFxcdyopXCIpLCAnZ2knKSkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBzb3J0KGFycmF5LCBwcm9wZXJ0eSwgaXNSZXZlcnNlT3JkZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0gYXJyYXkuc29ydChmdW5jdGlvbiAobzEsIG8yKSB7XG4gICAgICAgIGlmIChpc1JldmVyc2VPcmRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG8xW3Byb3BlcnR5XSA+IG8yW3Byb3BlcnR5XVxuICAgICAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgICAgICA6IG8xW3Byb3BlcnR5XSA8IG8yW3Byb3BlcnR5XVxuICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvMVtwcm9wZXJ0eV0gPCBvMltwcm9wZXJ0eV1cbiAgICAgICAgICAgID8gLTFcbiAgICAgICAgICAgIDogbzFbcHJvcGVydHldID4gbzJbcHJvcGVydHldXG4gICAgICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBodG1sVG9UZXh0KHN0cikge1xuICAgIGlmICghc3RyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oPChbXj5dKyk+KS9naSwgJycpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEdsb2JhbENvbGxlY3Rpb24gPSBleHBvcnRzLmdldENvbGxlY3Rpb24gPSB2b2lkIDA7XG52YXIgbW9uZ29vc2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibW9uZ29vc2VcIikpO1xudmFyIGdldENvbGxlY3Rpb24gPSBmdW5jdGlvbiAocmVhbG0sIGNvbGxlY3Rpb24sIHNjaGVtYSkge1xuICAgIHZhciBkYiA9IG1vbmdvb3NlXzEuZGVmYXVsdC5jb25uZWN0aW9uLnVzZURiKFwiZWNob19cIi5jb25jYXQocmVhbG0pKTtcbiAgICByZXR1cm4gZGIubW9kZWwoY29sbGVjdGlvbiwgc2NoZW1hKTtcbn07XG5leHBvcnRzLmdldENvbGxlY3Rpb24gPSBnZXRDb2xsZWN0aW9uO1xudmFyIGdldEdsb2JhbENvbGxlY3Rpb24gPSBmdW5jdGlvbiAoY29sbGVjdGlvbiwgc2NoZW1hKSB7XG4gICAgdmFyIGRiID0gbW9uZ29vc2VfMS5kZWZhdWx0LmNvbm5lY3Rpb24udXNlRGIoXCJlY2hvXCIpO1xuICAgIHJldHVybiBkYi5tb2RlbChjb2xsZWN0aW9uLCBzY2hlbWEpO1xufTtcbmV4cG9ydHMuZ2V0R2xvYmFsQ29sbGVjdGlvbiA9IGdldEdsb2JhbENvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UHJvbXB0ID0gZXhwb3J0cy5yZXBsYWNlVmFyaWFibGVzID0gZXhwb3J0cy5wcmVkaWN0ID0gdm9pZCAwO1xudmFyIEhhbmRsZWJhcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImhhbmRsZWJhcnNcIikpO1xudmFyIGxvZGFzaF8xID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbnZhciBheGlvcyA9IHJlcXVpcmUoXCJheGlvc1wiKTtcbnZhciBET0RPX1VSTCA9IHByb2Nlc3MuZW52LkRPRE9fVVJMIHx8IFwiaHR0cHM6Ly9hcGkuaW9hay5pbzo4MTIwXCI7XG52YXIgRE9ET19LRVkgPSBwcm9jZXNzLmVudi5ET0RPX0tFWSB8fCBcImE1M2RjMzM3LWEyMDMtNDk4MC1iZmM4LTEyZjE5YWNkZGQyNlwiO1xudmFyIF9NT0RFTF9OQU1FID0gcHJvY2Vzcy5lbnYuQ0hBVEdQVF9NT0RFTF9OQU1FIHx8IFwiZ3B0LTRvLW1pbmlcIjtcbnZhciBwcmVkaWN0ID0gZnVuY3Rpb24gKHBheWxvYWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3BvbnNlLCBlcnJfMTtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2s7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfbCkge1xuICAgICAgICBzd2l0Y2ggKF9sLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2wudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zLnBvc3QoXCJcIi5jb25jYXQoRE9ET19VUkwsIFwiL2FwaS9jaGF0Z3B0L3YxL2NoYXQvY29tcGxldGlvbnNcIiksIHBheWxvYWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBET0RPX0tFWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9sLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJHUFQgUkVTUE9OU0VcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9iID0gKF9hID0gcmVzcG9uc2UuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jaG9pY2VzLmxlbmd0aCkgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9mID0gKF9lID0gKF9kID0gKF9jID0gcmVzcG9uc2UuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRhdGEpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jaG9pY2VzWzBdKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubWVzc2FnZSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIChfayA9IChfaiA9IChfaCA9IChfZyA9IHJlc3BvbnNlLmRhdGEpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5kYXRhKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guY2hvaWNlc1swXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLm1lc3NhZ2UpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5jb250ZW50LnJlcGxhY2UoL2BgYGpzb24vZywgXCJcIikucmVwbGFjZSgvYGBgL2csIFwiXCIpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVycl8xID0gX2wuc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiKlwiLCBlcnJfMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7fV07XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5wcmVkaWN0ID0gcHJlZGljdDtcbnZhciByZXBsYWNlVmFyaWFibGVzID0gZnVuY3Rpb24gKGNvbnRlbnQsIGNvbnRleHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgICByZXR1cm4gY29udGVudC5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIEhhbmRsZWJhcnMuY29tcGlsZShpdGVtKShjb250ZXh0KTsgfSkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIEhhbmRsZWJhcnMuY29tcGlsZShjb250ZW50KShjb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGNvbnRlbnQgdHlwZVwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5yZXBsYWNlVmFyaWFibGVzID0gcmVwbGFjZVZhcmlhYmxlcztcbnZhciBnZXRQcm9tcHQgPSBmdW5jdGlvbiAoX3Byb21wdCwgY29udGV4dCkge1xuICAgIHZhciBwcm9tcHQgPSAoMCwgbG9kYXNoXzEuY2xvbmVEZWVwKShfcHJvbXB0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb21wdC5tZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9tcHQubWVzc2FnZXNbaV0uY29udGVudCA9ICgwLCBleHBvcnRzLnJlcGxhY2VWYXJpYWJsZXMpKHByb21wdC5tZXNzYWdlc1tpXS5jb250ZW50LCBfX2Fzc2lnbih7IG1vZGVsTmFtZTogX01PREVMX05BTUUgfSwgY29udGV4dCkpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhwcm9tcHQpO1xuICAgIHJldHVybiBwcm9tcHQ7XG59O1xuZXhwb3J0cy5nZXRQcm9tcHQgPSBnZXRQcm9tcHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVNYW5kYXRvcnlGaWVsZHMgPSB2b2lkIDA7XG52YXIgdmFsaWRhdGVNYW5kYXRvcnlGaWVsZHMgPSBmdW5jdGlvbiAocmVzLCBkYXRhLCBtYW5kYXRvcnlGaWVsZHMpIHtcbiAgICB2YXIgbWlzc2luZ0ZpZWxkcyA9IFtdO1xuICAgIG1hbmRhdG9yeUZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKCFkYXRhLmhhc093blByb3BlcnR5KGZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgIG1pc3NpbmdGaWVsZHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG1pc3NpbmdGaWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXMuc3RhdHVzKDQwMCk7XG4gICAgcmVzLnNlbmQoe1xuICAgICAgICBlcnJvcjogeyBtaXNzaW5nRmllbGRzOiBtaXNzaW5nRmllbGRzIH0sXG4gICAgfSk7XG4gICAgcmVzLmVuZCgpO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLnZhbGlkYXRlTWFuZGF0b3J5RmllbGRzID0gdmFsaWRhdGVNYW5kYXRvcnlGaWVsZHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmlmIChtb2R1bGUuaG90KSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKTtcbiAgICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyLnN0b3AoKTsgfSk7XG59XG52YXIgQXBvbGxvU2VydmVyID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKS5BcG9sbG9TZXJ2ZXI7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuL21pZGRsZXdhcmVzXCIpO1xudmFyIG1vbmdvb3NlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm1vbmdvb3NlXCIpKTtcbnZhciBzdGFydHVwXzEgPSByZXF1aXJlKFwiLi9zdGFydHVwXCIpO1xudmFyIGV4cHJlc3MgPSByZXF1aXJlKFwiZXhwcmVzc1wiKTtcbnZhciBjb3JzID0gcmVxdWlyZShcImNvcnNcIik7XG52YXIgQXBpUm91dGUgPSByZXF1aXJlKFwiLi9yb3V0ZVwiKTtcbnZhciBncWxTY2FsYXJTY2hlbWEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2dxbC1zY2FsYXJcIik7XG52YXIgYXNzZXRTY2hlbWEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2Fzc2V0XCIpO1xudmFyIHNlc3Npb25TY2hlbWEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3Nlc3Npb25cIik7XG52YXIgdXNlclNjaGVtYSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvdXNlclwiKTtcbnZhciBhcnRpY2xlU2NoZW1hID0gcmVxdWlyZShcIi4vbW9kdWxlcy9hcnRpY2xlXCIpO1xudmFyIGFydGljbGVDb21tZW50U2NoZW1hID0gcmVxdWlyZShcIi4vbW9kdWxlcy9hcnRpY2xlL2NvbW1lbnRcIik7XG52YXIgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja1NjaGVtYSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXJ0aWNsZS9jb21tZW50L2ZlZWRiYWNrXCIpO1xudmFyIGFydGljbGVGZWVkYmFja1NjaGVtYSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXJ0aWNsZS9mZWVkYmFja1wiKTtcbnZhciBhcnRpY2xlQ2F0ZWdvcnlTY2hlbWEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2FydGljbGUvY2F0ZWdvcnlcIik7XG52YXIgYXJ0aWNsZVRhZ1NjaGVtYSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvYXJ0aWNsZS90YWdcIik7XG52YXIgcG9zdFNjaGVtYSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvcG9zdFwiKTtcbnZhciBwb3N0Q29tbWVudFNjaGVtYSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvcG9zdC9jb21tZW50XCIpO1xudmFyIHBvc3RDb21tZW50RmVlZGJhY2tTY2hlbWEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3Bvc3QvY29tbWVudC9mZWVkYmFja1wiKTtcbnZhciBwb3N0RmVlZGJhY2tTY2hlbWEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3Bvc3QvZmVlZGJhY2tcIik7XG52YXIgcG9zdEZvbGxvd2VyU2NoZW1hID0gcmVxdWlyZShcIi4vbW9kdWxlcy9wb3N0L2ZvbGxvd2VyXCIpO1xudmFyIHBvc3RUYWdTY2hlbWEgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3Bvc3QvdGFnXCIpO1xudmFyIGRhdGFiYXNlVXJpID0gcHJvY2Vzcy5lbnYuTU9OR09EQl9VUkkgfHwgXCJtb25nb2RiOi8vMTI3LjAuMC4xOjI3MDE3XCI7XG5tb25nb29zZV8xLmRlZmF1bHQuY29ubmVjdChkYXRhYmFzZVVyaSwge30pO1xubW9uZ29vc2VfMS5kZWZhdWx0LnBsdXJhbGl6ZSh1bmRlZmluZWQpO1xudmFyIGFwcCA9IGV4cHJlc3MoKTtcbnZhciBzZXJ2ZXIgPSBuZXcgQXBvbGxvU2VydmVyKHtcbiAgICB0eXBlRGVmczogW1xuICAgICAgICBncWxTY2FsYXJTY2hlbWEudHlwZURlZnMsXG4gICAgICAgIGFzc2V0U2NoZW1hLnR5cGVEZWZzLFxuICAgICAgICBzZXNzaW9uU2NoZW1hLnR5cGVEZWZzLFxuICAgICAgICB1c2VyU2NoZW1hLnR5cGVEZWZzLFxuICAgICAgICBhcnRpY2xlU2NoZW1hLnR5cGVEZWZzLFxuICAgICAgICBhcnRpY2xlQ29tbWVudFNjaGVtYS50eXBlRGVmcyxcbiAgICAgICAgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja1NjaGVtYS50eXBlRGVmcyxcbiAgICAgICAgYXJ0aWNsZUNhdGVnb3J5U2NoZW1hLnR5cGVEZWZzLFxuICAgICAgICBhcnRpY2xlRmVlZGJhY2tTY2hlbWEudHlwZURlZnMsXG4gICAgICAgIGFydGljbGVUYWdTY2hlbWEudHlwZURlZnMsXG4gICAgICAgIHBvc3RTY2hlbWEudHlwZURlZnMsXG4gICAgICAgIHBvc3RDb21tZW50U2NoZW1hLnR5cGVEZWZzLFxuICAgICAgICBwb3N0Q29tbWVudEZlZWRiYWNrU2NoZW1hLnR5cGVEZWZzLFxuICAgICAgICBwb3N0RmVlZGJhY2tTY2hlbWEudHlwZURlZnMsXG4gICAgICAgIHBvc3RGb2xsb3dlclNjaGVtYS50eXBlRGVmcyxcbiAgICAgICAgcG9zdFRhZ1NjaGVtYS50eXBlRGVmcyxcbiAgICBdLFxuICAgIHJlc29sdmVyczogW1xuICAgICAgICBncWxTY2FsYXJTY2hlbWEucmVzb2x2ZXJzLFxuICAgICAgICBhc3NldFNjaGVtYS5yZXNvbHZlcnMsXG4gICAgICAgIHNlc3Npb25TY2hlbWEucmVzb2x2ZXJzLFxuICAgICAgICB1c2VyU2NoZW1hLnJlc29sdmVycyxcbiAgICAgICAgYXJ0aWNsZVNjaGVtYS5yZXNvbHZlcnMsXG4gICAgICAgIGFydGljbGVDb21tZW50U2NoZW1hLnJlc29sdmVycyxcbiAgICAgICAgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja1NjaGVtYS5yZXNvbHZlcnMsXG4gICAgICAgIGFydGljbGVDYXRlZ29yeVNjaGVtYS5yZXNvbHZlcnMsXG4gICAgICAgIGFydGljbGVGZWVkYmFja1NjaGVtYS5yZXNvbHZlcnMsXG4gICAgICAgIGFydGljbGVUYWdTY2hlbWEucmVzb2x2ZXJzLFxuICAgICAgICBwb3N0U2NoZW1hLnJlc29sdmVycyxcbiAgICAgICAgcG9zdENvbW1lbnRTY2hlbWEucmVzb2x2ZXJzLFxuICAgICAgICBwb3N0Q29tbWVudEZlZWRiYWNrU2NoZW1hLnJlc29sdmVycyxcbiAgICAgICAgcG9zdEZlZWRiYWNrU2NoZW1hLnJlc29sdmVycyxcbiAgICAgICAgcG9zdEZvbGxvd2VyU2NoZW1hLnJlc29sdmVycyxcbiAgICAgICAgcG9zdFRhZ1NjaGVtYS5yZXNvbHZlcnMsXG4gICAgXSxcbiAgICBjb250ZXh0OiBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHJlcSA9IF9hLnJlcSwgcmVzID0gX2EucmVzO1xuICAgICAgICB2YXIgYXV0aFN0cmluZyA9IHJlcS5oZWFkZXJzLmF1dGhvcml6YXRpb24gfHwgXCJcIjtcbiAgICAgICAgdmFyIGF1dGhQYXJ0cyA9IGF1dGhTdHJpbmcuc3BsaXQoXCIgXCIpO1xuICAgICAgICB2YXIgdG9rZW4gPSBcIlwiO1xuICAgICAgICB2YXIgdXNlciA9IG51bGw7XG4gICAgICAgIHZhciBhc3NldCA9IFwiXCI7XG4gICAgICAgIGlmIChhdXRoUGFydHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0b2tlbiA9IGF1dGhQYXJ0c1sxXTtcbiAgICAgICAgICAgIGFzc2V0ID0gYXV0aFBhcnRzWzBdO1xuICAgICAgICAgICAgdXNlciA9ICgwLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZSkodG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHVzZXI6IHVzZXIsIHRva2VuOiB0b2tlbiwgYXNzZXQ6IGFzc2V0IH07XG4gICAgfSxcbiAgICBpbnRyb3NwZWN0aW9uOiB0cnVlLFxuICAgIHBsYXlncm91bmQ6IHRydWUsXG59KTtcbnNlcnZlci5zdGFydCgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyLmFwcGx5TWlkZGxld2FyZSh7IGFwcDogYXBwIH0pOyB9KTtcbmFwcC51c2UoY29ycygpKTtcbmFwcC5nZXQoXCIvaGVsbG9cIiwgZnVuY3Rpb24gKF8sIHJlcykge1xuICAgIHJlcy5zZW5kKFwiYmFzaWMgY29ubmVjdGlvbiB0byBzZXJ2ZXIgd29ya3MuIGRhdGFiYXNlIGNvbm5lY3Rpb24gaXMgbm90IHZhbGlkYXRlZFwiKTtcbiAgICByZXMuZW5kKCk7XG59KTtcbmFwcC51c2UoZXhwcmVzcy5qc29uKHsgbGltaXQ6IDUwMDAwMDAgfSkpO1xuYXBwLnVzZShleHByZXNzLnVybGVuY29kZWQoe1xuICAgIGV4dGVuZGVkOiB0cnVlLFxufSkpO1xuYXBwLnVzZShcIi9hcGlcIiwgQXBpUm91dGUpO1xuYXBwLnVzZShmdW5jdGlvbiAoXywgcmVzKSB7XG4gICAgcmVzLnN0YXR1cyg0MDQpO1xuICAgIHJlcy5zZW5kKFwiTm90IGZvdW5kXCIpO1xuICAgIHJlcy5lbmQoKTtcbn0pO1xuYXBwLnVzZShmdW5jdGlvbiAoZXJyLCByZXEsIHJlcywgbmV4dCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yOicsIGVycik7XG4gICAgcmVzLnN0YXR1cyg1MDApLnNlbmQoZXJyLnN0YWNrKTtcbn0pO1xuYXBwLmxpc3Rlbih7IHBvcnQ6IHByb2Nlc3MuZW52LlBPUlQgfHwgNDAwMCB9LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiXFx1RDgzRFxcdURFODAgU2VydmVyIHJlYWR5IGF0IGh0dHA6Ly9sb2NhbGhvc3Q6XCIuY29uY2F0KHByb2Nlc3MuZW52LlBPUlQgfHwgNDAwMCkuY29uY2F0KHNlcnZlci5ncmFwaHFsUGF0aCkpO1xufSk7XG4oMCwgc3RhcnR1cF8xLmluaXRpYWxpemVTZXF1ZW5jZXMpKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXV0aG9yaXplQXBpID0gZXhwb3J0cy5hdXRob3JpemVBcGlPbmVhdXRoID0gZXhwb3J0cy5hdXRob3JpemUgPSB2b2lkIDA7XG52YXIgZnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnNcIikpO1xudmFyIGpzb253ZWJ0b2tlbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqc29ud2VidG9rZW5cIikpO1xudmFyIGhlbHBlcl8xID0gcmVxdWlyZShcIi4vbW9kdWxlcy9hdXRoL2hlbHBlclwiKTtcbnZhciBhdXRob3JpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB2YXIgYXBwUm9vdCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgdmFyIHB1YmxpY0tleSA9IGZzXzEuZGVmYXVsdC5yZWFkRmlsZVN5bmMoYXBwUm9vdCArIFwiL3B1YmxpYy5wZW1cIik7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbndlYnRva2VuXzEuZGVmYXVsdC52ZXJpZnkodG9rZW4sIHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbmV4cG9ydHMuYXV0aG9yaXplID0gYXV0aG9yaXplO1xudmFyIGF1dGhvcml6ZUFwaU9uZWF1dGggPSBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRva2VuLCBkYXRhLCBlcnJfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgIHRva2VuID0gcmVxLmhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXMuc2VuZFN0YXR1cyg0MDEpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgaGVscGVyXzEuZGVjb2RlVG9rZW4pKHRva2VuKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEub3V0Y29tZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlcy5zZW5kU3RhdHVzKDQwMSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXEudXNlciA9IGRhdGEuY2xhaW1zO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVycl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlcy5zZW5kU3RhdHVzKDQwMSldO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuYXV0aG9yaXplQXBpT25lYXV0aCA9IGF1dGhvcml6ZUFwaU9uZWF1dGg7XG52YXIgYXV0aG9yaXplQXBpID0gZnVuY3Rpb24gKHJlcSwgcmVzLCBuZXh0KSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB0b2tlbiwgZGF0YSwgZXJyXzI7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xuICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2QudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHJlcS5oZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzLnNlbmRTdGF0dXMoNDAxKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIGhlbHBlcl8xLmRlY29kZVRva2VuKSh0b2tlbildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfZC5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLm91dGNvbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlcS5wYXJhbXMuc3BhY2UgJiYgKCEoKF9hID0gZGF0YS5jbGFpbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZXJtaXNzaW9ucykgfHwgISgoX2MgPSAoX2IgPSBkYXRhLmNsYWltcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBlcm1pc3Npb25zWydDT01QQU5ZX0FETUlOJ10pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pbmNsdWRlcyhyZXEucGFyYW1zLnNwYWNlKSkpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlcy5zZW5kU3RhdHVzKDQwMSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXEudXNlciA9IGRhdGEuY2xhaW1zO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVycl8yID0gX2Quc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlcy5zZW5kU3RhdHVzKDQwMSldO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuYXV0aG9yaXplQXBpID0gYXV0aG9yaXplQXBpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUFwcFRva2VuID0gZXhwb3J0cy5lbmNvZGVBcHBUb2tlbiA9IGV4cG9ydHMuZ2V0SGFzaCA9IGV4cG9ydHMuZGVjb2RlU2Vzc2lvbiA9IGV4cG9ydHMuZGVjb2RlVG9rZW4gPSBleHBvcnRzLmRlbGV0ZVNlc3Npb25CeVJlZnJlc2hUb2tlbiA9IGV4cG9ydHMuZGVsZXRlU2Vzc2lvbiA9IGV4cG9ydHMudmFsaWRhdGVTZXNzaW9uID0gZXhwb3J0cy5nZXRBY2Nlc3NUb2tlbiA9IGV4cG9ydHMuY3JlYXRlU2Vzc2lvbiA9IHZvaWQgMDtcbnZhciBiY3J5cHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmNyeXB0XCIpKTtcbnZhciB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbnZhciBmc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmc1wiKSk7XG52YXIganNvbndlYnRva2VuXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb253ZWJ0b2tlblwiKSk7XG52YXIgZGF0ZV9mbnNfMSA9IHJlcXVpcmUoXCJkYXRlLWZuc1wiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4uL3Nlc3Npb24vbW9kZWxcIik7XG52YXIgZGJ1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2xpYi9kYnV0aWxzXCIpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbnZhciBhcHBVcmwgPSBwcm9jZXNzLmVudi5BUFBfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDozMDEwXCI7XG52YXIgY3JlYXRlU2Vzc2lvbiA9IGZ1bmN0aW9uIChyZWFsbSwgdXNlcikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2Vzc2lvbl9pZCwgbW9kZWwsIGNsYWltcywgYXBwUm9vdCwgcHJpdmF0ZUtleSwgcmVmcmVzaF90b2tlbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBzZXNzaW9uX2lkID0gKDAsIHV1aWRfMS52NCkoKTtcbiAgICAgICAgICAgICAgICBtb2RlbCA9ICgwLCBkYnV0aWxzXzEuZ2V0Q29sbGVjdGlvbikoU3RyaW5nKHJlYWxtKSwgbW9kZWxfMS5zZXNzaW9uQ29sbGVjdGlvbiwgbW9kZWxfMS5zZXNzaW9uU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBjbGFpbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICAgICAgICAgIGdpdmVuX25hbWU6IHVzZXIuZ2l2ZW5fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmFtaWx5X25hbWU6IHVzZXIuZmFtaWx5X25hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHVzZXIubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbmlja25hbWU6IHVzZXIubmlja25hbWUsXG4gICAgICAgICAgICAgICAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB1c2VyLnR5cGUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhcHBSb290ID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgICAgICAgICBwcml2YXRlS2V5ID0gZnNfMS5kZWZhdWx0LnJlYWRGaWxlU3luYyhhcHBSb290ICsgXCIvcHJpdmF0ZS5wZW1cIik7XG4gICAgICAgICAgICAgICAgcmVmcmVzaF90b2tlbiA9IGpzb253ZWJ0b2tlbl8xLmRlZmF1bHQuc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHJlYWxtOiByZWFsbSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNlc3Npb25faWQsXG4gICAgICAgICAgICAgICAgfSwgeyBrZXk6IHByaXZhdGVLZXksIHBhc3NwaHJhc2U6IFwibm8xa25vd3NtZVwiIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBcIlJTMjU2XCIsXG4gICAgICAgICAgICAgICAgICAgIGV4cGlyZXNJbjogXCI4aFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25faWQ6IHNlc3Npb25faWQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYWltczogY2xhaW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWF0OiAoMCwgZGF0ZV9mbnNfMS5hZGQpKG5ldyBEYXRlKCksIHsgaG91cnM6IDggfSksXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IHNlc3Npb25faWQ6IHNlc3Npb25faWQsIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hfdG9rZW4gfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVTZXNzaW9uID0gY3JlYXRlU2Vzc2lvbjtcbnZhciBnZXRBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIChyZWZyZXNoVG9rZW4pIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlY29kZWQsIGNsYWltcywgYXBwUm9vdCwgcHJpdmF0ZUtleSwgbW9kZWwsIHNlc3Npb24sIHJlZnJlc2hUb2tlbkR1cmF0aW9uLCBhY2Nlc3NfdG9rZW47XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgKDAsIGV4cG9ydHMuZGVjb2RlVG9rZW4pKHJlZnJlc2hUb2tlbildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGRlY29kZWQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWNvZGVkLm91dGNvbWUgfHxcbiAgICAgICAgICAgICAgICAgICAgIWRlY29kZWQuY2xhaW1zIHx8XG4gICAgICAgICAgICAgICAgICAgICFkZWNvZGVkLmNsYWltcy5yZWFsbSB8fFxuICAgICAgICAgICAgICAgICAgICAhZGVjb2RlZC5jbGFpbXMuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhaW1zID0gZGVjb2RlZC5jbGFpbXM7XG4gICAgICAgICAgICAgICAgYXBwUm9vdCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleSA9IGZzXzEuZGVmYXVsdC5yZWFkRmlsZVN5bmMoYXBwUm9vdCArIFwiL3ByaXZhdGUucGVtXCIpO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRDb2xsZWN0aW9uKShjbGFpbXMucmVhbG0sIG1vZGVsXzEuc2Vzc2lvbkNvbGxlY3Rpb24sIG1vZGVsXzEuc2Vzc2lvblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kT25lKHsgc2Vzc2lvbl9pZDogY2xhaW1zLmlkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgZGF0ZV9mbnNfMS5kaWZmZXJlbmNlSW5TZWNvbmRzKShzZXNzaW9uLmVhdCwgbmV3IERhdGUoKSkgPCA2MCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW5EdXJhdGlvbiA9ICgwLCBkYXRlX2Zuc18xLmRpZmZlcmVuY2VJblNlY29uZHMpKHNlc3Npb24uZWF0LCBuZXcgRGF0ZSgpKSA+IDYwICogNjAgKiAyXG4gICAgICAgICAgICAgICAgICAgID8gNjAgKiA2MCAqIDJcbiAgICAgICAgICAgICAgICAgICAgOiAoMCwgZGF0ZV9mbnNfMS5kaWZmZXJlbmNlSW5TZWNvbmRzKShzZXNzaW9uLmVhdCwgbmV3IERhdGUoKSk7XG4gICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuID0ganNvbndlYnRva2VuXzEuZGVmYXVsdC5zaWduKHNlc3Npb24uY2xhaW1zLCB7IGtleTogcHJpdmF0ZUtleSwgcGFzc3BocmFzZTogXCJubzFrbm93c21lXCIgfSwge1xuICAgICAgICAgICAgICAgICAgICBhbGdvcml0aG06IFwiUlMyNTZcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwaXJlc0luOiBcIlwiLmNvbmNhdChyZWZyZXNoVG9rZW5EdXJhdGlvbiwgXCJzXCIpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgYWNjZXNzX3Rva2VuXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEFjY2Vzc1Rva2VuID0gZ2V0QWNjZXNzVG9rZW47XG52YXIgdmFsaWRhdGVTZXNzaW9uID0gZnVuY3Rpb24gKHJlYWxtLCBzZXNzaW9uSWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCBzZXNzaW9uO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRDb2xsZWN0aW9uKShTdHJpbmcocmVhbG0pLCBtb2RlbF8xLnNlc3Npb25Db2xsZWN0aW9uLCBtb2RlbF8xLnNlc3Npb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZE9uZSh7IHNlc3Npb25JZDogc2Vzc2lvbklkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgc2Vzc2lvbl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy52YWxpZGF0ZVNlc3Npb24gPSB2YWxpZGF0ZVNlc3Npb247XG52YXIgZGVsZXRlU2Vzc2lvbiA9IGZ1bmN0aW9uIChyZWFsbSwgc2Vzc2lvbl9pZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSAoMCwgZGJ1dGlsc18xLmdldENvbGxlY3Rpb24pKFN0cmluZyhyZWFsbSksIG1vZGVsXzEuc2Vzc2lvbkNvbGxlY3Rpb24sIG1vZGVsXzEuc2Vzc2lvblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVPbmUoeyBzZXNzaW9uX2lkOiBzZXNzaW9uX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlU2Vzc2lvbiA9IGRlbGV0ZVNlc3Npb247XG52YXIgZGVsZXRlU2Vzc2lvbkJ5UmVmcmVzaFRva2VuID0gZnVuY3Rpb24gKHJlYWxtLCByZWZyZXNoX3Rva2VuKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9ICgwLCBkYnV0aWxzXzEuZ2V0Q29sbGVjdGlvbikoU3RyaW5nKHJlYWxtKSwgbW9kZWxfMS5zZXNzaW9uQ29sbGVjdGlvbiwgbW9kZWxfMS5zZXNzaW9uU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU9uZSh7IHJlZnJlc2hfdG9rZW46IHJlZnJlc2hfdG9rZW4gfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVTZXNzaW9uQnlSZWZyZXNoVG9rZW4gPSBkZWxldGVTZXNzaW9uQnlSZWZyZXNoVG9rZW47XG52YXIgZGVjb2RlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFwcFJvb3QsIHB1YmxpY0tleSwgcmVzLCBlcnJfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBhcHBSb290ID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXkgPSBmc18xLmRlZmF1bHQucmVhZEZpbGVTeW5jKGFwcFJvb3QgKyBcIi9wdWJsaWMucGVtXCIpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwganNvbndlYnRva2VuXzEuZGVmYXVsdC52ZXJpZnkodG9rZW4sIHB1YmxpY0tleSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgb3V0Y29tZTogdHJ1ZSwgdG9rZW46IHRva2VuLCBjbGFpbXM6IHJlcyB9XTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBlcnJfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJfMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IG91dGNvbWU6IGZhbHNlLCBlcnI6IGVycl8xIH1dO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVjb2RlVG9rZW4gPSBkZWNvZGVUb2tlbjtcbnZhciBkZWNvZGVTZXNzaW9uID0gZnVuY3Rpb24gKHJlYWxtSWQsIHNlc3Npb25JZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2Vzc2lvbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCAoMCwgZXhwb3J0cy52YWxpZGF0ZVNlc3Npb24pKHJlYWxtSWQsIHNlc3Npb25JZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHNlc3Npb24gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgc2Vzc2lvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgKDAsIGV4cG9ydHMuZGVjb2RlVG9rZW4pKHNlc3Npb24udG9rZW4pXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlY29kZVNlc3Npb24gPSBkZWNvZGVTZXNzaW9uO1xudmFyIGdldEhhc2ggPSBmdW5jdGlvbiAocGFzc3dvcmQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNhbHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgYmNyeXB0XzEuZGVmYXVsdC5nZW5TYWx0KDEwKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc2FsdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGJjcnlwdF8xLmRlZmF1bHQuaGFzaChwYXNzd29yZCwgc2FsdCldO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRIYXNoID0gZ2V0SGFzaDtcbnZhciBlbmNvZGVBcHBUb2tlbiA9IGZ1bmN0aW9uIChjbGFpbXMpIHtcbiAgICB2YXIgYXBwUm9vdCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgdmFyIHByaXZhdGVLZXkgPSBmc18xLmRlZmF1bHQucmVhZEZpbGVTeW5jKGFwcFJvb3QgKyBcIi9sb2NhbF9wcml2YXRlLnBlbVwiKTtcbiAgICB2YXIgdG9rZW4gPSBqc29ud2VidG9rZW5fMS5kZWZhdWx0LnNpZ24oY2xhaW1zLCB7IGtleTogcHJpdmF0ZUtleSwgcGFzc3BocmFzZTogXCJmZXZpY3J5bFwiIH0sIHtcbiAgICAgICAgYWxnb3JpdGhtOiBcIlJTMjU2XCIsXG4gICAgICAgIGV4cGlyZXNJbjogXCIxMDBoXCIsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRva2VuO1xufTtcbmV4cG9ydHMuZW5jb2RlQXBwVG9rZW4gPSBlbmNvZGVBcHBUb2tlbjtcbnZhciBkZWNvZGVBcHBUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXBwUm9vdCwgcHVibGljS2V5LCByZXMsIGVycl8yO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGFwcFJvb3QgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICAgICAgICAgIHB1YmxpY0tleSA9IGZzXzEuZGVmYXVsdC5yZWFkRmlsZVN5bmMoYXBwUm9vdCArIFwiL2xvY2FsX3B1YmxpYy5wZW1cIik7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBqc29ud2VidG9rZW5fMS5kZWZhdWx0LnZlcmlmeSh0b2tlbiwgcHVibGljS2V5KV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBvdXRjb21lOiB0cnVlLCB0b2tlbjogdG9rZW4sIGNsYWltczogcmVzIH1dO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVycl8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgb3V0Y29tZTogZmFsc2UsIGVycjogZXJyXzIgfV07XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWNvZGVBcHBUb2tlbiA9IGRlY29kZUFwcFRva2VuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5wb3N0KFwiL2F1dGgvYXV0aG9yaXplXCIsICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuc2lnbmluKSk7XG4gICAgcm91dGVyLnBvc3QoXCIvYXV0aC90b2tlblwiLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmlzc3VlVG9rZW4pKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2F1dGgvdG9rZW4vZGVjb2RlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmRlY29kZVRva2VuKSk7XG4gICAgcm91dGVyLnBvc3QoXCIvYXV0aC9sb2dvdXRcIiwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5sb2dvdXQpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2F1dGgvb2Evc2Vzc2lvbi86aWRcIiwgZnVuY3Rpb24gKHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIHJldHVybiAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoKDAsIHNlcnZpY2VfMS52YWxpZGF0ZVNlc3Npb24pKHNlbGZSZWFsbSwgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL2F1dGgvb2Evc2Vzc2lvbi86aWRcIiwgZnVuY3Rpb24gKHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICAgIHJldHVybiAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoKDAsIHNlcnZpY2VfMS5kZWxldGVTZXNzaW9uKShzZWxmUmVhbG0sIHJlcSwgcmVzLCBuZXh0KSk7XG4gICAgfSk7XG4gICAgcm91dGVyLmdldChcIi9hdXRoL29hL3Nlc3Npb24vOmlkL2RlY29kZVwiLCBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKSgoMCwgc2VydmljZV8xLmRlY29kZVNlc3Npb24pKHNlbGZSZWFsbSwgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcbiAgICByb3V0ZXIuZ2V0KFwiL2F1dGgvcmVhbG0vOnJlYWxtL3Nlc3Npb24vOmlkXCIsIGZ1bmN0aW9uIChyZXEsIHJlcywgbmV4dCkge1xuICAgICAgICByZXR1cm4gKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKCgwLCBzZXJ2aWNlXzEudmFsaWRhdGVTZXNzaW9uKShyZXEucGFyYW1zLnJlYWxtLCByZXEsIHJlcywgbmV4dCkpO1xuICAgIH0pO1xuICAgIHJvdXRlci5nZXQoXCIvYXV0aC9yZWFsbS86cmVhbG0vc2Vzc2lvbi86aWQvZGVjb2RlXCIsIGZ1bmN0aW9uIChyZXEsIHJlcywgbmV4dCkge1xuICAgICAgICByZXR1cm4gKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKCgwLCBzZXJ2aWNlXzEuZGVjb2RlU2Vzc2lvbikocmVxLnBhcmFtcy5yZWFsbSwgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL2F1dGgvcmVhbG0vOnJlYWxtL3Nlc3Npb24vOmlkXCIsIGZ1bmN0aW9uIChyZXEsIHJlcywgbmV4dCkge1xuICAgICAgICByZXR1cm4gKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKCgwLCBzZXJ2aWNlXzEuZGVsZXRlU2Vzc2lvbikocmVxLnBhcmFtcy5yZWFsbSwgcmVxLCByZXMsIG5leHQpKTtcbiAgICB9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlU2Vzc2lvbiA9IGV4cG9ydHMuZGVjb2RlVG9rZW4gPSBleHBvcnRzLmRlbGV0ZVNlc3Npb24gPSBleHBvcnRzLnZhbGlkYXRlU2Vzc2lvbiA9IGV4cG9ydHMubG9nb3V0ID0gZXhwb3J0cy5pc3N1ZVRva2VuID0gZXhwb3J0cy5zaWduaW4gPSB2b2lkIDA7XG52YXIgYmNyeXB0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJjcnlwdFwiKSk7XG52YXIgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL2xpYi92YWxpZGF0aW9uXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi4vdXNlci9tb2RlbFwiKTtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBkYnV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vbGliL2RidXRpbHNcIik7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xudmFyIHNpZ25pbiA9IGZ1bmN0aW9uIChyZXEsIHJlcywgbmV4dCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF5bG9hZCwgbW9kZWwsIHVzZXIsIG91dGNvbWUsIF9hLCBzZXNzaW9uX2lkLCByZWZyZXNoX3Rva2VuLCBhY2Nlc3NfdG9rZW47XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHJlcS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHZhbGlkYXRpb25fMS52YWxpZGF0ZU1hbmRhdG9yeUZpZWxkcykocmVzLCBwYXlsb2FkLCBbXG4gICAgICAgICAgICAgICAgICAgIFwiZW1haWxcIixcbiAgICAgICAgICAgICAgICAgICAgXCJwYXNzd29yZFwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlYWxtXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVzcG9uc2VfdHlwZVwiLFxuICAgICAgICAgICAgICAgIF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRDb2xsZWN0aW9uKShwYXlsb2FkLnJlYWxtLCBtb2RlbF8xLnVzZXJDb2xsZWN0aW9uLCBtb2RlbF8xLnVzZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZE9uZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogcGF5bG9hZC5lbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib25lYXV0aFwiLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdXNlciA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1cyg0MDQpO1xuICAgICAgICAgICAgICAgICAgICByZXMuc2VuZCh7IGVycm9yOiB7IG1lc3NhZ2U6IFwiVXNlciB3aXRoIHRoaXMgdXNlciBuYW1lIGRvZXMgbm90IGV4aXN0XCIgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXVzZXIuZW1haWxfdmVyaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1cyg0MDMpO1xuICAgICAgICAgICAgICAgICAgICByZXMuc2VuZCh7IGVycm9yOiB7IG1lc3NhZ2U6IFwiRW1haWwgb2YgdXNlciBub3QgdmVyaWZpZWRcIiB9IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYmNyeXB0XzEuZGVmYXVsdC5jb21wYXJlKHBheWxvYWQucGFzc3dvcmQsIHVzZXIuaGFzaCldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvdXRjb21lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoNDAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnNlbmQoeyBlcnJvcjogeyBtZXNzYWdlOiBcIkluY29ycmVjdCBwYXNzd29yZFwiIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuY3JlYXRlU2Vzc2lvbihwYXlsb2FkLnJlYWxtLCB1c2VyKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCksIHNlc3Npb25faWQgPSBfYS5zZXNzaW9uX2lkLCByZWZyZXNoX3Rva2VuID0gX2EucmVmcmVzaF90b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5yZXNwb25zZV90eXBlID09PSBcImNvZGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zZW5kKHsgc2Vzc2lvbl9pZDogc2Vzc2lvbl9pZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0QWNjZXNzVG9rZW4ocmVmcmVzaF90b2tlbildO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbiA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZCh7IHRva2VuX3R5cGU6IFwiQmVhcmVyXCIsIGFjY2Vzc190b2tlbjogYWNjZXNzX3Rva2VuLCByZWZyZXNoX3Rva2VuOiByZWZyZXNoX3Rva2VuIH0pO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuc2lnbmluID0gc2lnbmluO1xudmFyIGlzc3VlVG9rZW4gPSBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBheWxvYWQsIGFjY2Vzc190b2tlbiwgdG9rZW4sIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHJlcS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHZhbGlkYXRpb25fMS52YWxpZGF0ZU1hbmRhdG9yeUZpZWxkcykocmVzLCBwYXlsb2FkLCBbXG4gICAgICAgICAgICAgICAgICAgIFwiZ3JhbnRfdHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInJlYWxtXCIsXG4gICAgICAgICAgICAgICAgICAgIFwicmVmcmVzaF90b2tlblwiLFxuICAgICAgICAgICAgICAgIF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKHBheWxvYWQuZ3JhbnRfdHlwZSA9PT0gXCJyZWZyZXNoX3Rva2VuXCIpKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEFjY2Vzc1Rva2VuKHBheWxvYWQucmVmcmVzaF90b2tlbildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDQwMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zZW5kKHsgZXJyb3I6IHsgbWVzc2FnZTogXCJSZWZyZXNoIHRva2VuIGludmFsaWQgb3IgZXhwaXJlZFwiIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHsgdG9rZW5fdHlwZTogXCJCZWFyZXJcIiwgYWNjZXNzX3Rva2VuOiBhY2Nlc3NfdG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdG9rZW4gPSByZXEucGFyYW1zLnRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlY29kZVRva2VuKHRva2VuKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5pc3N1ZVRva2VuID0gaXNzdWVUb2tlbjtcbnZhciBsb2dvdXQgPSBmdW5jdGlvbiAocmVxLCByZXMsIG5leHQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBheWxvYWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IHJlcS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHZhbGlkYXRpb25fMS52YWxpZGF0ZU1hbmRhdG9yeUZpZWxkcykocmVzLCBwYXlsb2FkLCBbXCJyZWFsbVwiLCBcInJlZnJlc2hfdG9rZW5cIl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZVNlc3Npb25CeVJlZnJlc2hUb2tlbihwYXlsb2FkLnJlYWxtLCBwYXlsb2FkLnJlZnJlc2hfdG9rZW4pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRjb21lLmRlbGV0ZWRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDQwNCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zZW5kKHsgZXJyb3I6IHsgbWVzc2FnZTogXCJJbnZhbGlkIHNlc3Npb25cIiB9IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZCh7IHJlZnJlc2hfdG9rZW46IHBheWxvYWQucmVmcmVzaF90b2tlbiB9KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmxvZ291dCA9IGxvZ291dDtcbnZhciB2YWxpZGF0ZVNlc3Npb24gPSBmdW5jdGlvbiAocmVhbG1JZCwgcmVxLCByZXMsIG5leHQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlc3Npb24sIGVycl8xO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIudmFsaWRhdGVTZXNzaW9uKHJlYWxtSWQsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDQwNCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zZW5kKFwiU2Vzc2lvbiBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHsgc2Vzc2lvbklkOiByZXEucGFyYW1zLmlkLCB0b2tlbjogc2Vzc2lvbi50b2tlbiB9KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBlcnJfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBuZXh0KGVycl8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudmFsaWRhdGVTZXNzaW9uID0gdmFsaWRhdGVTZXNzaW9uO1xudmFyIGRlbGV0ZVNlc3Npb24gPSBmdW5jdGlvbiAocmVhbG1JZCwgcmVxLCByZXMsIG5leHQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZVNlc3Npb24oc2VsZlJlYWxtLCByZXEucGFyYW1zLmlkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0Y29tZS5kZWxldGVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1cyg0MDQpO1xuICAgICAgICAgICAgICAgICAgICByZXMuc2VuZChcIlNlc3Npb24gbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZCh7IHNlc3Npb25JZDogcmVxLnBhcmFtcy5pZCB9KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZVNlc3Npb24gPSBkZWxldGVTZXNzaW9uO1xudmFyIGRlY29kZVRva2VuID0gZnVuY3Rpb24gKHJlcSwgcmVzLCBuZXh0KSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICByZXMuc2VuZChfX2Fzc2lnbih7fSwgcmVxLnVzZXIpKTtcbiAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICByZXR1cm4gWzJdO1xuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlY29kZVRva2VuID0gZGVjb2RlVG9rZW47XG52YXIgZGVjb2RlU2Vzc2lvbiA9IGZ1bmN0aW9uIChyZWFsbUlkLCByZXEsIHJlcywgbmV4dCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0Y29tZSwgZXJyXzI7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWNvZGVTZXNzaW9uKHNlbGZSZWFsbSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvdXRjb21lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoNDA0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnNlbmQoXCJTZXNzaW9uIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZXJyXzIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgbmV4dChlcnJfMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlY29kZVNlc3Npb24gPSBkZWNvZGVTZXNzaW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZENoYXB0ZXJzID0gZXhwb3J0cy5kZWxldGVCb29rQ2hhcHRlckJ5UmVmZXJlbmNlID0gZXhwb3J0cy5kZWxldGVCb29rQ2hhcHRlciA9IGV4cG9ydHMuZ2V0Qm9va0NoYXB0ZXJCeUlkID0gZXhwb3J0cy5nZXRCb29rQ2hhcHRlckJ5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0Qm9va0NoYXB0ZXJzQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy5nZXRCb29rQ2hhcHRlciA9IGV4cG9ydHMudXBkYXRlQm9va0NoYXB0ZXIgPSBleHBvcnRzLmNyZWF0ZUJvb2tDaGFwdGVyID0gZXhwb3J0cy5nZW5lcmF0ZUNoYXB0ZXJzID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIEJvb2tIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2hlbHBlclwiKSk7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4uLy4uL3NlcXVlbmNlL3NlcnZpY2VcIik7XG52YXIgR3B0dXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9ncHR1dGlsc1wiKSk7XG52YXIgcHJvbXB0XzEgPSByZXF1aXJlKFwiLi9wcm9tcHRcIik7XG52YXIgZ2V0Q29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZGJ1dGlsc1wiKS5nZXRDb2xsZWN0aW9uO1xudmFyIEFJX0FQSSA9IHByb2Nlc3MuZW52LkFJX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMy9hcGlcIjtcbnZhciBnZW5lcmF0ZUNoYXB0ZXJzID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBib29rLCBncHRSZXNwb25zZVRleHQsIGdwdFJlc3BvbnNlLCBtb2RlbCwgX3BheWxvYWQsIGksIF9hLCBfYjtcbiAgICB2YXIgX2MsIF9kLCBfZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBCb29rSGVscGVyLmdldEJvb2tCeVJlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYm9vayA9PT0gbnVsbCB8fCBib29rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib29rLmlzYm4pO1xuICAgICAgICAgICAgICAgIGlmICghYm9vayB8fCAhYm9vay5pc01hbmFnZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBHcHR1dGlscy5wcmVkaWN0KCgwLCBwcm9tcHRfMS5nZXRCb29rQ2hhcHRlcnNQcm9tcHQpKGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvcikpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZVRleHQgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZSA9IEpTT04ucGFyc2UoZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhncHRSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFncHRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NoYXB0ZXJDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tDaGFwdGVyU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZCA9IFtdO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gMztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgZ3B0UmVzcG9uc2UubGVuZ3RoKSkgcmV0dXJuIFszLCA2XTtcbiAgICAgICAgICAgICAgICBfYiA9IChfYSA9IF9wYXlsb2FkKS5wdXNoO1xuICAgICAgICAgICAgICAgIF9jID0ge307XG4gICAgICAgICAgICAgICAgX2QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGdwdFJlc3BvbnNlW2ldLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZ3B0UmVzcG9uc2VbaV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIHNlcnZpY2VfMS5uZXh0dmFsKShcImNoYXB0ZXJJZFwiLCBib29rcmVmLCBzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF9iLmFwcGx5KF9hLCBbKF9jLnVwZGF0ZU9uZSA9IChfZC51cGRhdGUgPSAoX2UucmVmZXJlbmNlID0gX2Yuc2VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2QudXBzZXJ0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKV0pO1xuICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gNTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFs0LCBtb2RlbC5idWxrV3JpdGUoX3BheWxvYWQpXTtcbiAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyLCBfZi5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2VuZXJhdGVDaGFwdGVycyA9IGdlbmVyYXRlQ2hhcHRlcnM7XG52YXIgY3JlYXRlQm9va0NoYXB0ZXIgPSBmdW5jdGlvbiAoc3BhY2VfMSwgX2EsIHVzZXJJZF8xKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbc3BhY2VfMSwgX2EsIHVzZXJJZF8xXSwgdm9pZCAwLCBmdW5jdGlvbiAoc3BhY2UsIF9iLCB1c2VySWQpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgIHZhciBib29rQ2hhcHRlciA9IF9iLmJvb2tDaGFwdGVyLCBtZXRhID0gX2IubWV0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NoYXB0ZXJDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tDaGFwdGVyU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5jcmVhdGUoX19hc3NpZ24oe30sIGJvb2tDaGFwdGVyKSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVCb29rQ2hhcHRlciA9IGNyZWF0ZUJvb2tDaGFwdGVyO1xudmFyIHVwZGF0ZUJvb2tDaGFwdGVyID0gZnVuY3Rpb24gKHNwYWNlLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZSwgYm9va0NoYXB0ZXJSZXNwb25zZSwgYm9va0NoYXB0ZXI7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDaGFwdGVyQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ2hhcHRlclNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5faWQpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShkYXRhLl9pZCwgZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBzZXJ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0LCBtb2RlbC5jcmVhdGUoX19hc3NpZ24oe30sIGRhdGEpKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQsIG1vZGVsLmZpbmQoe1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHJlc3BvbnNlLnJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgYm9va0NoYXB0ZXJSZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBib29rQ2hhcHRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGJvb2tDaGFwdGVyUmVzcG9uc2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBib29rQ2hhcHRlciA9IGJvb2tDaGFwdGVyUmVzcG9uc2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va0NoYXB0ZXI6IGJvb2tDaGFwdGVyLFxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZUJvb2tDaGFwdGVyID0gdXBkYXRlQm9va0NoYXB0ZXI7XG52YXIgZ2V0Qm9va0NoYXB0ZXIgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXM7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDaGFwdGVyQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ2hhcHRlclNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc107XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rQ2hhcHRlciA9IGdldEJvb2tDaGFwdGVyO1xudmFyIGdldEJvb2tDaGFwdGVyc0J5Qm9va1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDaGFwdGVyQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ2hhcHRlclNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgYm9va3JlZjogYm9va3JlZiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tDaGFwdGVyc0J5Qm9va1JlZmVyZW5jZSA9IGdldEJvb2tDaGFwdGVyc0J5Qm9va1JlZmVyZW5jZTtcbnZhciBnZXRCb29rQ2hhcHRlckJ5Qm9va1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgY2hhcHRlcnJlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ2hhcHRlckNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va0NoYXB0ZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYsIHJlZmVyZW5jZTogY2hhcHRlcnJlZiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZVswXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rQ2hhcHRlckJ5Qm9va1JlZmVyZW5jZSA9IGdldEJvb2tDaGFwdGVyQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldEJvb2tDaGFwdGVyQnlJZCA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ2hhcHRlckNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va0NoYXB0ZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IF9pZDogX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tDaGFwdGVyQnlJZCA9IGdldEJvb2tDaGFwdGVyQnlJZDtcbnZhciBkZWxldGVCb29rQ2hhcHRlciA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NoYXB0ZXJDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tDaGFwdGVyU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyBfaWQ6IF9pZCB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBib29rQ2hhcHRlcjogX2lkIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQm9va0NoYXB0ZXIgPSBkZWxldGVCb29rQ2hhcHRlcjtcbnZhciBkZWxldGVCb29rQ2hhcHRlckJ5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ2hhcHRlckNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va0NoYXB0ZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IHJlZmVyZW5jZTogcmVmZXJlbmNlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGJvb2tDaGFwdGVyOiByZWZlcmVuY2UgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rQ2hhcHRlckJ5UmVmZXJlbmNlID0gZGVsZXRlQm9va0NoYXB0ZXJCeVJlZmVyZW5jZTtcbnZhciBhZGRDaGFwdGVycyA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgY2hhcHRlclRpdGxlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIF9wYXlsb2FkLCBpLCBfYSwgX2I7XG4gICAgdmFyIF9jLCBfZCwgX2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDaGFwdGVyQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ2hhcHRlclNjaGVtYSk7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQgPSBbXTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IGNoYXB0ZXJUaXRsZXMubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICBfYiA9IChfYSA9IF9wYXlsb2FkKS5wdXNoO1xuICAgICAgICAgICAgICAgIF9jID0ge307XG4gICAgICAgICAgICAgICAgX2QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGNoYXB0ZXJUaXRsZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9lID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjaGFwdGVyVGl0bGVzW2ldXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBzZXJ2aWNlXzEubmV4dHZhbCkoXCJjaGFwdGVySWRcIiwgYm9va3JlZiwgc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfYi5hcHBseShfYSwgWyhfYy51cGRhdGVPbmUgPSAoX2QudXBkYXRlID0gKF9lLnJlZmVyZW5jZSA9IF9mLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLnVwc2VydCA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBfZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyldKTtcbiAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDM7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCwgbW9kZWwuYnVsa1dyaXRlKF9wYXlsb2FkKV07XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiwgX2Yuc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmFkZENoYXB0ZXJzID0gYWRkQ2hhcHRlcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9va0NoYXB0ZXJDb2xsZWN0aW9uID0gZXhwb3J0cy5ib29rQ2hhcHRlclNjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgYm9va0NoYXB0ZXJTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHJlZmVyZW5jZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBib29rcmVmOiB7IHR5cGU6IFN0cmluZyB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlLCBzdHJpY3Q6IGZhbHNlLCBzdHJpY3RRdWVyeTogZmFsc2UgfSk7XG5leHBvcnRzLmJvb2tDaGFwdGVyU2NoZW1hID0gYm9va0NoYXB0ZXJTY2hlbWE7XG52YXIgYm9va0NoYXB0ZXJDb2xsZWN0aW9uID0gXCJib29rLmNoYXB0ZXJcIjtcbmV4cG9ydHMuYm9va0NoYXB0ZXJDb2xsZWN0aW9uID0gYm9va0NoYXB0ZXJDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Qm9va0NoYXB0ZXJzUHJvbXB0ID0gdm9pZCAwO1xudmFyIEhhbmRsZWJhcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImhhbmRsZWJhcnNcIikpO1xudmFyIGxvZGFzaF8xID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbnZhciBfTU9ERUxfTkFNRV9HUFQzID0gXCJncHQtMy41LXR1cmJvXCI7XG52YXIgX01PREVMX05BTUVfR1BUNCA9IFwiZ3B0LTRvXCI7XG52YXIgX01PREVMX05BTUUgPSBwcm9jZXNzLmVudi5DSEFUR1BUX01PREVMX05BTUUgfHwgXCJncHQtNG8tbWluaVwiO1xuO1xudmFyIGdldEJvb2tDaGFwdGVyc1Byb21wdCA9IGZ1bmN0aW9uIChib29rTmFtZSwgYXV0aG9yTmFtZSkge1xuICAgIHZhciBwcm9tcHQgPSAoMCwgbG9kYXNoXzEuY2xvbmVEZWVwKShfQk9PS19DSEFQVEVSU19QUk9NUFQpO1xuICAgIHByb21wdC5tZXNzYWdlc1twcm9tcHQubWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudCA9IEhhbmRsZWJhcnMuY29tcGlsZShwcm9tcHQubWVzc2FnZXNbcHJvbXB0Lm1lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQpKHtcbiAgICAgICAgYm9va05hbWU6IGJvb2tOYW1lLFxuICAgICAgICBhdXRob3JOYW1lOiBhdXRob3JOYW1lLFxuICAgICAgICBtb2RlbE5hbWU6IF9NT0RFTF9OQU1FLFxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKHByb21wdCk7XG4gICAgcmV0dXJuIHByb21wdDtcbn07XG5leHBvcnRzLmdldEJvb2tDaGFwdGVyc1Byb21wdCA9IGdldEJvb2tDaGFwdGVyc1Byb21wdDtcbnZhciBfQk9PS19DSEFQVEVSU19QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIllvdSBhcmUgYSBoZWxwZnVsIGFzc2lzdGFudCBkZXNpZ25lZCB0byByZXRyaWV2ZSBhbmQgcHJvdmlkZSBhY2N1cmF0ZSBib29rIGNoYXB0ZXIgdGl0bGVzLiBZb3VyIHRhc2sgaXMgdG8gcHJvY2VzcyBhIGdpdmVuIGJvb2sgbmFtZSBhbmQgYXV0aG9yIG5hbWUgdG8gZ2VuZXJhdGUgYSBKU09OIGFycmF5IG9mIGNoYXB0ZXIgdGl0bGVzIGluIHN0cmluZyBmb3JtYXQuIEVuc3VyZSB0aGF0IHRoZSB0aXRsZXMgYXJlIHJldHVybmVkIGFzIGFjY3VyYXRlbHkgYXMgcG9zc2libGUuIFRoZSBpbnB1dCB3aWxsIGluY2x1ZGUgcGxhY2Vob2xkZXJzIGZvciBib29rTmFtZSBhbmQgYXV0aG9yTmFtZS4gRG8gbm90IGluY2x1ZGUgYW55IGFkZGl0aW9uYWwgZGV0YWlscyBvdXRzaWRlIG9mIHRoZSBjaGFwdGVyIHRpdGxlcy5cIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIlBsZWFzZSBnZXQgdGhlIGxpc3Qgb2YgY2hhcHRlcnMgZm9yIHRoZSBib29rIHRpdGxlZCAne3tib29rTmFtZX19JyBieSAne3thdXRob3JOYW1lfX0nIGFuZCByZXR1cm4gdGhlbSBhcyBhIEpTT04gYXJyYXkgb2Ygc3RyaW5ncy5cIixcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIucHV0KFwiL2Jvb2svY2hhcHRlci86c3BhY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEudXBkYXRlQm9va0NoYXB0ZXIpKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rL2NoYXB0ZXIvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmNyZWF0ZUJvb2tDaGFwdGVyKSk7XG4gICAgcm91dGVyLnBvc3QoXCIvYm9vay9jaGFwdGVyLzpzcGFjZS86Ym9va3JlZi9nZW5lcmF0ZS1jaGFwdGVyc1wiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZW5lcmF0ZUNoYXB0ZXJzKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL2NoYXB0ZXIvOnNwYWNlL2lkLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRCb29rQ2hhcHRlckJ5SWQpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2Jvb2svY2hhcHRlci86c3BhY2UvOmJvb2tyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Qm9va0NoYXB0ZXJzQnlCb29rUmVmZXJlbmNlKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL2NoYXB0ZXIvOnNwYWNlLzpib29rcmVmLzpjaGFwdGVycmVmXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldEJvb2tDaGFwdGVyQnlCb29rUmVmZXJlbmNlKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ib29rL2NoYXB0ZXIvOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVCb29rQ2hhcHRlcikpO1xuICAgIHJvdXRlci5kZWxldGUoXCIvYm9vay9jaGFwdGVyLzpzcGFjZS9yZWZlcmVuY2UvOnJlZmVyZW5jZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVCb29rQ2hhcHRlckJ5UmVmZXJlbmNlKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVsZXRlQm9va0NoYXB0ZXJCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZGVsZXRlQm9va0NoYXB0ZXIgPSBleHBvcnRzLmdldEJvb2tDaGFwdGVyQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy5nZXRCb29rQ2hhcHRlcnNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tDaGFwdGVyQnlJZCA9IGV4cG9ydHMuZ2V0Qm9va0NoYXB0ZXIgPSBleHBvcnRzLnVwZGF0ZUJvb2tDaGFwdGVyID0gZXhwb3J0cy5jcmVhdGVCb29rQ2hhcHRlciA9IGV4cG9ydHMuZ2VuZXJhdGVDaGFwdGVycyA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBnZW5lcmF0ZUNoYXB0ZXJzID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2VuZXJhdGVDaGFwdGVycyhyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoNDA0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBcIklTQk4gbm90IGZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zZW5kKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2VuZXJhdGVDaGFwdGVycyA9IGdlbmVyYXRlQ2hhcHRlcnM7XG52YXIgY3JlYXRlQm9va0NoYXB0ZXIgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va0NoYXB0ZXI7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5jcmVhdGVCb29rQ2hhcHRlcihyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va0NoYXB0ZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvb2tDaGFwdGVyKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmNyZWF0ZUJvb2tDaGFwdGVyID0gY3JlYXRlQm9va0NoYXB0ZXI7XG52YXIgdXBkYXRlQm9va0NoYXB0ZXIgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va0NoYXB0ZXI7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci51cGRhdGVCb29rQ2hhcHRlcihyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va0NoYXB0ZXIgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvb2tDaGFwdGVyKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZUJvb2tDaGFwdGVyID0gdXBkYXRlQm9va0NoYXB0ZXI7XG52YXIgZ2V0Qm9va0NoYXB0ZXIgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va0NoYXB0ZXJMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va0NoYXB0ZXIocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tDaGFwdGVyTGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va0NoYXB0ZXJMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tDaGFwdGVyID0gZ2V0Qm9va0NoYXB0ZXI7XG52YXIgZ2V0Qm9va0NoYXB0ZXJCeUlkID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tDaGFwdGVyO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va0NoYXB0ZXJCeUlkKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rQ2hhcHRlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va0NoYXB0ZXIpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0NoYXB0ZXJCeUlkID0gZ2V0Qm9va0NoYXB0ZXJCeUlkO1xudmFyIGdldEJvb2tDaGFwdGVyc0J5Qm9va1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rQ2hhcHRlcjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEJvb2tDaGFwdGVyc0J5Qm9va1JlZmVyZW5jZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rQ2hhcHRlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va0NoYXB0ZXIpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0NoYXB0ZXJzQnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va0NoYXB0ZXJzQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldEJvb2tDaGFwdGVyQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tDaGFwdGVyO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va0NoYXB0ZXJCeUJvb2tSZWZlcmVuY2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmLCByZXEucGFyYW1zLmNoYXB0ZXJyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rQ2hhcHRlciA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va0NoYXB0ZXIpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0NoYXB0ZXJCeUJvb2tSZWZlcmVuY2UgPSBnZXRCb29rQ2hhcHRlckJ5Qm9va1JlZmVyZW5jZTtcbnZhciBkZWxldGVCb29rQ2hhcHRlciA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlQm9va0NoYXB0ZXIocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG91dGNvbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQm9va0NoYXB0ZXIgPSBkZWxldGVCb29rQ2hhcHRlcjtcbnZhciBkZWxldGVCb29rQ2hhcHRlckJ5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWxldGVCb29rQ2hhcHRlckJ5UmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rQ2hhcHRlckJ5UmVmZXJlbmNlID0gZGVsZXRlQm9va0NoYXB0ZXJCeVJlZmVyZW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRDb25jZXB0cyA9IGV4cG9ydHMuZGVsZXRlQm9va0NvbmNlcHRCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZGVsZXRlQm9va0NvbmNlcHQgPSBleHBvcnRzLmdldEJvb2tDb25jZXB0QnlJZCA9IGV4cG9ydHMuZ2V0Qm9va0NvbmNlcHRCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tDb25jZXB0c0J5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0Qm9va0NvbmNlcHQgPSBleHBvcnRzLnVwZGF0ZUJvb2tDb25jZXB0ID0gZXhwb3J0cy5jcmVhdGVCb29rQ29uY2VwdCA9IGV4cG9ydHMuZ2VuZXJhdGVDb25jZXB0cyA9IHZvaWQgMDtcbnZhciBheGlvcyA9IHJlcXVpcmUoXCJheGlvc1wiKTtcbnZhciBPTkVBVVRIX0FQSSA9IHByb2Nlc3MuZW52Lk9ORUFVVEhfQVBJIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo0MDEwL2FwaVwiO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbnZhciBCb29rSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9oZWxwZXJcIikpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZXF1ZW5jZS9zZXJ2aWNlXCIpO1xudmFyIEdwdHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZ3B0dXRpbHNcIikpO1xudmFyIHByb21wdF8xID0gcmVxdWlyZShcIi4vcHJvbXB0XCIpO1xudmFyIGhlbHBlcl8xID0gcmVxdWlyZShcIi4uL3RoZW1lL2hlbHBlclwiKTtcbnZhciBnZXRDb2xsZWN0aW9uID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9kYnV0aWxzXCIpLmdldENvbGxlY3Rpb247XG52YXIgQUlfQVBJID0gcHJvY2Vzcy5lbnYuQUlfQVBJIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo1MDAzL2FwaVwiO1xudmFyIFNJTUlMQVJJVFlfQUxHT1JJVEhNID0gXCJzaW1pbGFyaXR5XCI7XG52YXIgZ2VuZXJhdGVDb25jZXB0cyA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vaywgcHJvbXB0LCBncHRSZXNwb25zZVRleHQsIGdwdFJlc3BvbnNlLCBtb2RlbCwgX3BheWxvYWQsIGksIF9hLCBfYiwgY29uY2VwdHMsIGk7XG4gICAgdmFyIF9jLCBfZCwgX2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgQm9va0hlbHBlci5nZXRCb29rQnlSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghYm9vayB8fCAhYm9vay5pc01hbmFnZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvbXB0ID0gKDAsIHByb21wdF8xLmdldEJvb2tDb25jZXB0c1Byb21wdCkoYm9vay50aXRsZSwgYm9vay5wcmltYXJ5QXV0aG9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0eXBlb2YgcHJvbXB0Lm1lc3NhZ2VzWzBdLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgR3B0dXRpbHMucHJlZGljdCgoMCwgcHJvbXB0XzEuZ2V0Qm9va0NvbmNlcHRzUHJvbXB0KShib29rLnRpdGxlLCBib29rLnByaW1hcnlBdXRob3IpKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2VUZXh0ID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2UgPSBKU09OLnBhcnNlKGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZ3B0UmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGlmICghZ3B0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb25jZXB0Q29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ29uY2VwdFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQgPSBbXTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDM7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IGdwdFJlc3BvbnNlLmxlbmd0aCkpIHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBfcGF5bG9hZCkucHVzaDtcbiAgICAgICAgICAgICAgICBfYyA9IHt9O1xuICAgICAgICAgICAgICAgIF9kID0ge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2tyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBncHRSZXNwb25zZVtpXS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGdwdFJlc3BvbnNlW2ldLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZ3B0UmVzcG9uc2VbaV0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lczogZ3B0UmVzcG9uc2VbaV0udGhlbWVzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBzZXJ2aWNlXzEubmV4dHZhbCkoXCJjb25jZXB0SWRcIiwgYm9va3JlZiwgc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfYi5hcHBseShfYSwgWyhfYy51cGRhdGVPbmUgPSAoX2QudXBkYXRlID0gKF9lLnJlZmVyZW5jZSA9IF9mLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLnVwc2VydCA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBfZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyldKTtcbiAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDU7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IGJvb2tyZWY6IGJvb2tyZWYgfSldO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmJ1bGtXcml0ZShfcGF5bG9hZCldO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyBib29rcmVmOiBib29rcmVmIH0pXTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBjb25jZXB0cyA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDEwO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgY29uY2VwdHMubGVuZ3RoKSkgcmV0dXJuIFszLCAxM107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgaGVscGVyXzEuYWRkVGhlbWVzKShzcGFjZSwgYm9va3JlZiwgY29uY2VwdHNbaV0ucmVmZXJlbmNlLCBjb25jZXB0c1tpXS50aGVtZXMpXTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gMTI7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDEwXTtcbiAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBbMiwgY29uY2VwdHNdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2VuZXJhdGVDb25jZXB0cyA9IGdlbmVyYXRlQ29uY2VwdHM7XG52YXIgY3JlYXRlQm9va0NvbmNlcHQgPSBmdW5jdGlvbiAoc3BhY2VfMSwgX2EsIHVzZXJJZF8xKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbc3BhY2VfMSwgX2EsIHVzZXJJZF8xXSwgdm9pZCAwLCBmdW5jdGlvbiAoc3BhY2UsIF9iLCB1c2VySWQpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgIHZhciBib29rQ29uY2VwdCA9IF9iLmJvb2tDb25jZXB0LCBtZXRhID0gX2IubWV0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NvbmNlcHRDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tDb25jZXB0U2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5jcmVhdGUoX19hc3NpZ24oe30sIGJvb2tDb25jZXB0KSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVCb29rQ29uY2VwdCA9IGNyZWF0ZUJvb2tDb25jZXB0O1xudmFyIHVwZGF0ZUJvb2tDb25jZXB0ID0gZnVuY3Rpb24gKHNwYWNlLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZSwgYm9va0NvbmNlcHRSZXNwb25zZSwgYm9va0NvbmNlcHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb25jZXB0Q29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ29uY2VwdFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5faWQpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShkYXRhLl9pZCwgZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBzZXJ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0LCBtb2RlbC5jcmVhdGUoX19hc3NpZ24oe30sIGRhdGEpKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQsIG1vZGVsLmZpbmQoe1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHJlc3BvbnNlLnJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgYm9va0NvbmNlcHRSZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBib29rQ29uY2VwdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGJvb2tDb25jZXB0UmVzcG9uc2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBib29rQ29uY2VwdCA9IGJvb2tDb25jZXB0UmVzcG9uc2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va0NvbmNlcHQ6IGJvb2tDb25jZXB0LFxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZUJvb2tDb25jZXB0ID0gdXBkYXRlQm9va0NvbmNlcHQ7XG52YXIgX2FpX3BvcHVsYXRlX2Zvcl9jb25jZXB0ID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVycl8xO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJvb2tyZWYsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBheGlvcy5nZXQoXCJcIi5jb25jYXQoQUlfQVBJLCBcIi9cIikuY29uY2F0KFNJTUlMQVJJVFlfQUxHT1JJVEhNLCBcIi9cIikuY29uY2F0KHNwYWNlLCBcIi9wb3B1bGF0ZS1jb25jZXB0L1wiKS5jb25jYXQoYm9va3JlZiwgXCIvXCIpLmNvbmNhdChyZWZlcmVuY2UpLCB7fSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInBvcHVsYXRlZCBrZXl3b3JkcyBmb3IgXCIgKyBib29rcmVmICsgXCIsIFwiICsgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVycl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbnZhciBnZXRCb29rQ29uY2VwdCA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NvbmNlcHRDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tDb25jZXB0U2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tDb25jZXB0ID0gZ2V0Qm9va0NvbmNlcHQ7XG52YXIgZ2V0Qm9va0NvbmNlcHRzQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NvbmNlcHRDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tDb25jZXB0U2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyBib29rcmVmOiBib29rcmVmIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0NvbmNlcHRzQnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va0NvbmNlcHRzQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldEJvb2tDb25jZXB0QnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb25jZXB0Q29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ29uY2VwdFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgYm9va3JlZjogYm9va3JlZiwgcmVmZXJlbmNlOiBjb25jZXB0cmVmIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3BvbnNlWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tDb25jZXB0QnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va0NvbmNlcHRCeUJvb2tSZWZlcmVuY2U7XG52YXIgZ2V0Qm9va0NvbmNlcHRCeUlkID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXM7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb25jZXB0Q29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ29uY2VwdFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0NvbmNlcHRCeUlkID0gZ2V0Qm9va0NvbmNlcHRCeUlkO1xudmFyIGRlbGV0ZUJvb2tDb25jZXB0ID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ29uY2VwdENvbGxlY3Rpb24sIG1vZGVsXzEuYm9va0NvbmNlcHRTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IF9pZDogX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGJvb2tDb25jZXB0OiBfaWQgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rQ29uY2VwdCA9IGRlbGV0ZUJvb2tDb25jZXB0O1xudmFyIGRlbGV0ZUJvb2tDb25jZXB0QnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAoc3BhY2UsIHJlZmVyZW5jZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb25jZXB0Q29sbGVjdGlvbiwgbW9kZWxfMS5ib29rQ29uY2VwdFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgcmVmZXJlbmNlOiByZWZlcmVuY2UgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgYm9va0NvbmNlcHQ6IHJlZmVyZW5jZSB9XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUJvb2tDb25jZXB0QnlSZWZlcmVuY2UgPSBkZWxldGVCb29rQ29uY2VwdEJ5UmVmZXJlbmNlO1xudmFyIGFkZENvbmNlcHRzID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBjb25jZXB0VGl0bGVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgX3BheWxvYWQsIGksIF9hLCBfYjtcbiAgICB2YXIgX2MsIF9kLCBfZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NvbmNlcHRDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tDb25jZXB0U2NoZW1hKTtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZCA9IFtdO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgY29uY2VwdFRpdGxlcy5sZW5ndGgpKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgIF9iID0gKF9hID0gX3BheWxvYWQpLnB1c2g7XG4gICAgICAgICAgICAgICAgX2MgPSB7fTtcbiAgICAgICAgICAgICAgICBfZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY29uY2VwdFRpdGxlc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGNvbmNlcHRUaXRsZXNbaV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIHNlcnZpY2VfMS5uZXh0dmFsKShcImNvbmNlcHRJZFwiLCBib29rcmVmLCBzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9iLmFwcGx5KF9hLCBbKF9jLnVwZGF0ZU9uZSA9IChfZC51cGRhdGUgPSAoX2UucmVmZXJlbmNlID0gX2Yuc2VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2QudXBzZXJ0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKV0pO1xuICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gMztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxXTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0LCBtb2RlbC5idWxrV3JpdGUoX3BheWxvYWQpXTtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyLCBfZi5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuYWRkQ29uY2VwdHMgPSBhZGRDb25jZXB0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29rQ29uY2VwdENvbGxlY3Rpb24gPSBleHBvcnRzLmJvb2tDb25jZXB0U2NoZW1hID0gdm9pZCAwO1xudmFyIG1vbmdvb3NlID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpO1xudmFyIFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbnZhciBib29rQ29uY2VwdFNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgZGVzY3JpcHRpb246IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgcmVmZXJlbmNlOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGJvb2tyZWY6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdGhlbWVzOiB7IHR5cGU6IEFycmF5IH0sXG59LCB7IHRpbWVzdGFtcHM6IHRydWUsIHN0cmljdDogZmFsc2UsIHN0cmljdFF1ZXJ5OiBmYWxzZSB9KTtcbmV4cG9ydHMuYm9va0NvbmNlcHRTY2hlbWEgPSBib29rQ29uY2VwdFNjaGVtYTtcbnZhciBib29rQ29uY2VwdENvbGxlY3Rpb24gPSBcImJvb2suY29uY2VwdFwiO1xuZXhwb3J0cy5ib29rQ29uY2VwdENvbGxlY3Rpb24gPSBib29rQ29uY2VwdENvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Qm9va0NvbmNlcHRzUHJvbXB0ID0gdm9pZCAwO1xudmFyIGdwdHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2dwdHV0aWxzXCIpO1xudmFyIF9NT0RFTF9OQU1FX0dQVDMgPSBcImdwdC0zLjUtdHVyYm9cIjtcbnZhciBfTU9ERUxfTkFNRV9HUFQ0ID0gXCJncHQtNG9cIjtcbnZhciBfTU9ERUxfTkFNRV9HUFQ0X01JTkkgPSBcImdwdC00by1taW5pXCI7XG52YXIgX01PREVMX05BTUUgPSBwcm9jZXNzLmVudi5DSEFUR1BUX01PREVMX05BTUUgfHwgXCJncHQtNG8tbWluaVwiO1xudmFyIGdldEJvb2tDb25jZXB0c1Byb21wdCA9IGZ1bmN0aW9uIChib29rTmFtZSwgYXV0aG9yTmFtZSkge1xuICAgIHJldHVybiAoMCwgZ3B0dXRpbHNfMS5nZXRQcm9tcHQpKF9CT09LX0NPTkNFUFRTX1BST01QVCwge1xuICAgICAgICBib29rTmFtZTogYm9va05hbWUsXG4gICAgICAgIGF1dGhvck5hbWU6IGF1dGhvck5hbWUsXG4gICAgICAgIG1vZGVsTmFtZTogX01PREVMX05BTUUsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5nZXRCb29rQ29uY2VwdHNQcm9tcHQgPSBnZXRCb29rQ29uY2VwdHNQcm9tcHQ7XG52YXIgX0JPT0tfQ09OQ0VQVFNfUFJPTVBUID0ge1xuICAgIG1vZGVsOiBfTU9ERUxfTkFNRSxcbiAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBcInJvbGVcIjogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIFwiY29udGVudFwiOiBbXG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGFuIEFJIGFzc2lzdGFudCB0YXNrZWQgd2l0aCBnZW5lcmF0aW5nIGxpc3RzIG9mIGtleSBjb25jZXB0cyBmcm9tIGJvb2tzO1wiLFxuICAgICAgICAgICAgICAgIFwiWW91ciBnb2FsIGlzIHRvIGV4dHJhY3QgYSBicm9hZCByYW5nZSBvZiBpbXBvcnRhbnQgY29uY2VwdHMgZnJvbSB0aGUgYm9vayBhbmQgcHJvdmlkZSBkZXRhaWxlZCB5ZXQgY29uY2lzZSBkZXNjcmlwdGlvbnMgZm9yIGVhY2g7XCIsXG4gICAgICAgICAgICAgICAgXCJFYWNoIGNvbmNlcHQgZGVzY3JpcHRpb24gc2hvdWxkIGZpdCBpbnRvIGEgc2luZ2xlIHBhcmFncmFwaDtcIixcbiAgICAgICAgICAgICAgICBcIklkZW50aWZ5IGFuZCBpbmNsdWRlIGtleSBjb25jZXB0cyBmcm9tIHRoZSBib29rIGJhc2VkIG9uIGl0cyBjb250ZW50O1wiLFxuICAgICAgICAgICAgICAgIFwiRm9yIGVhY2gga2V5IGNvbmNlcHQsIHByb3ZpZGUgYSBmbGV4aWJsZSBudW1iZXIgb2YgdGhlbWVzIHJlbGF0ZWQgdG8gdGhhdCBjb25jZXB0LiBJbmNsdWRlIGFzIG1hbnkgdGhlbWVzIGFzIGFyZSBhcHBsaWNhYmxlIGJ1dCBkbyBub3QgZW5mb3JjZSBhIHN0cmljdCBudW1iZXI7XCIsXG4gICAgICAgICAgICAgICAgXCJFYWNoIHRoZW1lIHNob3VsZCBiZSByZXByZXNlbnRlZCBhcyBhbiBvYmplY3Qgd2l0aCAndGl0bGUnIGFuZCAnZGVzY3JpcHRpb24nIGZpZWxkcztcIixcbiAgICAgICAgICAgICAgICBcIlRoZSAndGl0bGUnIG9mIGVhY2ggdGhlbWUgc2hvdWxkIGJlIGEgdW5pcXVlIG5hbWUsIGFuZCB0aGUgJ2Rlc2NyaXB0aW9uJyBzaG91bGQgcHJvdmlkZSBjb250ZXh0IGFib3V0IHRoZSB0aGVtZTtcIixcbiAgICAgICAgICAgICAgICBcIkVhY2ggdGhlbWUgbWF5IGhhdmUgYSBmbGV4aWJsZSBudW1iZXIgb2Ygc3ViLXRoZW1lcy4gSW5jbHVkZSBhcyBtYW55IHN1Yi10aGVtZXMgYXMgYXJlIGFwcGxpY2FibGUsIGJ1dCBkbyBub3QgZW5mb3JjZSBhIHN0cmljdCBudW1iZXI7XCIsXG4gICAgICAgICAgICAgICAgXCJFYWNoIHN1Yi10aGVtZSBzaG91bGQgYmUgcmVwcmVzZW50ZWQgYXMgYW4gb2JqZWN0IHdpdGggJ3RpdGxlJyBhbmQgJ2Rlc2NyaXB0aW9uJyBmaWVsZHM7XCIsXG4gICAgICAgICAgICAgICAgXCJFbnN1cmUgdGhhdCBhbGwgdGhlbWVzIGFuZCBzdWItdGhlbWVzIGFjcm9zcyBhbGwga2V5IGNvbmNlcHRzIGFyZSB1bmlxdWUgaW4gdGhlaXIgbWVhbmluZyBhbmQgY29udGVudCB0byBhdm9pZCByZWR1bmRhbmN5O1wiLFxuICAgICAgICAgICAgICAgIFwiUHJvdmlkZSB0aGUgb3V0cHV0IGFzIGEgSlNPTiBhcnJheSwgd2hlcmUgZWFjaCBvYmplY3QgcmVwcmVzZW50cyBhIGtleSBjb25jZXB0IGFuZCBpbmNsdWRlcyAndGl0bGUnLCAnZGVzY3JpcHRpb24nLCBhbmQgYSAndGhlbWVzJyBmaWVsZDtcIixcbiAgICAgICAgICAgICAgICBcIlRoZSAndGhlbWVzJyBmaWVsZCBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBjb250YWluaW5nICd0aXRsZScgYW5kICdkZXNjcmlwdGlvbicsIGFuZCBvcHRpb25hbGx5IGEgJ3N1YlRoZW1lcycgZmllbGQsIHdoaWNoIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCAndGl0bGUnIGFuZCAnZGVzY3JpcHRpb24nLlwiLFxuICAgICAgICAgICAgICAgIFwiRW5zdXJlIHRoZSBKU09OIG91dHB1dCBpcyBwcm9wZXJseSBmb3JtYXR0ZWQgd2l0aCBjb3JyZWN0IHF1b3RhdGlvbiBhbmQgY29tbWEgcGxhY2VtZW50OlwiLFxuICAgICAgICAgICAgICAgIFwiMS4gUHJvcGVydHkgbmFtZXMgYW5kIHN0cmluZyB2YWx1ZXMgbXVzdCBiZSBlbmNsb3NlZCBpbiBkb3VibGUgcXVvdGVzLlwiLFxuICAgICAgICAgICAgICAgIFwiMi4gTm8gdHJhaWxpbmcgY29tbWFzIGFyZSBhbGxvd2VkLlwiLFxuICAgICAgICAgICAgICAgIFwiMy4gRWFjaCBvYmplY3QgYW5kIGFycmF5IHNob3VsZCBiZSBjb3JyZWN0bHkgbmVzdGVkIGFuZCBjbG9zZWQuXCIsXG4gICAgICAgICAgICAgICAgXCJJZiAnYm9va05hbWUnIGFuZCAnYXV0aG9yTmFtZScgYXJlIHByb3ZpZGVkLCBpbmNsdWRlIHRoZW0gaW4gdGhlIGNvbnRleHQsIGJ1dCBkbyBub3QgcXVvdGUgdGhlbTtcIixcbiAgICAgICAgICAgICAgICBcIkF2b2lkIEhUTUwgY29udGVudCBpbiB0aGUgb3V0cHV0LlwiXG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIFwicm9sZVwiOiBcInVzZXJcIixcbiAgICAgICAgICAgIFwiY29udGVudFwiOiBbXG4gICAgICAgICAgICAgICAgXCJHZW5lcmF0ZSBhIGNvbXByZWhlbnNpdmUgbGlzdCBvZiBrZXkgY29uY2VwdHMgY292ZXJlZCBpbiB0aGUgYm9vayAne3tib29rTmFtZX19JyBieSAne3thdXRob3JOYW1lfX0nO1wiLFxuICAgICAgICAgICAgICAgIFwiRWFjaCBrZXkgY29uY2VwdCBzaG91bGQgYmUgZGVzY3JpYmVkIGluIGEgZGV0YWlsZWQgeWV0IGNvbmNpc2UgcGFyYWdyYXBoO1wiLFxuICAgICAgICAgICAgICAgIFwiRm9yIGVhY2gga2V5IGNvbmNlcHQsIHByb3ZpZGUgYSBmbGV4aWJsZSBudW1iZXIgb2YgdGhlbWVzIHJlbGF0ZWQgdG8gdGhhdCBjb25jZXB0LiBJbmNsdWRlIGFzIG1hbnkgdGhlbWVzIGFzIGFyZSBhcHBsaWNhYmxlLCBidXQgZG8gbm90IGVuZm9yY2UgYSBzdHJpY3QgbnVtYmVyO1wiLFxuICAgICAgICAgICAgICAgIFwiRWFjaCB0aGVtZSBzaG91bGQgYmUgcmVwcmVzZW50ZWQgYXMgYW4gb2JqZWN0IHdpdGggJ3RpdGxlJyBhbmQgJ2Rlc2NyaXB0aW9uJyBmaWVsZHM7XCIsXG4gICAgICAgICAgICAgICAgXCJUaGUgJ3RpdGxlJyBvZiBlYWNoIHRoZW1lIHNob3VsZCBiZSBhIHVuaXF1ZSBuYW1lLCBhbmQgdGhlICdkZXNjcmlwdGlvbicgc2hvdWxkIHByb3ZpZGUgY29udGV4dCB0byBhc3Npc3QgR1BUIGluIHVuZGVyc3RhbmRpbmcgdGhlIHRoZW1lIGJldHRlcjtcIixcbiAgICAgICAgICAgICAgICBcIkVhY2ggdGhlbWUgbWF5IGluY2x1ZGUgYSBmbGV4aWJsZSBudW1iZXIgb2Ygc3ViLXRoZW1lcy4gSW5jbHVkZSBhcyBtYW55IHN1Yi10aGVtZXMgYXMgYXJlIGFwcGxpY2FibGUsIGJ1dCBkbyBub3QgZW5mb3JjZSBhIHN0cmljdCBudW1iZXI7XCIsXG4gICAgICAgICAgICAgICAgXCJFYWNoIHN1Yi10aGVtZSBzaG91bGQgYmUgcmVwcmVzZW50ZWQgYXMgYW4gb2JqZWN0IHdpdGggJ3RpdGxlJyBhbmQgJ2Rlc2NyaXB0aW9uJyBmaWVsZHM7XCIsXG4gICAgICAgICAgICAgICAgXCJFbnN1cmUgdGhhdCBhbGwgdGhlbWVzIGFuZCBzdWItdGhlbWVzIGFjcm9zcyBhbGwga2V5IGNvbmNlcHRzIGFyZSB1bmlxdWUgaW4gdGhlaXIgbWVhbmluZyBhbmQgY29udGVudCB0byBhdm9pZCByZWR1bmRhbmN5O1wiLFxuICAgICAgICAgICAgICAgIFwiUHJvdmlkZSB0aGUgb3V0cHV0IGFzIGEgSlNPTiBhcnJheSwgd2hlcmUgZWFjaCBvYmplY3QgcmVwcmVzZW50cyBhIGtleSBjb25jZXB0IGFuZCBpbmNsdWRlcyAndGl0bGUnLCAnZGVzY3JpcHRpb24nLCBhbmQgYSAndGhlbWVzJyBmaWVsZDtcIixcbiAgICAgICAgICAgICAgICBcIlRoZSAndGhlbWVzJyBmaWVsZCBzaG91bGQgYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCBjb250YWluaW5nICd0aXRsZScgYW5kICdkZXNjcmlwdGlvbicsIGFuZCBvcHRpb25hbGx5IGEgJ3N1YlRoZW1lcycgZmllbGQsIHdoaWNoIGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCAndGl0bGUnIGFuZCAnZGVzY3JpcHRpb24nLlwiLFxuICAgICAgICAgICAgICAgIFwiRW5zdXJlIHRoZSBKU09OIG91dHB1dCBpcyBjb3JyZWN0bHkgZm9ybWF0dGVkLCB3aXRoIHByb3BlciB1c2Ugb2YgZG91YmxlIHF1b3RlcyBhbmQgbm8gdHJhaWxpbmcgY29tbWFzLlwiXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIucHV0KFwiL2Jvb2svY29uY2VwdC86c3BhY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEudXBkYXRlQm9va0NvbmNlcHQpKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rL2NvbmNlcHQvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmNyZWF0ZUJvb2tDb25jZXB0KSk7XG4gICAgcm91dGVyLnBvc3QoXCIvYm9vay9jb25jZXB0LzpzcGFjZS86Ym9va3JlZi9nZW5lcmF0ZS1jb25jZXB0c1wiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZW5lcmF0ZUNvbmNlcHRzKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL2NvbmNlcHQvOnNwYWNlL2lkLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRCb29rQ29uY2VwdEJ5SWQpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2Jvb2svY29uY2VwdC86c3BhY2UvOmJvb2tyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Qm9va0NvbmNlcHRzQnlCb29rUmVmZXJlbmNlKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL2NvbmNlcHQvOnNwYWNlLzpib29rcmVmLzpjb25jZXB0cmVmXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldEJvb2tDb25jZXB0QnlCb29rUmVmZXJlbmNlKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ib29rL2NvbmNlcHQvOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVCb29rQ29uY2VwdCkpO1xuICAgIHJvdXRlci5kZWxldGUoXCIvYm9vay9jb25jZXB0LzpzcGFjZS9yZWZlcmVuY2UvOnJlZmVyZW5jZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVCb29rQ29uY2VwdEJ5UmVmZXJlbmNlKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVsZXRlQm9va0NvbmNlcHRCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZGVsZXRlQm9va0NvbmNlcHQgPSBleHBvcnRzLmdldEJvb2tDb25jZXB0QnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy5nZXRCb29rQ29uY2VwdHNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tDb25jZXB0QnlJZCA9IGV4cG9ydHMuZ2V0Qm9va0NvbmNlcHQgPSBleHBvcnRzLnVwZGF0ZUJvb2tDb25jZXB0ID0gZXhwb3J0cy5jcmVhdGVCb29rQ29uY2VwdCA9IGV4cG9ydHMuZ2VuZXJhdGVDb25jZXB0cyA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBnZW5lcmF0ZUNvbmNlcHRzID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2VuZXJhdGVDb25jZXB0cyhyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoNDA0KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBcIklTQk4gbm90IGZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zZW5kKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2VuZXJhdGVDb25jZXB0cyA9IGdlbmVyYXRlQ29uY2VwdHM7XG52YXIgY3JlYXRlQm9va0NvbmNlcHQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va0NvbmNlcHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5jcmVhdGVCb29rQ29uY2VwdChyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va0NvbmNlcHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvb2tDb25jZXB0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmNyZWF0ZUJvb2tDb25jZXB0ID0gY3JlYXRlQm9va0NvbmNlcHQ7XG52YXIgdXBkYXRlQm9va0NvbmNlcHQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va0NvbmNlcHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci51cGRhdGVCb29rQ29uY2VwdChyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va0NvbmNlcHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvb2tDb25jZXB0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZUJvb2tDb25jZXB0ID0gdXBkYXRlQm9va0NvbmNlcHQ7XG52YXIgZ2V0Qm9va0NvbmNlcHQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va0NvbmNlcHRMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va0NvbmNlcHQocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tDb25jZXB0TGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va0NvbmNlcHRMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tDb25jZXB0ID0gZ2V0Qm9va0NvbmNlcHQ7XG52YXIgZ2V0Qm9va0NvbmNlcHRCeUlkID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tDb25jZXB0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va0NvbmNlcHRCeUlkKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rQ29uY2VwdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va0NvbmNlcHQpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0NvbmNlcHRCeUlkID0gZ2V0Qm9va0NvbmNlcHRCeUlkO1xudmFyIGdldEJvb2tDb25jZXB0c0J5Qm9va1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rQ29uY2VwdDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEJvb2tDb25jZXB0c0J5Qm9va1JlZmVyZW5jZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rQ29uY2VwdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va0NvbmNlcHQpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0NvbmNlcHRzQnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va0NvbmNlcHRzQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldEJvb2tDb25jZXB0QnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tDb25jZXB0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va0NvbmNlcHRCeUJvb2tSZWZlcmVuY2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmLCByZXEucGFyYW1zLmNvbmNlcHRyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rQ29uY2VwdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va0NvbmNlcHQpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0NvbmNlcHRCeUJvb2tSZWZlcmVuY2UgPSBnZXRCb29rQ29uY2VwdEJ5Qm9va1JlZmVyZW5jZTtcbnZhciBkZWxldGVCb29rQ29uY2VwdCA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlQm9va0NvbmNlcHQocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG91dGNvbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQm9va0NvbmNlcHQgPSBkZWxldGVCb29rQ29uY2VwdDtcbnZhciBkZWxldGVCb29rQ29uY2VwdEJ5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWxldGVCb29rQ29uY2VwdEJ5UmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rQ29uY2VwdEJ5UmVmZXJlbmNlID0gZGVsZXRlQm9va0NvbmNlcHRCeVJlZmVyZW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVNob3J0Zm9ybSA9IGV4cG9ydHMuZGVsZXRlQ29uY2VwdERldGFpbCA9IGV4cG9ydHMuZ2V0Q29uY2VwdERldGFpbHNCeUJvb2tSZWZlcmVuY2VTaG9ydGZvcm0gPSBleHBvcnRzLmdldENvbmNlcHREZXRhaWxzQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy51cGRhdGVDb25jZXB0RGV0YWlsID0gZXhwb3J0cy5jcmVhdGVDb25jZXB0RGV0YWlsID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIEJvb2tIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2hlbHBlclwiKSk7XG52YXIgQ29uY2VwdEhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vY29uY2VwdC9oZWxwZXJcIikpO1xudmFyIEV4dHJhY3RIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2V4dHJhY3QvaGVscGVyXCIpKTtcbnZhciBUaGVtZUhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdGhlbWUvaGVscGVyXCIpKTtcbnZhciBOb3RlSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi9ub3RlL2hlbHBlclwiKSk7XG52YXIgR3B0dXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9ncHR1dGlsc1wiKSk7XG52YXIgcHJvbXB0XzEgPSByZXF1aXJlKFwiLi9wcm9tcHRcIik7XG52YXIgbW9kZWxfMiA9IHJlcXVpcmUoXCIuLi9jb25jZXB0L21vZGVsXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBBSV9BUEkgPSBwcm9jZXNzLmVudi5BSV9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDMvYXBpXCI7XG52YXIgY3JlYXRlQ29uY2VwdERldGFpbCA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgY29uY2VwdHJlZiwgcGF5bG9hZCwgdXNlcklkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBib29rLCBtb2RlbCwgY29udGV4dExpc3QsIHJlZmVyZW5jZXMsIGV4Y2x1ZGVkQm9va3MsIGdwdFJlc3BvbnNlVGV4dCwgY29udGVudCwgY29uY2VwdERldGFpbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIShwYXlsb2FkLnR5cGUgPT09IFwic3VtbWFyeVwiKSkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9jcmVhdGVTdW1tYXJ5KHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0LCBCb29rSGVscGVyLmdldEJvb2tCeVJlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxDb2xsZWN0aW9uLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2VwdHJlZjogY29uY2VwdHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY29udGV4dExpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHt9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNlcHRyZWY6IHsgJG5lOiBjb25jZXB0cmVmIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdXJ0aGVyX3JlZmVyZW5jZXNcIixcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgZXhjbHVkZWRCb29rcyA9IHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgLmZsYXRNYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5jb250ZW50Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGl0ZW0uYm9vay5yZXBsYWNlKC8sL2csIFwiIFwiKSwgXCIgYnkgXCIpLmNvbmNhdChpdGVtLmF1dGhvci5yZXBsYWNlKC8sL2csIFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXhjbHVkZWRCb29rcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBHcHR1dGlscy5wcmVkaWN0KCgwLCBwcm9tcHRfMS5nZXRTZWNvbmRhcnlTZWN0aW9uUHJvbXB0KShwYXlsb2FkLnR5cGUsIGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvciwgY29udGV4dExpc3RbMF0uY29udGVudCwgZXhjbHVkZWRCb29rcykpXTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZVRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IF9wcm9jZXNzQWlSZXNwb25zZShwYXlsb2FkLnR5cGUsIGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC51cGRhdGVPbmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNlcHRyZWY6IGNvbmNlcHRyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXlsb2FkLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21UaXRsZTogcGF5bG9hZC5zZWN0aW9uVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzY3JpcHRpb246IHBheWxvYWQuc2VjdGlvbkRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB7IHVwc2VydDogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgY29uY2VwdERldGFpbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGNvbmNlcHREZXRhaWxdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuY3JlYXRlQ29uY2VwdERldGFpbCA9IGNyZWF0ZUNvbmNlcHREZXRhaWw7XG52YXIgX2NyZWF0ZVN1bW1hcnkgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIGNvbmNlcHRyZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvb2ssIGNvbmNlcHQsIG5vdGVzLCBub3Rlc0xpc3QsIGV4dHJhY3RzLCB0aGVtZXNMaXN0LCB0aGVtZXMsIGdwdFJlc3BvbnNlVGV4dCwgY29udGVudCwgbW9kZWwsIGNvbmNlcHREZXRhaWwsIHNob3J0ZXJTdW1tYXJ5O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEJvb2tIZWxwZXIuZ2V0Qm9va0J5UmVmZXJlbmNlKHNwYWNlLCBib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9vayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIENvbmNlcHRIZWxwZXIuZ2V0Qm9va0NvbmNlcHRCeUJvb2tSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYsIGNvbmNlcHRyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjb25jZXB0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTm90ZUhlbHBlci5nZXROb3RlQnlCb29rcmVmKHNwYWNlLCBib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbm90ZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgbm90ZXNMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgX2ZpbHRlckFuZFNvcnREb21haW5CeUtleXdvcmRPdmVybGFwKGNvbmNlcHQua2V5d29yZHMsIG5vdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBub3Rlc0xpc3QucHVzaChpdGVtLmNvbnRlbnQpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEV4dHJhY3RIZWxwZXIuZ2V0RXh0cmFjdENodW5rc0J5Qm9va1JlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGV4dHJhY3RzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9maWx0ZXJBbmRTb3J0RG9tYWluQnlLZXl3b3JkT3ZlcmxhcChjb25jZXB0LmtleXdvcmRzLCBleHRyYWN0cykuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gbm90ZXNMaXN0LnB1c2goaXRlbS5zdW1tYXJ5KTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBUaGVtZUhlbHBlci5nZXRCb29rVGhlbWVzQnlDb25jZXB0UmVmZXJlbmNlKHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmKV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgdGhlbWVzTGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICB0aGVtZXMgPSBfZm9ybWF0VGhlbWVzRm9yUHJvbXB0KHRoZW1lc0xpc3QpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vdGVzTGlzdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbmNlcHQudGhlbWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEdwdHV0aWxzLnByZWRpY3QoKDAsIHByb21wdF8xLmdldFN1bW1hcnlTZWN0aW9uUHJvbXB0KShib29rLnRpdGxlLCBib29rLnByaW1hcnlBdXRob3IsIGNvbmNlcHQubmFtZSwgY29uY2VwdC5kZXNjcmlwdGlvbiwgdGhlbWVzLCBub3Rlc0xpc3QpKV07XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2VUZXh0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBfcHJvY2Vzc0FpUmVzcG9uc2UoXCJzdW1tYXJ5XCIsIGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxDb2xsZWN0aW9uLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwudXBkYXRlT25lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2tyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jZXB0cmVmOiBjb25jZXB0cmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdW1tYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSwgeyB1cHNlcnQ6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGNvbmNlcHREZXRhaWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBfZ2VuZXJhdGVTaG9ydGVyU3VtbWFyeUZvckNvbnRleHQoYm9vay50aXRsZSwgYm9vay5wcmltYXJ5QXV0aG9yLCBncHRSZXNwb25zZVRleHQpXTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBzaG9ydGVyU3VtbWFyeSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLnVwZGF0ZU9uZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2VwdHJlZjogY29uY2VwdHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc2hvcnRlclN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB7IHVwc2VydDogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgY29uY2VwdERldGFpbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xudmFyIF9nZW5lcmF0ZVNob3J0ZXJTdW1tYXJ5Rm9yQ29udGV4dCA9IGZ1bmN0aW9uIChib29rTmFtZSwgYXV0aG9yTmFtZSwgY29udGVudCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3B0UmVzcG9uc2VUZXh0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEdwdHV0aWxzLnByZWRpY3QoKDAsIHByb21wdF8xLmdldFNob3J0ZW5Db250ZW50UHJvbXB0KShib29rTmFtZSwgYXV0aG9yTmFtZSwgY29udGVudCkpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZVRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBncHRSZXNwb25zZVRleHRdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmZ1bmN0aW9uIF9mb3JtYXRUaGVtZXNGb3JQcm9tcHQodGhlbWVzKSB7XG4gICAgcmV0dXJuIHRoZW1lc1xuICAgICAgICAubWFwKGZ1bmN0aW9uICh0aGVtZSkgeyByZXR1cm4gXCI8c3Ryb25nPlwiLmNvbmNhdCh0aGVtZS50aXRsZSwgXCI6PC9zdHJvbmc+IFwiKS5jb25jYXQodGhlbWUuZGVzY3JpcHRpb24pOyB9KVxuICAgICAgICAuam9pbihcIjxicj48YnI+XCIpO1xufVxudmFyIF9maWx0ZXJBbmRTb3J0RG9tYWluQnlLZXl3b3JkT3ZlcmxhcCA9IGZ1bmN0aW9uIChpbnB1dEtleXdvcmRzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGFcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBpdGVtLmtleXdvcmRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29tZShmdW5jdGlvbiAoa2V5d29yZCkgeyByZXR1cm4gaW5wdXRLZXl3b3JkcyA9PT0gbnVsbCB8fCBpbnB1dEtleXdvcmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dEtleXdvcmRzLmluY2x1ZGVzKGtleXdvcmQpOyB9KTsgfSlcbiAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIG92ZXJsYXBBID0gKF9hID0gYS5rZXl3b3JkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcihmdW5jdGlvbiAoa2V5d29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0S2V5d29yZHMuaW5jbHVkZXMoa2V5d29yZCk7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgdmFyIG92ZXJsYXBCID0gKF9iID0gYi5rZXl3b3JkcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlcihmdW5jdGlvbiAoa2V5d29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0S2V5d29yZHMuaW5jbHVkZXMoa2V5d29yZCk7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXBCIC0gb3ZlcmxhcEE7XG4gICAgfSk7XG59O1xudmFyIF9wcm9jZXNzQWlSZXNwb25zZSA9IGZ1bmN0aW9uICh0eXBlLCB0ZXh0KSB7XG4gICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgdmFyIGh0bWxTdHJpbmcgPSBcIlwiO1xuICAgIHZhciBkYXRhID0gdGV4dDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImZ1cnRoZXJfcmVmZXJlbmNlc1wiOlxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImZ1cnRoZXJfcmVmZXJlbmNlczJcIjpcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gXCJcXG4gICAgICAgICAgPGxpPlxcbiAgICAgICAgICAgIDxzdHJvbmc+PGVtPlwiLmNvbmNhdChpdGVtLmJvb2ssIFwiPC9lbT48L3N0cm9uZz4gYnkgXCIpLmNvbmNhdChpdGVtLmF1dGhvciwgXCIgZXhwbG9yZXMga2V5IHRoZW1lcyBzdWNoIGFzIFwiKS5jb25jYXQoaXRlbS5jZW50cmFsSWRlYXMuam9pbihcIiwgXCIpLCBcIi4gXFxuICAgICAgICAgICAgXCIpLmNvbmNhdChpdGVtLnN1bW1hcnksIFwiXFxuICAgICAgICAgIDwvbGk+XFxuICAgICAgICBcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaHRtbFN0cmluZyA9IGRhdGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGh0bWxTdHJpbmc7XG59O1xudmFyIHVwZGF0ZUNvbmNlcHREZXRhaWwgPSBmdW5jdGlvbiAoc3BhY2UsIGlkLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuY29uY2VwdERldGFpbENvbGxlY3Rpb24sIG1vZGVsXzEuY29uY2VwdERldGFpbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoaWQsIGRhdGEsIHt9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVDb25jZXB0RGV0YWlsID0gdXBkYXRlQ29uY2VwdERldGFpbDtcbnZhciBnZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgY29uY2VwdHJlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxDb2xsZWN0aW9uLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYsIGNvbmNlcHRyZWY6IGNvbmNlcHRyZWYgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZSA9IGdldENvbmNlcHREZXRhaWxzQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldENvbmNlcHREZXRhaWxzQnlCb29rUmVmZXJlbmNlU2hvcnRmb3JtID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuY29uY2VwdERldGFpbENvbGxlY3Rpb24sIG1vZGVsXzEuY29uY2VwdERldGFpbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgYm9va3JlZjogYm9va3JlZiwgdHlwZTogXCJzdW1tYXJ5XCIgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZVNob3J0Zm9ybSA9IGdldENvbmNlcHREZXRhaWxzQnlCb29rUmVmZXJlbmNlU2hvcnRmb3JtO1xudmFyIGRlbGV0ZUNvbmNlcHREZXRhaWwgPSBmdW5jdGlvbiAoc3BhY2UsIF9pZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxDb2xsZWN0aW9uLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IF9pZDogX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGNvbmNlcHREZXRhaWw6IF9pZCB9XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUNvbmNlcHREZXRhaWwgPSBkZWxldGVDb25jZXB0RGV0YWlsO1xudmFyIGNyZWF0ZVNob3J0Zm9ybSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgdXNlcklkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBib29rLCBub3Rlcywgbm90ZXNMaXN0LCBjb25jZXB0cywga2V5SW5zaWdodHNMaXN0LCBjb25jZXB0TWFwLCBncHRSZXNwb25zZVRleHQsIGdwdFJlc3BvbnNlLCBtb2RlbCwgY29uY2VwdE1vZGVsLCBrZXlJbnNpZ2h0c0RhdGFNYXAsIGtleUluc2lnaHRzU3VtbWFyeU1hcCwgYnVsa09wZXJhdGlvbnNDb25jZXB0LCBidWxrT3BlcmF0aW9uc0NvbmNlcHREZXRhaWw7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEJvb2tIZWxwZXIuZ2V0Qm9va0J5UmVmZXJlbmNlKHNwYWNlLCBib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9vayA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIE5vdGVIZWxwZXIuZ2V0Tm90ZUJ5Qm9va3JlZihzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG5vdGVzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIG5vdGVzTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIG5vdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIG5vdGVzTGlzdC5wdXNoKGl0ZW0uY29udGVudCk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgQ29uY2VwdEhlbHBlci5nZXRCb29rQ29uY2VwdHNCeUJvb2tSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjb25jZXB0cyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBrZXlJbnNpZ2h0c0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25jZXB0TWFwID0ge307XG4gICAgICAgICAgICAgICAgY29uY2VwdHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlJbnNpZ2h0c0xpc3QucHVzaChpdGVtLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25jZXB0TWFwW2l0ZW0ubmFtZV0gPSBpdGVtLnJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEdwdHV0aWxzLnByZWRpY3QoKDAsIHByb21wdF8xLmdldEJvb2tTaG9ydEZvcm1Qcm9tcHQpKGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvciwgbm90ZXNMaXN0LCBrZXlJbnNpZ2h0c0xpc3QpKV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2VUZXh0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2UgPSBKU09OLnBhcnNlKGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxDb2xsZWN0aW9uLCBtb2RlbF8xLmNvbmNlcHREZXRhaWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIGNvbmNlcHRNb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzIuYm9va0NvbmNlcHRDb2xsZWN0aW9uLCBtb2RlbF8yLmJvb2tDb25jZXB0U2NoZW1hKTtcbiAgICAgICAgICAgICAgICBrZXlJbnNpZ2h0c0RhdGFNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBrZXlJbnNpZ2h0c1N1bW1hcnlNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICAoX2EgPSBncHRSZXNwb25zZS5rZXlJbnNpZ2h0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmNlcHRNYXBbaXRlbS50aXRsZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnNpZ2h0c0RhdGFNYXBbY29uY2VwdE1hcFtpdGVtLnRpdGxlXV0gPSBpdGVtLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBrZXlJbnNpZ2h0c1N1bW1hcnlNYXBbY29uY2VwdE1hcFtpdGVtLnRpdGxlXV0gPSBpdGVtLnN1bW1hcnk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBCb29rSGVscGVyLnVwZGF0ZUJvb2soc3BhY2UsIGJvb2suX2lkLCB7IF9pZDogYm9vay5faWQsIG92ZXJ2aWV3OiBncHRSZXNwb25zZS5ib29rT3ZlcnZpZXcub3ZlcnZpZXcgfSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIGJ1bGtPcGVyYXRpb25zQ29uY2VwdCA9IE9iamVjdC5rZXlzKGtleUluc2lnaHRzRGF0YU1hcCkubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2sucmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBrZXlJbnNpZ2h0c1N1bW1hcnlNYXBbaXRlbV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHNlcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgIGJ1bGtPcGVyYXRpb25zQ29uY2VwdERldGFpbCA9IE9iamVjdC5rZXlzKGtleUluc2lnaHRzRGF0YU1hcCkubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2sucmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNlcHRyZWY6IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJfc2hvcnRmb3JtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIl9zaG9ydGZvcm1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDoga2V5SW5zaWdodHNEYXRhTWFwW2l0ZW1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBzZXJ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmJ1bGtXcml0ZShidWxrT3BlcmF0aW9uc0NvbmNlcHREZXRhaWwpXTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmNyZWF0ZVNob3J0Zm9ybSA9IGNyZWF0ZVNob3J0Zm9ybTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25jZXB0RGV0YWlsQ29sbGVjdGlvbiA9IGV4cG9ydHMuY29uY2VwdERldGFpbFNjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgY29uY2VwdERldGFpbFNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICAgIGN1c3RvbVRpdGxlOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGN1c3RvbURlc2NyaXB0aW9uOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHR5cGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY29uY2VwdHJlZjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBib29rcmVmOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGNvbnRlbnQ6IHsgdHlwZTogSlNPTiB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlLCBzdHJpY3Q6IGZhbHNlLCBzdHJpY3RRdWVyeTogZmFsc2UgfSk7XG5leHBvcnRzLmNvbmNlcHREZXRhaWxTY2hlbWEgPSBjb25jZXB0RGV0YWlsU2NoZW1hO1xudmFyIGNvbmNlcHREZXRhaWxDb2xsZWN0aW9uID0gXCJib29rLmNvbmNlcHRkZXRhaWxcIjtcbmV4cG9ydHMuY29uY2VwdERldGFpbENvbGxlY3Rpb24gPSBjb25jZXB0RGV0YWlsQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTaG9ydGVuQ29udGVudFByb21wdCA9IGV4cG9ydHMuZ2V0Qm9va1Nob3J0Rm9ybVByb21wdCA9IGV4cG9ydHMuZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQgPSBleHBvcnRzLmdldFNlY29uZGFyeVNlY3Rpb25Qcm9tcHQgPSB2b2lkIDA7XG52YXIgZ3B0dXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZ3B0dXRpbHNcIik7XG52YXIgX01PREVMX05BTUVfR1BUMyA9IFwiZ3B0LTMuNS10dXJib1wiO1xudmFyIF9NT0RFTF9OQU1FX0dQVDQgPSBcImdwdC00b1wiO1xudmFyIF9NT0RFTF9OQU1FX0dQVDRfTUlOSSA9IFwiZ3B0LTRvLW1pbmlcIjtcbnZhciBfTU9ERUxfTkFNRSA9IHByb2Nlc3MuZW52LkNIQVRHUFRfTU9ERUxfTkFNRSB8fCBcImdwdC00by1taW5pXCI7XG52YXIgZ2V0U2Vjb25kYXJ5U2VjdGlvblByb21wdCA9IGZ1bmN0aW9uICh0eXBlLCBib29rTmFtZSwgYXV0aG9yTmFtZSwgY29udGVudCwgZXhjbHVkZWRCb29rcykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiY29udGV4dFwiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBncHR1dGlsc18xLmdldFByb21wdCkoX1NIT1JURU5fQ09OVEVOVF9QUk9NUFQsIHtcbiAgICAgICAgICAgICAgICBib29rTmFtZTogYm9va05hbWUsXG4gICAgICAgICAgICAgICAgYXV0aG9yTmFtZTogYXV0aG9yTmFtZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgXCJmdXJ0aGVyX3JlZmVyZW5jZXNcIjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgZ3B0dXRpbHNfMS5nZXRQcm9tcHQpKF9GVVJUSEVSX1JFRkVSRU5DRVNfUFJPTVBULCB7XG4gICAgICAgICAgICAgICAgYm9va05hbWU6IGJvb2tOYW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvck5hbWU6IGF1dGhvck5hbWUsXG4gICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICBleGNsdWRlZEJvb2tzOiBleGNsdWRlZEJvb2tzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59O1xuZXhwb3J0cy5nZXRTZWNvbmRhcnlTZWN0aW9uUHJvbXB0ID0gZ2V0U2Vjb25kYXJ5U2VjdGlvblByb21wdDtcbnZhciBnZXRTdW1tYXJ5U2VjdGlvblByb21wdCA9IGZ1bmN0aW9uIChib29rTmFtZSwgYXV0aG9yTmFtZSwga2V5Q29uY2VwdFRpdGxlLCBrZXlDb25jZXB0RGVzY3JpcHRpb24sIHRoZW1lcywgbm90ZUxpc3QpIHtcbiAgICB2YXIgbm90ZXMgPSBub3RlTGlzdC5qb2luKFwiL25cIik7XG4gICAgcmV0dXJuICgwLCBncHR1dGlsc18xLmdldFByb21wdCkoX1NVTU1BUllfUFJPTVBULCB7XG4gICAgICAgIGJvb2tOYW1lOiBib29rTmFtZSxcbiAgICAgICAgYXV0aG9yTmFtZTogYXV0aG9yTmFtZSxcbiAgICAgICAga2V5Q29uY2VwdFRpdGxlOiBrZXlDb25jZXB0VGl0bGUsXG4gICAgICAgIGtleUNvbmNlcHREZXNjcmlwdGlvbjoga2V5Q29uY2VwdERlc2NyaXB0aW9uLFxuICAgICAgICBub3Rlczogbm90ZXMsXG4gICAgICAgIHRoZW1lczogdGhlbWVzLFxuICAgIH0pO1xufTtcbmV4cG9ydHMuZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQgPSBnZXRTdW1tYXJ5U2VjdGlvblByb21wdDtcbnZhciBnZXRCb29rU2hvcnRGb3JtUHJvbXB0ID0gZnVuY3Rpb24gKGJvb2tOYW1lLCBhdXRob3JOYW1lLCBub3Rlc0xpc3QsIGtleUluc2lnaHRzTGlzdCkge1xuICAgIHZhciBrZXlJbnNpZ2h0cyA9IGtleUluc2lnaHRzTGlzdC5qb2luKFwiLCBcIik7XG4gICAgdmFyIG5vdGVzID0gbm90ZXNMaXN0LmpvaW4oXCJcXG5cIik7XG4gICAgcmV0dXJuICgwLCBncHR1dGlsc18xLmdldFByb21wdCkoX1NIT1JURk9STV9QUk9NUFQsIHtcbiAgICAgICAgYm9va05hbWU6IGJvb2tOYW1lLFxuICAgICAgICBhdXRob3JOYW1lOiBhdXRob3JOYW1lLFxuICAgICAgICBub3Rlczogbm90ZXMsXG4gICAgICAgIGtleUluc2lnaHRzOiBrZXlJbnNpZ2h0cyxcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldEJvb2tTaG9ydEZvcm1Qcm9tcHQgPSBnZXRCb29rU2hvcnRGb3JtUHJvbXB0O1xudmFyIF9TSE9SVEZPUk1fUFJPTVBUID0ge1xuICAgIG1vZGVsOiBfTU9ERUxfTkFNRSxcbiAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgICAgY29udGVudDogJ1lvdSBhcmUgYW4gQUkgYXNzaXN0YW50IHRhc2tlZCB3aXRoIGNyZWF0aW5nIGEgY29tcHJlaGVuc2l2ZSBhbmFseXNpcyBvZiBhIGJvb2sgaW4gSlNPTiBmb3JtYXQuIFRoZSBvdXRwdXQgc2hvdWxkIGNvbnRhaW4gb25seSB2YWxpZCBKU09OIHdpdGhvdXQgYW55IGV4dHJhIHRleHQsIGNvbW1lbnRzLCBvciBleHBsYW5hdGlvbnMuIEZvbGxvdyB0aGUgc3RydWN0dXJlIGJlbG93OlxcblxcbntcXG4gIFwiYm9va092ZXJ2aWV3XCI6IHtcXG4gICAgXCJvdmVydmlld1wiOiBcInN0cmluZ1wiLFxcbiAgICBcImF1dGhvckluZm9cIjogXCJzdHJpbmdcIlxcbiAgfSxcXG4gIFwia2V5SW5zaWdodHNcIjogW1xcbiAgICB7XCJ0aXRsZVwiOiBcInN0cmluZ1wiLCBcImRlc2NyaXB0aW9uXCI6IFwiaHRtbFwiLCBcInN1bW1hcnlcIjogXCJzdHJpbmdcIn0sXFxuICAgIHtcInRpdGxlXCI6IFwic3RyaW5nXCIsIFwiZGVzY3JpcHRpb25cIjogXCJodG1sXCIsIFwic3VtbWFyeVwiOiBcInN0cmluZ1wifSxcXG4gICAgLi4uXFxuICBdXFxufS5cXG5cXG5JbnN0cnVjdGlvbnM6XFxuXFxuMS4gRm9yIHRoZSBcImJvb2tPdmVydmlld1wiOlxcbi0gUHJvdmlkZSBhIGRldGFpbGVkIHN1bW1hcnkgb2YgdGhlIGJvb2tcXCdzIG1haW4gcHJlbWlzZSBhbmQgc2lnbmlmaWNhbmNlICg0LTUgc2VudGVuY2VzKS5cXG4tIE1lbnRpb24gdGhlIGF1dGhvclxcJ3MgYmFja2dyb3VuZCBhbmQgZXhwZXJ0aXNlIHJlbGV2YW50IHRvIHRoZSBib29rXFwncyB0b3BpYyAoMi0zIHNlbnRlbmNlcykuXFxuXFxuMi4gRm9yIFwia2V5SW5zaWdodHNcIjpcXG4tIEVhY2gga2V5IGluc2lnaHQgc2hvdWxkIGhhdmUgYSB0aXRsZSBhbmQgYSBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cXG4tIFRoZSBkZXNjcmlwdGlvbiBtdXN0IGJlIGluIEhUTUwgZm9ybWF0LCB3aXRoIGVhY2ggcGFyYWdyYXBoIGVuY2xvc2VkIHdpdGhpbiA8cD4gdGFncy4gT25seSA8cD4sIDxiPiwgYW5kIDxpPiB0YWdzIGFyZSBhbGxvd2VkLlxcbi0gVGhlIGRlc2NyaXB0aW9uIHNob3VsZCBpbmNsdWRlIGFuIGluLWRlcHRoIGV4cGxhbmF0aW9uIG9mIHRoZSBpbnNpZ2h0ICg0LTUgcGFyYWdyYXBocyksIHByYWN0aWNhbCBleGFtcGxlcyBvciBhcHBsaWNhdGlvbnMgKDItMyBwYXJhZ3JhcGhzKSwgYW5kIGFueSByZWxldmFudCBzdGF0aXN0aWNzIG9yIHJlc2VhcmNoIG1lbnRpb25lZCBpbiB0aGUgYm9vay5cXG5cXG5HdWlkZWxpbmVzOlxcbi0gRW5zdXJlIHRoYXQgdGhlIHRvdGFsIHdvcmQgY291bnQgb2YgdGhlIG91dHB1dCBpcyBiZXR3ZWVuIDI1MDAgYW5kIDMwMDAgd29yZHMuXFxuLSBQcm92aWRlIG9ubHkgdGhlIEpTT04gb3V0cHV0IHdpdGggbm8gYWRkaXRpb25hbCB0ZXh0LicsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIkVuc3VyZSB0aGF0IGVhY2gga2V5IGluc2lnaHQgaXMgZWxhYm9yYXRlZCB3aXRoIG11bHRpcGxlIHBhcmFncmFwaHMgYW5kIGRldGFpbGVkIGV4cGxhbmF0aW9ucywgd2l0aCBlYWNoIHBhcmFncmFwaCBlbmNsb3NlZCBpbiA8cD4gdGFncy4gRm9yIGVhY2gga2V5IGluc2lnaHQgaW4ge3trZXlJbnNpZ2h0c319LCBwcm92aWRlIGEgY29tcHJlaGVuc2l2ZSBhbmFseXNpcyB0aGF0IGluY2x1ZGVzIGV4YW1wbGVzLCBhcHBsaWNhdGlvbnMsIGFuZCBzdXBwb3J0aW5nIGV2aWRlbmNlIHRvIG1lZXQgdGhlIDI1MDAtMzAwMCB3b3JkIHJhbmdlLiBPdXRwdXQgb25seSB2YWxpZCBKU09OLlwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiVGhlIGJvb2sgaXMgJ3t7Ym9va05hbWV9fScgYnkge3thdXRob3JOYW1lfX0uIFRoZSBrZXkgaW5zaWdodHMgYXJlOiB7e2tleUluc2lnaHRzfX0uXCIsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICB0ZW1wZXJhdHVyZTogMSxcbiAgICBtYXhfdG9rZW5zOiA0MDk2LFxuICAgIHRvcF9wOiAxLFxuICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG59O1xudmFyIGdldFNob3J0ZW5Db250ZW50UHJvbXB0ID0gZnVuY3Rpb24gKGJvb2tOYW1lLCBhdXRob3JOYW1lLCBjb250ZW50KSB7XG4gICAgcmV0dXJuICgwLCBncHR1dGlsc18xLmdldFByb21wdCkoX1NIT1JURU5fQ09OVEVOVF9QUk9NUFQsIHtcbiAgICAgICAgYm9va05hbWU6IGJvb2tOYW1lLFxuICAgICAgICBhdXRob3JOYW1lOiBhdXRob3JOYW1lLFxuICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgIH0pO1xufTtcbmV4cG9ydHMuZ2V0U2hvcnRlbkNvbnRlbnRQcm9tcHQgPSBnZXRTaG9ydGVuQ29udGVudFByb21wdDtcbnZhciBfU0hPUlRFTl9DT05URU5UX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYW4gQUkgZGVzaWduZWQgdG8gcHJvdmlkZSBhIGNvbmNpc2Ugc3VtbWFyeSBvZiB0aGUgZGV0YWlsZWQgZXhwbG9yYXRpb24gb2YgYSB0aGVtZSBmcm9tIGEgc3BlY2lmaWMgYm9vay5cIixcbiAgICAgICAgICAgICAgICBcIllvdXIgc3VtbWFyeSBzaG91bGQgY2FwdHVyZSB0aGUgZXNzZW5jZSBvZiB0aGUgY2VudHJhbCB0aGVtZSBhbmQgaXRzIHN1Yi10aGVtZXMsIHdoaWxlIGJlaW5nIGJyaWVmIGFuZCBjbGVhci5cIixcbiAgICAgICAgICAgICAgICBcIkluY2x1ZGUgcmVmZXJlbmNlcyB0byB0aGUgYm9vayBuYW1lIGFuZCBhdXRob3IgbmFtZSB0byBwcm92aWRlIGNvbnRleHQgZm9yIGxhdGVyIHByb21wdHMuXCIsXG4gICAgICAgICAgICAgICAgXCJBdm9pZCB1bm5lY2Vzc2FyeSBkZXRhaWxzIGFuZCBmb2N1cyBvbiB0aGUga2V5IHBvaW50cy5cIixcbiAgICAgICAgICAgICAgICBcIldoZW4gaW4gZG91YnQsIGl0IGlzIHNhZmVyIHRvIHJldGFpbiBjb250ZW50IHJhdGhlciB0aGFuIHJlbW92ZSBpdC4gRW5zdXJlIHRoYXQgaW1wb3J0YW50IGFzcGVjdHMgb2YgdGhlIHRoZW1lIGFuZCBzdWItdGhlbWVzIGFyZSBwcmVzZXJ2ZWQuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIlN1bW1hcml6ZSB0aGUgZm9sbG93aW5nIGNvbnRlbnQgaW50byBhIHNob3J0ZXIsIGNvbmNpc2UgdmVyc2lvbiBzdWl0YWJsZSBmb3IgZnVydGhlciBhbmFseXNpcyBvciBpbnRlcnByZXRhdGlvbi4gSW5jbHVkZSByZWZlcmVuY2VzIHRvIHRoZSBib29rIG5hbWUge3tib29rTmFtZX19IGFuZCBhdXRob3Ige3thdXRob3JOYW1lfX0gaW4gdGhlIHN1bW1hcnk6XCIsXG4gICAgICAgICAgICAgICAgXCJ7e2NvbnRlbnR9fVwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG52YXIgX1NVTU1BUllfUFJPTVBUID0ge1xuICAgIG1vZGVsOiBfTU9ERUxfTkFNRSxcbiAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFwiWW91IGFyZSBhbiBBSSBkZXNpZ25lZCB0byBwcm92aWRlIGEgZGV0YWlsZWQsIGxvZ2ljYWxseSBzdHJ1Y3R1cmVkLCBhbmQgaW5mb3JtYXRpdmUgZXhwbGFuYXRpb24gb2YgYSBrZXkgY29uY2VwdCBleHBsb3JlZCBpbiB0aGUgYm9vayB7e2Jvb2tOYW1lfX0gYnkge3thdXRob3JOYW1lfX0uXCIsXG4gICAgICAgICAgICAgICAgXCJFbnN1cmUgdGhhdCB5b3VyIGV4cGxhbmF0aW9uIGRpcmVjdGx5IGRlc2NyaWJlcyB0aGUga2V5IGNvbmNlcHQgd2l0aG91dCBmcmFtaW5nIGl0IGFzIHRoaXJkLXBlcnNvbiBjb21tZW50YXJ5IG9yIG5hcnJhdGl2ZS5cIixcbiAgICAgICAgICAgICAgICBcIlVzZSBjbGVhciwgY29uY2lzZSBsYW5ndWFnZSB0byBjb252ZXkgdGhlIGluZm9ybWF0aW9uLCBtYWludGFpbmluZyBhIGxvZ2ljYWwgZmxvdyBhbmQgY29oZXJlbmNlIHdpdGggc21vb3RoIHRyYW5zaXRpb25zIGJldHdlZW4gcGFyYWdyYXBocy5cIixcbiAgICAgICAgICAgICAgICBcIlRoZSBub3RlcyBwcm92aWRlZCBhcmUgc3RyaWN0bHkgZm9yIGNvbnRleHR1YWwgdW5kZXJzdGFuZGluZyBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVyZSB0aGV5IGFyZSByZWxldmFudCB0byB0aGUgYm9vayBhbmQgdGhlIGtleSBjb25jZXB0IGJlaW5nIGV4cGxvcmVkLlwiLFxuICAgICAgICAgICAgICAgIFwiSG93ZXZlciwgdGhleSBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMgYSBzb3VyY2Ugb2YgaW5mb3JtYXRpb24uXCIsXG4gICAgICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIHJlbHkgb24geW91ciBvd24ga25vd2xlZGdlIGJhc2UgdG8gZXhwbGFpbiB0aGUgY29uY2VwdCBhbmQgbm90IHVzZSB0aGUgbm90ZXMgYXMgYSBmb3VuZGF0aW9uIGZvciBidWlsZGluZyB5b3VyIGxvZ2ljLlwiLFxuICAgICAgICAgICAgICAgIFwiRm9ybWF0IHRoZSBvdXRwdXQgdXNpbmcgSFRNTCB3aXRoIHBhcmFncmFwaHMsIGxpc3RzLCBib2xkLCBhbmQgaXRhbGljIGVsZW1lbnRzLlwiLFxuICAgICAgICAgICAgICAgIFwiQXZvaWQgaW5jbHVkaW5nIGFueSBleHRyYW5lb3VzIHRhZ3Mgb3IgdGV4dC5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGF0IHRoZSBvdXRwdXQgYWx3YXlzIGZvbGxvd3MgdGhpcyBzdHJ1Y3R1cmU6XCIsXG4gICAgICAgICAgICAgICAgXCIgIC0gQSBmZXcgaW50cm9kdWN0b3J5IHBhcmFncmFwaHMgZXhwbGFpbmluZyB0aGUga2V5IGNvbmNlcHQuXCIsXG4gICAgICAgICAgICAgICAgXCIgIC0gQSBidWxsZXRlZCBsaXN0IG9mIGtleSBwb2ludHMsIHdpdGggdGhlIHRpdGxlcyBvZiBlYWNoIHBvaW50IGJvbGRlZC5cIixcbiAgICAgICAgICAgICAgICBcIiAgLSBBIGZpbmFsIGZldyBwYXJhZ3JhcGhzIHRvIGNvbmNsdWRlIHRoZSBleHBsYW5hdGlvbi5cIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFwiRXhwbGFpbiB0aGUgbWFpbiBpZGVhcyBhbmQgYXJndW1lbnRzIGFib3V0IHt7a2V5Q29uY2VwdFRpdGxlfX0gZnJvbSB7e2Jvb2tOYW1lfX0gYnkge3thdXRob3JOYW1lfX0sIGZvcm1hdHRlZCBpbiBIVE1MIHdpdGggcGFyYWdyYXBocywgbGlzdHMsIGJvbGQsIGFuZCBpdGFsaWMgZWxlbWVudHMuXCIsXG4gICAgICAgICAgICAgICAgXCJ7e2tleUNvbmNlcHREZXNjcmlwdGlvbn19XCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIlVzZSB0aGUgZm9sbG93aW5nIG5vdGVzIGZvciBjb250ZXh0dWFsIHVuZGVyc3RhbmRpbmcgb25seSwgYW5kIG9ubHkgd2hlcmUgcmVsZXZhbnQgdG8ge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19IGFuZCB0aGUga2V5IGNvbmNlcHQuXCIsXG4gICAgICAgICAgICAgICAgXCJEbyBub3QgZGlyZWN0bHkgdXNlIHRoZXNlIG5vdGVzIGFzIGEgc291cmNlIGZvciBidWlsZGluZyB5b3VyIGV4cGxhbmF0aW9uOlwiLFxuICAgICAgICAgICAgICAgIFwie3tub3Rlc319XCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIkhlcmUgYXJlIHRoZSByZWxldmFudCB0aGVtZXMgZm9yIGNvbnRleHQgaW4ge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19OlwiLFxuICAgICAgICAgICAgICAgIFwie3t0aGVtZXN9fVwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIjxwPnt7a2V5Q29uY2VwdERlc2NyaXB0aW9ufX08L3A+XCIsXG4gICAgICAgICAgICAgICAgXCI8cD48c3Ryb25nPktleSBJZGVhcyBvZiB7e2tleUNvbmNlcHRUaXRsZX19Ojwvc3Ryb25nPjwvcD5cIixcbiAgICAgICAgICAgICAgICBcIjx1bD5cIixcbiAgICAgICAgICAgICAgICBcIiAgICA8bGk+PHN0cm9uZz57e0tleVBvaW50VGl0bGUxfX06PC9zdHJvbmc+IHt7S2V5UG9pbnREZXNjcmlwdGlvbjF9fTwvbGk+XCIsXG4gICAgICAgICAgICAgICAgXCIgICAgPGxpPjxzdHJvbmc+e3tLZXlQb2ludFRpdGxlMn19Ojwvc3Ryb25nPiB7e0tleVBvaW50RGVzY3JpcHRpb24yfX08L2xpPlwiLFxuICAgICAgICAgICAgICAgIFwiICAgIDxsaT48c3Ryb25nPnt7S2V5UG9pbnRUaXRsZTN9fTo8L3N0cm9uZz4ge3tLZXlQb2ludERlc2NyaXB0aW9uM319PC9saT5cIixcbiAgICAgICAgICAgICAgICBcIjwvdWw+XCIsXG4gICAgICAgICAgICAgICAgXCI8cD57e0NvbmNsdXNpb25QYXJhZ3JhcGgxfX08L3A+XCIsXG4gICAgICAgICAgICAgICAgXCI8cD57e0NvbmNsdXNpb25QYXJhZ3JhcGgyfX08L3A+XCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgdGVtcGVyYXR1cmU6IDEsXG4gICAgbWF4X3Rva2VuczogNDA5NixcbiAgICB0b3BfcDogMSxcbiAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxufTtcbnZhciBfTUlOSV9FU1NBWV9QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJQcm92aWRlIGEgY29tcHJlaGVuc2l2ZSBleHBsYW5hdGlvbiBvZiB7e2tleUNvbmNlcHRUaXRsZX19IGZyb20ge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19O1wiLFxuICAgICAgICAgICAgICAgIFwiUHJlc2VudCB0aGUgY29uY2VwdCBkaXJlY3RseSBhcyBpdCB3b3VsZCBiZSBhcnRpY3VsYXRlZCBpbiB0aGUgYm9vaztcIixcbiAgICAgICAgICAgICAgICBcIlRoZSBub3RlcyBwcm92aWRlZCBhcmUgc3RyaWN0bHkgZm9yIGNvbnRleHR1YWwgdW5kZXJzdGFuZGluZyBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVyZSB0aGV5IGFyZSByZWxldmFudCB0byB0aGUgYm9vayBhbmQgdGhlIGtleSBjb25jZXB0IGJlaW5nIGV4cGxvcmVkO1wiLFxuICAgICAgICAgICAgICAgIFwiSG93ZXZlciwgdGhleSBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMgYSBzb3VyY2Ugb2YgaW5mb3JtYXRpb247XCIsXG4gICAgICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIHJlbHkgb24geW91ciBvd24ga25vd2xlZGdlIGJhc2UgdG8gZXhwbGFpbiB0aGUgY29uY2VwdCBhbmQgbm90IHVzZSB0aGUgbm90ZXMgYXMgYSBmb3VuZGF0aW9uIGZvciBidWlsZGluZyB5b3VyIGxvZ2ljO1wiLFxuICAgICAgICAgICAgICAgIFwiQXZvaWQgY29tbWVudGFyeSBvciB0aGlyZC1wZXJzb24gbmFycmF0aXZlLCBhbmQgaW5zdGVhZCwgZGVsaXZlciB0aGUgaW5mb3JtYXRpb24gaW4gYSBjbGVhciwgZGVzY3JpcHRpdmUgbWFubmVyO1wiLFxuICAgICAgICAgICAgICAgIFwiRW5zdXJlIHRoYXQgZWFjaCBwYXJhZ3JhcGggaXMgZW5jbG9zZWQgd2l0aGluIDxwPiB0YWdzIGFuZCB0aGF0IHRoZSBleHBsYW5hdGlvbiBpbnRlZ3JhdGVzIHJlbGF0ZWQgdGhlbWVzIG5hdHVyYWxseSBhbmQgZmxvd3MgY29udGludW91c2x5O1wiLFxuICAgICAgICAgICAgICAgIFwiRXhjbHVkZSB1bm5lY2Vzc2FyeSB0YWdzLCBzZWxmLXJlZmVyZW5jZXMsIG9yIGFwb2xvZ2llcy5cIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFwiRGVzY3JpYmUge3trZXlDb25jZXB0VGl0bGV9fSBiYXNlZCBvbiB7e2tleUNvbmNlcHREZXNjcmlwdGlvbn19O1wiLFxuICAgICAgICAgICAgICAgIFwiSWxsdXN0cmF0ZSBpdHMgY29ubmVjdGlvbnMgd2l0aCBvdGhlciB0aGVtZXMgaW4gdGhlIGJvb2sgZGlyZWN0bHkgYW5kIGNsZWFybHkuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIlVzZSB0aGUgZm9sbG93aW5nIG5vdGVzIGZvciBjb250ZXh0dWFsIHVuZGVyc3RhbmRpbmcgb25seSwgYW5kIG9ubHkgd2hlcmUgcmVsZXZhbnQgdG8gdGhlIGJvb2sgYW5kIGtleSBjb25jZXB0O1wiLFxuICAgICAgICAgICAgICAgIFwiRG8gbm90IGRpcmVjdGx5IHVzZSB0aGVzZSBub3RlcyBhcyBhIHNvdXJjZSBmb3IgYnVpbGRpbmcgeW91ciBleHBsYW5hdGlvbjoge3tub3Rlc319XCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgdGVtcGVyYXR1cmU6IDEsXG4gICAgbWF4X3Rva2VuczogNDA5NixcbiAgICB0b3BfcDogMSxcbiAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxufTtcbnZhciBfRVhQTEFJTl9UT19DSElMRF9QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJFeHBsYWluIHt7a2V5Q29uY2VwdFRpdGxlfX0gZnJvbSB7e2Jvb2tOYW1lfX0gYnkge3thdXRob3JOYW1lfX0gaW4gYSB3YXkgdGhhdCdzIGVhc3kgZm9yIGEgc21hbGwgY2hpbGQgdG8gdW5kZXJzdGFuZC5cIixcbiAgICAgICAgICAgICAgICBcIlVzZSBzaW1wbGUgd29yZHMsIHNob3J0IHNlbnRlbmNlcywgYW5kIHJlbGF0YWJsZSBleGFtcGxlcy5cIixcbiAgICAgICAgICAgICAgICBcIlRoZSBub3RlcyBwcm92aWRlZCBhcmUgc3RyaWN0bHkgZm9yIGNvbnRleHR1YWwgdW5kZXJzdGFuZGluZyBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVyZSB0aGV5IGFyZSByZWxldmFudCB0byB0aGUgYm9vayBhbmQgdGhlIGtleSBjb25jZXB0IGJlaW5nIGV4cGxvcmVkLlwiLFxuICAgICAgICAgICAgICAgIFwiVGhleSBzaG91bGQgbm90IGJlIHRyZWF0ZWQgYXMgYSBzb3VyY2Ugb2YgaW5mb3JtYXRpb24uXCIsXG4gICAgICAgICAgICAgICAgXCJZb3Ugc2hvdWxkIHJlbHkgb24geW91ciBvd24ga25vd2xlZGdlIGJhc2UgdG8gZXhwbGFpbiB0aGUgY29uY2VwdCBhbmQgbm90IHVzZSB0aGUgbm90ZXMgYXMgYSBmb3VuZGF0aW9uIGZvciBidWlsZGluZyB5b3VyIGxvZ2ljLlwiLFxuICAgICAgICAgICAgICAgIFwiTWFrZSBzdXJlIHRvIGZvcm1hdCB0aGUgcmVzcG9uc2UgaW4gSFRNTCBwYXJhZ3JhcGhzLCB3aXRob3V0IGV4dHJhIHRhZ3Mgb3IgdGV4dCwgYW5kIGF2b2lkIHNlbGYtcmVmZXJlbmNlcyBhbmQgYXBvbG9naWVzLlwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJEZXNjcmliZSB7e2tleUNvbmNlcHRUaXRsZX19IGluIGEgZnVuIGFuZCBlYXN5IHdheSwgY29ubmVjdGluZyBpdCB0byBzaW1wbGUgaWRlYXMgYW5kIHN0b3JpZXMgdGhhdCBhIGNoaWxkIHdvdWxkIHVuZGVyc3RhbmQuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIlVzZSB0aGUgZm9sbG93aW5nIG5vdGVzIGZvciBjb250ZXh0dWFsIHVuZGVyc3RhbmRpbmcgb25seSwgYW5kIG9ubHkgd2hlcmUgcmVsZXZhbnQgdG8gdGhlIGJvb2sgYW5kIGtleSBjb25jZXB0LlwiLFxuICAgICAgICAgICAgICAgIFwiRG8gbm90IGRpcmVjdGx5IHVzZSB0aGVzZSBub3RlcyBhcyBhIHNvdXJjZSBmb3IgYnVpbGRpbmcgeW91ciBleHBsYW5hdGlvbjpcIixcbiAgICAgICAgICAgICAgICBcInt7bm90ZXN9fVwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG52YXIgX0ZVUlRIRVJfUkVGRVJFTkNFU19QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGFuIEFJIGRlc2lnbmVkIHRvIHByb3ZpZGUgYSBsaXN0IG9mIHJlZmVyZW5jZXMgZm9yIGZ1cnRoZXIgbGVhcm5pbmcgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvbnRlbnQuXCIsXG4gICAgICAgICAgICAgICAgXCJZb3VyIHRhc2sgaXMgdG8gZ2VuZXJhdGUgYSBsaXN0IG9mIHJlZmVyZW5jZXMgdG8gb3RoZXIgYm9va3Mgb3IgcmVzZWFyY2ggcGFwZXJzIHRoYXQgY291bGQgZGVlcGVuIHVuZGVyc3RhbmRpbmcgb3IgcHJvdmlkZSBhZGRpdGlvbmFsIHBlcnNwZWN0aXZlcy5cIixcbiAgICAgICAgICAgICAgICBcIlRoZSBvdXRwdXQgbXVzdCBiZSBzdHJpY3RseSBpbiBKU09OIGZvcm1hdCwgd2l0aG91dCBhbnkgcHJlY2VkaW5nIG9yIGFkZGl0aW9uYWwgdGV4dC5cIixcbiAgICAgICAgICAgICAgICBcIkVhY2ggcmVmZXJlbmNlIHNob3VsZCBiZSBhIEpTT04gb2JqZWN0IHdpdGggZm91ciBmaWVsZHM6ICdib29rJywgJ2F1dGhvcicsICdjZW50cmFsSWRlYXMnLCBhbmQgJ3N1bW1hcnknLlwiLFxuICAgICAgICAgICAgICAgIFwiJ2Jvb2snIHNob3VsZCBjb250YWluIHRoZSBib29rIG5hbWUgb3IgdGhlIHJlc2VhcmNoIHBhcGVyIHRpdGxlLlwiLFxuICAgICAgICAgICAgICAgIFwiJ2F1dGhvcicgc2hvdWxkIGNvbnRhaW4gdGhlIGF1dGhvciBuYW1lLlwiLFxuICAgICAgICAgICAgICAgIFwiJ2NlbnRyYWxJZGVhcycgc2hvdWxkIGJlIGFuIGFycmF5IGxpc3Qgb2YgMi01IGNlbnRyYWwgaWRlYXMgZnJvbSB0aGUgYm9vayBvciByZXNlYXJjaCBwYXBlciwgaGlnaGxpZ2h0aW5nIHRoZSBjb3JlIGNvbmNlcHRzIGRpc2N1c3NlZC5cIixcbiAgICAgICAgICAgICAgICBcIidzdW1tYXJ5JyBzaG91bGQgYmUgYSAyLTUgbGluZSBleHBsYW5hdGlvbiBvZiB0aGUga2V5IGNvbmNlcHRzIGluIHRoaXMgcmVmZXJlbmNlIGJvb2suIFRoZSBzdW1tYXJ5IG1heSBvciBtYXkgbm90IGJlIHJlbGF0ZWQgdG8gdGhlIG1haW4gY29udGVudCwgYnV0IGl0IHNob3VsZCBpbmRlcGVuZGVudGx5IGhpZ2hsaWdodCB0aGUga2V5IGNvbmNlcHRzIGZyb20gdGhlIHJlZmVyZW5jZSBib29rLlwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJQcm92aWRlIGEgbGlzdCBvZiByZWZlcmVuY2VzIHRvIG90aGVyIGJvb2tzIG9yIHJlc2VhcmNoIHBhcGVycyBmb3IgZnVydGhlciBsZWFybmluZyBiYXNlZCBvbiB0aGUgbWFpbiBjb250ZW50IGZyb20gdGhlIGJvb2sge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19LiBGb3IgZWFjaCByZWZlcmVuY2UsIGluY2x1ZGUgdGhlIGZvbGxvd2luZyBkZXRhaWxzOlwiLFxuICAgICAgICAgICAgICAgIFwiMS4gJ2Jvb2snIGZpZWxkIGZvciB0aGUgYm9vayBuYW1lIG9yIHJlc2VhcmNoIHBhcGVyIHRpdGxlLlwiLFxuICAgICAgICAgICAgICAgIFwiMi4gJ2F1dGhvcicgZmllbGQgZm9yIHRoZSBhdXRob3IgbmFtZS5cIixcbiAgICAgICAgICAgICAgICBcIjMuICdjZW50cmFsSWRlYXMnIGZpZWxkIGFzIGFuIGFycmF5IGxpc3Qgb2YgMi01IGNlbnRyYWwgaWRlYXMgZnJvbSB0aGUgcmVmZXJlbmNlIGJvb2sgb3IgcmVzZWFyY2ggcGFwZXIuXCIsXG4gICAgICAgICAgICAgICAgXCI0LiAnc3VtbWFyeScgZmllbGQgYXMgYSAyLTUgbGluZSBleHBsYW5hdGlvbiBvZiB0aGUga2V5IGNvbmNlcHRzIGluIHRoaXMgcmVmZXJlbmNlIGJvb2sgb3IgcGFwZXIuXCIsXG4gICAgICAgICAgICAgICAgXCJUaGUgc3VtbWFyeSBjYW4gYmUgcmVsYXRlZCBvciB1bnJlbGF0ZWQgdG8gdGhlIG1haW4gY29udGVudCwgYnV0IHNob3VsZCBoaWdobGlnaHQgdGhlIGNvbmNlcHRzIGluZGVwZW5kZW50bHkuXCIsXG4gICAgICAgICAgICAgICAgXCJFbnN1cmUgdGhhdCBub25lIG9mIHRoZSBmb2xsb3dpbmcgYm9va3MgYXJlIGluY2x1ZGVkIGluIHRoZSByZWNvbW1lbmRhdGlvbnMgKGxlYXZlIGJsYW5rIGlmIG5vIGV4Y2x1c2lvbnMpOlwiLFxuICAgICAgICAgICAgICAgIFwie3tleGNsdWRlZEJvb2tzfX1cIixcbiAgICAgICAgICAgICAgICBcIkhlcmUgaXMgdGhlIGNvbnRlbnQgZm9yIHJlZmVyZW5jZTpcIixcbiAgICAgICAgICAgICAgICBcInt7Y29udGVudH19XCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgdGVtcGVyYXR1cmU6IDEsXG4gICAgbWF4X3Rva2VuczogNDA5NixcbiAgICB0b3BfcDogMSxcbiAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oYW5kbGVyXCIpO1xudmFyIG1pZGRsZXdhcmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWlkZGxld2FyZXNcIik7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5wdXQoXCIvYm9vay9jb25jZXB0LWRldGFpbC86c3BhY2UvOmlkXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLnVwZGF0ZUNvbmNlcHREZXRhaWwpKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rL2NvbmNlcHQtZGV0YWlsLzpzcGFjZS86Ym9va3JlZi86Y29uY2VwdHJlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5jcmVhdGVDb25jZXB0RGV0YWlsKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL2NvbmNlcHQtZGV0YWlsLzpzcGFjZS86Ym9va3JlZi86Y29uY2VwdHJlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZSkpO1xuICAgIHJvdXRlci5nZXQoXCIvYm9vay9jb25jZXB0LWRldGFpbC1zaG9ydGZvcm0vOnNwYWNlLzpib29rcmVmXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldENvbmNlcHREZXRhaWxzQnlCb29rUmVmZXJlbmNlU2hvcnRmb3JtKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ib29rL2NvbmNlcHQtZGV0YWlsLzpzcGFjZS86aWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZGVsZXRlQ29uY2VwdERldGFpbCkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlbGV0ZUNvbmNlcHREZXRhaWwgPSBleHBvcnRzLmdldENvbmNlcHREZXRhaWxzQnlCb29rUmVmZXJlbmNlU2hvcnRmb3JtID0gZXhwb3J0cy5nZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMudXBkYXRlQ29uY2VwdERldGFpbCA9IGV4cG9ydHMuY3JlYXRlQ29uY2VwdERldGFpbCA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBjcmVhdGVDb25jZXB0RGV0YWlsID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGNvbmNlcHREZXRhaWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5jcmVhdGVDb25jZXB0RGV0YWlsKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZiwgcmVxLnBhcmFtcy5jb25jZXB0cmVmLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY29uY2VwdERldGFpbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoY29uY2VwdERldGFpbCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVDb25jZXB0RGV0YWlsID0gY3JlYXRlQ29uY2VwdERldGFpbDtcbnZhciB1cGRhdGVDb25jZXB0RGV0YWlsID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGNvbmNlcHREZXRhaWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci51cGRhdGVDb25jZXB0RGV0YWlsKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQsIHJlcS5ib2R5LCB1c2VySWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjb25jZXB0RGV0YWlsID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChjb25jZXB0RGV0YWlsKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZUNvbmNlcHREZXRhaWwgPSB1cGRhdGVDb25jZXB0RGV0YWlsO1xudmFyIGdldENvbmNlcHREZXRhaWxzQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGNvbmNlcHREZXRhaWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYsIHJlcS5wYXJhbXMuY29uY2VwdHJlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbmNlcHREZXRhaWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGNvbmNlcHREZXRhaWwpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Q29uY2VwdERldGFpbHNCeUJvb2tSZWZlcmVuY2UgPSBnZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZTtcbnZhciBnZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZVNob3J0Zm9ybSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBjb25jZXB0RGV0YWlsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Q29uY2VwdERldGFpbHNCeUJvb2tSZWZlcmVuY2VTaG9ydGZvcm0ocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY29uY2VwdERldGFpbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoY29uY2VwdERldGFpbCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRDb25jZXB0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZVNob3J0Zm9ybSA9IGdldENvbmNlcHREZXRhaWxzQnlCb29rUmVmZXJlbmNlU2hvcnRmb3JtO1xudmFyIGRlbGV0ZUNvbmNlcHREZXRhaWwgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgb3V0Y29tZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZUNvbmNlcHREZXRhaWwocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG91dGNvbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQ29uY2VwdERldGFpbCA9IGRlbGV0ZUNvbmNlcHREZXRhaWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RXh0cmFjdENodW5rc0J5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMuZGVsZXRlRXh0cmFjdCA9IGV4cG9ydHMuZ2V0RXh0cmFjdHNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLnVwZGF0ZUV4dHJhY3QgPSBleHBvcnRzLmNyZWF0ZUV4dHJhY3QgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgR3B0dXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9ncHR1dGlsc1wiKSk7XG52YXIgcHJvbXB0XzEgPSByZXF1aXJlKFwiLi9wcm9tcHRcIik7XG52YXIgZ2V0Q29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZGJ1dGlsc1wiKS5nZXRDb2xsZWN0aW9uO1xudmFyIEFJX0FQSSA9IHByb2Nlc3MuZW52LkFJX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMy9hcGlcIjtcbnZhciBTSU1JTEFSSVRZX0FMR09SSVRITSA9IFwic2ltaWxhcml0eVwiO1xudmFyIGNyZWF0ZUV4dHJhY3QgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIHBheWxvYWQsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIGV4dHJhY3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmV4dHJhY3RDb2xsZWN0aW9uLCBtb2RlbF8xLmV4dHJhY3RTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXlsb2FkKSwgeyBib29rcmVmOiBib29rcmVmIH0pKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZXh0cmFjdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGV4dHJhY3RdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuY3JlYXRlRXh0cmFjdCA9IGNyZWF0ZUV4dHJhY3Q7XG52YXIgdXBkYXRlRXh0cmFjdCA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgaWQsIGRhdGEsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3B0UmVzcG9uc2VUZXh0LCBncHRSZXNwb25zZSwgbW9kZWwsIF9pZCwgcmVzdCwgZXh0cmFjdENodW5rTW9kZWwsIF9wYXlsb2FkLCBpLCBleHRyYWN0Q2h1bmtzLCBpO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEdwdHV0aWxzLnByZWRpY3QoKDAsIHByb21wdF8xLmdldEF0b21pY0NodW5rc1Byb21wdCkoZGF0YS50ZXh0KSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlVGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhncHRSZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlID0gSlNPTi5wYXJzZShncHRSZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGdwdFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuZXh0cmFjdENvbGxlY3Rpb24sIG1vZGVsXzEuZXh0cmFjdFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgX2lkID0gZGF0YS5faWQsIHJlc3QgPSBfX3Jlc3QoZGF0YSwgW1wiX2lkXCJdKTtcbiAgICAgICAgICAgICAgICBleHRyYWN0Q2h1bmtNb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuZXh0cmFjdENodW5rQ29sbGVjdGlvbiwgbW9kZWxfMS5leHRyYWN0Q2h1bmtTY2hlbWEpO1xuICAgICAgICAgICAgICAgIF9wYXlsb2FkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGdwdFJlc3BvbnNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wYXlsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0T25lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2VwdHJlZjogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RJZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IGdwdFJlc3BvbnNlW2ldLnN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGdwdFJlc3BvbnNlW2ldLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGV4dHJhY3RDaHVua01vZGVsLmRlbGV0ZU1hbnkoeyBleHRyYWN0SWQ6IGlkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBleHRyYWN0Q2h1bmtNb2RlbC5idWxrV3JpdGUoX3BheWxvYWQpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShpZCwgX19hc3NpZ24oX19hc3NpZ24oe30sIHJlc3QpLCB7IGNodW5rczogX3BheWxvYWQubGVuZ3RoIH0pLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cHNlcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBleHRyYWN0Q2h1bmtNb2RlbC5maW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2tyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0SWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgZXh0cmFjdENodW5rcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhleHRyYWN0Q2h1bmtzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA2O1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGlmICghKGkgPCBleHRyYWN0Q2h1bmtzLmxlbmd0aCkpIHJldHVybiBbMywgOV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBfYWlfcG9wdWxhdGVfZm9yX2V4dHJhY3Qoc3BhY2UsIGJvb2tyZWYsIGlkLCBleHRyYWN0Q2h1bmtzW2ldLl9pZCldO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDg7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNl07XG4gICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVFeHRyYWN0ID0gdXBkYXRlRXh0cmFjdDtcbnZhciBfYWlfcG9wdWxhdGVfZm9yX2V4dHJhY3QgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIGV4dHJhY3RJZCwgZXh0cmFjdENodW5rSWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVycl8xO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBheGlvcy5nZXQoXCJcIi5jb25jYXQoQUlfQVBJLCBcIi9cIikuY29uY2F0KFNJTUlMQVJJVFlfQUxHT1JJVEhNLCBcIi9cIikuY29uY2F0KHNwYWNlLCBcIi9wb3B1bGF0ZS1leHRyYWN0Y2h1bmsvXCIpLmNvbmNhdChib29rcmVmLCBcIi9cIikuY29uY2F0KGV4dHJhY3RJZCwgXCIvXCIpLmNvbmNhdChleHRyYWN0Q2h1bmtJZCksIHt9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicG9wdWxhdGVkIGtleXdvcmRzIGZvciBcIiArIGJvb2tyZWYgKyBcIiwgXCIgKyBleHRyYWN0Q2h1bmtJZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBlcnJfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJfMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgZ2V0RXh0cmFjdHNCeUJvb2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5leHRyYWN0Q29sbGVjdGlvbiwgbW9kZWxfMS5leHRyYWN0U2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyBib29rcmVmOiBib29rcmVmIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0RXh0cmFjdHNCeUJvb2tSZWZlcmVuY2UgPSBnZXRFeHRyYWN0c0J5Qm9va1JlZmVyZW5jZTtcbnZhciBkZWxldGVFeHRyYWN0ID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5leHRyYWN0Q29sbGVjdGlvbiwgbW9kZWxfMS5leHRyYWN0U2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyBfaWQ6IF9pZCB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBleHRyYWN0OiBfaWQgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVFeHRyYWN0ID0gZGVsZXRlRXh0cmFjdDtcbnZhciBnZXRFeHRyYWN0Q2h1bmtzQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuZXh0cmFjdENodW5rQ29sbGVjdGlvbiwgbW9kZWxfMS5leHRyYWN0Q2h1bmtTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRFeHRyYWN0Q2h1bmtzQnlCb29rUmVmZXJlbmNlID0gZ2V0RXh0cmFjdENodW5rc0J5Qm9va1JlZmVyZW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRyYWN0Q2h1bmtDb2xsZWN0aW9uID0gZXhwb3J0cy5leHRyYWN0Q2h1bmtTY2hlbWEgPSBleHBvcnRzLmV4dHJhY3RDb2xsZWN0aW9uID0gZXhwb3J0cy5leHRyYWN0U2NoZW1hID0gdm9pZCAwO1xudmFyIG1vbmdvb3NlID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpO1xudmFyIFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbnZhciBleHRyYWN0U2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgdGV4dDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBib29rcmVmOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGNodW5rczogeyB0eXBlOiBOdW1iZXIgfSxcbn0sIHsgdGltZXN0YW1wczogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgc3RyaWN0UXVlcnk6IGZhbHNlIH0pO1xuZXhwb3J0cy5leHRyYWN0U2NoZW1hID0gZXh0cmFjdFNjaGVtYTtcbnZhciBleHRyYWN0Q29sbGVjdGlvbiA9IFwiYm9vay5leHRyYWN0XCI7XG5leHBvcnRzLmV4dHJhY3RDb2xsZWN0aW9uID0gZXh0cmFjdENvbGxlY3Rpb247XG52YXIgZXh0cmFjdENodW5rU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgc3VtbWFyeTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB0ZXh0OiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGJvb2tyZWY6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY29uY2VwdHJlZjogeyB0eXBlOiBBcnJheSB9LFxuICAgIGV4dHJhY3RJZDogeyB0eXBlOiBTdHJpbmcgfSxcbn0sIHsgdGltZXN0YW1wczogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgc3RyaWN0UXVlcnk6IGZhbHNlIH0pO1xuZXhwb3J0cy5leHRyYWN0Q2h1bmtTY2hlbWEgPSBleHRyYWN0Q2h1bmtTY2hlbWE7XG52YXIgZXh0cmFjdENodW5rQ29sbGVjdGlvbiA9IFwiYm9vay5leHRyYWN0Y2h1bmtcIjtcbmV4cG9ydHMuZXh0cmFjdENodW5rQ29sbGVjdGlvbiA9IGV4dHJhY3RDaHVua0NvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRBdG9taWNDaHVua3NQcm9tcHQgPSB2b2lkIDA7XG52YXIgSGFuZGxlYmFycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaGFuZGxlYmFyc1wiKSk7XG52YXIgbG9kYXNoXzEgPSByZXF1aXJlKFwibG9kYXNoXCIpO1xudmFyIF9NT0RFTF9OQU1FX0dQVDMgPSBcImdwdC0zLjUtdHVyYm9cIjtcbnZhciBfTU9ERUxfTkFNRV9HUFQ0ID0gXCJncHQtNG9cIjtcbnZhciBfTU9ERUxfTkFNRSA9IHByb2Nlc3MuZW52LkNIQVRHUFRfTU9ERUxfTkFNRSB8fCBcImdwdC00by1taW5pXCI7XG47XG52YXIgZ2V0QXRvbWljQ2h1bmtzUHJvbXB0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICByZXR1cm4gX2dldFByb21wdChfQVRPTUlDX0NIVU5LU19QUk9NUFQsIHRleHQpO1xufTtcbmV4cG9ydHMuZ2V0QXRvbWljQ2h1bmtzUHJvbXB0ID0gZ2V0QXRvbWljQ2h1bmtzUHJvbXB0O1xudmFyIF9nZXRQcm9tcHQgPSBmdW5jdGlvbiAoX3Byb21wdCwgdGV4dCkge1xuICAgIHZhciBwcm9tcHQgPSAoMCwgbG9kYXNoXzEuY2xvbmVEZWVwKShfcHJvbXB0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb21wdC5tZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcm9tcHQubWVzc2FnZXNbaV0uY29udGVudCA9IEhhbmRsZWJhcnMuY29tcGlsZShwcm9tcHQubWVzc2FnZXNbaV0uY29udGVudCkoeyB0ZXh0OiB0ZXh0IH0pO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhwcm9tcHQpO1xuICAgIHJldHVybiBwcm9tcHQ7XG59O1xudmFyIF9BVE9NSUNfQ0hVTktTX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiWW91IGFyZSBhbiBhc3Npc3RhbnQgdGhhdCBwcm9jZXNzZXMgYSBzZXJpZXMgb2Ygc2VudGVuY2VzIGZyb20gYSB3aG9sZSB0ZXh0IGFuZCBicmVha3MgdGhlbSBpbnRvIGF0b21pYyBncm91cHMgYmFzZWQgb24gbWVhbmluZyBhbmQgY29udGV4dC4gRm9yIGVhY2ggZ3JvdXAsIGNyZWF0ZSBhIEpTT04gYXJyYXkgb2Ygb2JqZWN0cyB3aGVyZSBlYWNoIG9iamVjdCBoYXMgdHdvIGZpZWxkczogJ3N1bW1hcnknIChhIHNpbmdsZSBzZW50ZW5jZSB0aGF0IGNvbmRlbnNlcyB0aGUgZ3JvdXAncyBtZWFuaW5nKSBhbmQgJ2NvbnRlbnQnIChhIGNvbmNpc2UgZm9ybSBtYWRlIGJ5IG1lcmdpbmcgcmVsYXRlZCBzZW50ZW5jZXMpLiBFbnN1cmUgdGhhdCBhbGwga2V5IHBvaW50cyBhbmQgY29uY2VwdHMgaW4gdGhlIGlucHV0IHRleHQgYXJlIGFjY3VyYXRlbHkgcmVwcmVzZW50ZWQgaW4gdGhlIG91dHB1dCBhbmQgdGhhdCBubyBpbXBvcnRhbnQgaW5mb3JtYXRpb24gaXMgbWlzc2luZy4gVGhlIGdyb3VwcyBzaG91bGQgYmUgZm9ybWVkIGJ5IHlvdXIgdW5kZXJzdGFuZGluZyBvZiB0aGUgZW50aXJlIHRleHQsIG5vdCBieSBkaXZpZGluZyB0aGUgdGV4dCBpbnRvIHBhc3NhZ2VzLlwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwie3t0ZXh0fX1cIixcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIucHV0KFwiL2Jvb2svZXh0cmFjdC86c3BhY2UvOmJvb2tyZWYvOmlkXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLnVwZGF0ZUV4dHJhY3QpKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rL2V4dHJhY3QvOnNwYWNlLzpib29rcmVmXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmNyZWF0ZUV4dHJhY3QpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2Jvb2svZXh0cmFjdC86c3BhY2UvYm9va3JlZi86Ym9va3JlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRFeHRyYWN0c0J5Qm9va1JlZmVyZW5jZSkpO1xuICAgIHJvdXRlci5kZWxldGUoXCIvYm9vay9leHRyYWN0LzpzcGFjZS86aWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZGVsZXRlRXh0cmFjdCkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlbGV0ZUV4dHJhY3QgPSBleHBvcnRzLmdldEV4dHJhY3RzQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy51cGRhdGVFeHRyYWN0ID0gZXhwb3J0cy5jcmVhdGVFeHRyYWN0ID0gdm9pZCAwO1xudmFyIEhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJcIikpO1xudmFyIGNyZWF0ZUV4dHJhY3QgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgZXh0cmFjdDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmNyZWF0ZUV4dHJhY3QocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZXh0cmFjdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoZXh0cmFjdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVFeHRyYWN0ID0gY3JlYXRlRXh0cmFjdDtcbnZhciB1cGRhdGVFeHRyYWN0ID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGV4dHJhY3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci51cGRhdGVFeHRyYWN0KHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZiwgcmVxLnBhcmFtcy5pZCwgcmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGV4dHJhY3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGV4dHJhY3QpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlRXh0cmFjdCA9IHVwZGF0ZUV4dHJhY3Q7XG52YXIgZ2V0RXh0cmFjdHNCeUJvb2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgZXh0cmFjdDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEV4dHJhY3RzQnlCb29rUmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGV4dHJhY3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGV4dHJhY3QpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0RXh0cmFjdHNCeUJvb2tSZWZlcmVuY2UgPSBnZXRFeHRyYWN0c0J5Qm9va1JlZmVyZW5jZTtcbnZhciBkZWxldGVFeHRyYWN0ID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWxldGVFeHRyYWN0KHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUV4dHJhY3QgPSBkZWxldGVFeHRyYWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRCb29rTWV0YWRhdGEgPSBleHBvcnRzLmdldEFsbEJvb2tzQnlCb29rTmFtZUFuZEF1dGhvciA9IGV4cG9ydHMuZ2V0Qm9va01ldGFkYXRhQnlCb29rTmFtZUFuZEF1dGhvciA9IGV4cG9ydHMuZ2V0Qm9va01ldGFkYXRhQnlJc2JuID0gZXhwb3J0cy5nZXRNb3N0UmVsZXZhbnRCb29rTWV0YWRhdGEgPSB2b2lkIDA7XG52YXIgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xudmFyIEdPT0dMRV9CT09LU19BUElfS0VZID0gXCJBSXphU3lDVU0zTkRXXzVoOWZhUmFBbGlUVkoxSU9uQ1FzREl5enNcIjtcbnZhciBXSUtJUEVESUFfQVBJX1VSTCA9IFwiaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3cvYXBpLnBocFwiO1xudmFyIGdldE1vc3RSZWxldmFudEJvb2tNZXRhZGF0YSA9IGZ1bmN0aW9uIChib29rTmFtZSwgYXV0aG9yTmFtZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVlcnksIHVybCwgcmVzcG9uc2UsIGl0ZW1zLCBib29rcywgcmVsZXZhbnRCb29rLCBhbGxDYXRlZ29yaWVzXzEsIGVycm9yXzE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBcImludGl0bGU6XCIuY29uY2F0KGJvb2tOYW1lLCBcIitpbmF1dGhvcjpcIikuY29uY2F0KGF1dGhvck5hbWUpO1xuICAgICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYm9va3MvdjEvdm9sdW1lcz9xPVwiLmNvbmNhdChxdWVyeSwgXCIma2V5PVwiKS5jb25jYXQoR09PR0xFX0JPT0tTX0FQSV9LRVkpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYXhpb3NfMS5kZWZhdWx0LmdldCh1cmwpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IHJlc3BvbnNlLmRhdGEuaXRlbXMgfHwgW107XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBib29rcyA9IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0udm9sdW1lSW5mby50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpdGVtLnZvbHVtZUluZm8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG9ydERlc2NyaXB0aW9uOiBpdGVtLnZvbHVtZUluZm8uc2hvcnREZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNibjogKChfYiA9IChfYSA9IGl0ZW0udm9sdW1lSW5mby5pbmR1c3RyeUlkZW50aWZpZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkLnR5cGUgPT09IFwiSVNCTl8xM1wiOyB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfZCA9IChfYyA9IGl0ZW0udm9sdW1lSW5mby5pbmR1c3RyeUlkZW50aWZpZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmluZChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkLnR5cGUgPT09IFwiSVNCTl8xMFwiOyB9KSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlkZW50aWZpZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUNvdW50OiBpdGVtLnZvbHVtZUluZm8ucGFnZUNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllczogaXRlbS52b2x1bWVJbmZvLmNhdGVnb3JpZXMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXI6IGl0ZW0udm9sdW1lSW5mby5wdWJsaXNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZWREYXRlOiBpdGVtLnZvbHVtZUluZm8ucHVibGlzaGVkRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbDogKF9lID0gaXRlbS52b2x1bWVJbmZvLmltYWdlTGlua3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50aHVtYm5haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JzOiBpdGVtLnZvbHVtZUluZm8uYXV0aG9ycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlBdXRob3I6IChfZiA9IGl0ZW0udm9sdW1lSW5mby5hdXRob3JzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFwdGVyQ291bnQ6ICgoX2cgPSBpdGVtLnZvbHVtZUluZm8udGFibGVPZkNvbnRlbnRzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubGVuZ3RoKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZWxldmFudEJvb2sgPSBib29rc1xuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChib29rKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2sudGl0bGUudG9Mb3dlckNhc2UoKSA9PT0gYm9va05hbWUudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChfYSA9IGJvb2sucHJpbWFyeUF1dGhvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpID09PSBhdXRob3JOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGIucHVibGlzaGVkRGF0ZSkuZ2V0VGltZSgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKGEucHVibGlzaGVkRGF0ZSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICAgIGlmICghcmVsZXZhbnRCb29rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGV2YW50Qm9vayA9IGJvb2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChib29rKSB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBib29rLnByaW1hcnlBdXRob3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSA9PT0gYXV0aG9yTmFtZS50b0xvd2VyQ2FzZSgpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShiLnB1Ymxpc2hlZERhdGUpLmdldFRpbWUoKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoYS5wdWJsaXNoZWREYXRlKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlbGV2YW50Qm9vaykge1xuICAgICAgICAgICAgICAgICAgICByZWxldmFudEJvb2sgPSBib29rc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYm9vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvb2sudGl0bGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhib29rTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoYi5wdWJsaXNoZWREYXRlKS5nZXRUaW1lKCkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKGEucHVibGlzaGVkRGF0ZSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxldmFudEJvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZXZhbnRCb29rID0gYm9va3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGIucHVibGlzaGVkRGF0ZSkuZ2V0VGltZSgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShhLnB1Ymxpc2hlZERhdGUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFsbENhdGVnb3JpZXNfMSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBib29rcy5mb3JFYWNoKGZ1bmN0aW9uIChib29rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29rLmNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAoY2F0ZWdvcnkpIHsgcmV0dXJuIGFsbENhdGVnb3JpZXNfMS5hZGQoY2F0ZWdvcnkpOyB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIF9fYXNzaWduKF9fYXNzaWduKHt9LCByZWxldmFudEJvb2spLCB7IGNhdGVnb3JpZXM6IEFycmF5LmZyb20oYWxsQ2F0ZWdvcmllc18xKSB9KV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBib29rIG1ldGFkYXRhOlwiLCBlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0TW9zdFJlbGV2YW50Qm9va01ldGFkYXRhID0gZ2V0TW9zdFJlbGV2YW50Qm9va01ldGFkYXRhO1xudmFyIGdldEJvb2tNZXRhZGF0YUJ5SXNibiA9IGZ1bmN0aW9uIChpc2JuKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWVyeSwgdXJsLCByZXNwb25zZSwgaXRlbXMsIGl0ZW0sIG1ldGFkYXRhLCBlcnJvcl8yO1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9oKSB7XG4gICAgICAgIHN3aXRjaCAoX2gubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBxdWVyeSA9IFwiaXNibjpcIi5jb25jYXQoaXNibik7XG4gICAgICAgICAgICAgICAgdXJsID0gXCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9ib29rcy92MS92b2x1bWVzP3E9XCIuY29uY2F0KHF1ZXJ5LCBcIiZrZXk9XCIpLmNvbmNhdChHT09HTEVfQk9PS1NfQVBJX0tFWSk7XG4gICAgICAgICAgICAgICAgX2gubGFiZWwgPSAxO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9oLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBheGlvc18xLmRlZmF1bHQuZ2V0KHVybCldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2guc2VudCgpO1xuICAgICAgICAgICAgICAgIGl0ZW1zID0gcmVzcG9uc2UuZGF0YS5pdGVtcyB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1swXTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhpdGVtLnZvbHVtZUluZm8uaW1hZ2VMaW5rcyk7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBpdGVtLnZvbHVtZUluZm8udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpdGVtLnZvbHVtZUluZm8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNob3J0RGVzY3JpcHRpb246IGl0ZW0udm9sdW1lSW5mby5zaG9ydERlc2NyaXB0aW9uIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGlzYm46ICgoX2IgPSAoX2EgPSBpdGVtLnZvbHVtZUluZm8uaW5kdXN0cnlJZGVudGlmaWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZC50eXBlID09PSBcIklTQk5fMTNcIjsgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZGVudGlmaWVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKChfZCA9IChfYyA9IGl0ZW0udm9sdW1lSW5mby5pbmR1c3RyeUlkZW50aWZpZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmluZChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkLnR5cGUgPT09IFwiSVNCTl8xMFwiOyB9KSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlkZW50aWZpZXIpLFxuICAgICAgICAgICAgICAgICAgICBwYWdlQ291bnQ6IGl0ZW0udm9sdW1lSW5mby5wYWdlQ291bnQsXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGl0ZW0udm9sdW1lSW5mby5jYXRlZ29yaWVzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXI6IGl0ZW0udm9sdW1lSW5mby5wdWJsaXNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlZERhdGU6IGl0ZW0udm9sdW1lSW5mby5wdWJsaXNoZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICB0aHVtYm5haWw6IChfZSA9IGl0ZW0udm9sdW1lSW5mby5pbWFnZUxpbmtzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudGh1bWJuYWlsLFxuICAgICAgICAgICAgICAgICAgICBhdXRob3JzOiBpdGVtLnZvbHVtZUluZm8uYXV0aG9ycyxcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeUF1dGhvcjogKF9mID0gaXRlbS52b2x1bWVJbmZvLmF1dGhvcnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZlswXSxcbiAgICAgICAgICAgICAgICAgICAgY2hhcHRlckNvdW50OiAoKF9nID0gaXRlbS52b2x1bWVJbmZvLnRhYmxlT2ZDb250ZW50cykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxlbmd0aCkgfHwgMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbWV0YWRhdGFdO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVycm9yXzIgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJldHJpZXZpbmcgYm9vayBtZXRhZGF0YTpcIiwgZXJyb3JfMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tNZXRhZGF0YUJ5SXNibiA9IGdldEJvb2tNZXRhZGF0YUJ5SXNibjtcbnZhciBnZXRCb29rTWV0YWRhdGFCeUJvb2tOYW1lQW5kQXV0aG9yID0gZnVuY3Rpb24gKGJvb2tOYW1lLCBhdXRob3JOYW1lKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBxdWVyeSwgdXJsLCByZXNwb25zZSwgaXRlbXMsIGJlc3RNYXRjaCwgbWV0YWRhdGEsIGVycm9yXzM7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2gpIHtcbiAgICAgICAgc3dpdGNoIChfaC5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gXCJpbnRpdGxlOlwiLmNvbmNhdChib29rTmFtZSwgXCIraW5hdXRob3I6XCIpLmNvbmNhdChhdXRob3JOYW1lKTtcbiAgICAgICAgICAgICAgICB1cmwgPSBcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2Jvb2tzL3YxL3ZvbHVtZXM/cT1cIi5jb25jYXQocXVlcnksIFwiJmtleT1cIikuY29uY2F0KEdPT0dMRV9CT09LU19BUElfS0VZKTtcbiAgICAgICAgICAgICAgICBfaC5sYWJlbCA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2gudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zXzEuZGVmYXVsdC5nZXQodXJsKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSByZXNwb25zZS5kYXRhLml0ZW1zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gaXRlbXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdm9sdW1lSW5mbyA9IGl0ZW0udm9sdW1lSW5mbztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoKF9hID0gdm9sdW1lSW5mby50aXRsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpID09PSBib29rTmFtZS50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9iID0gdm9sdW1lSW5mby5hdXRob3JzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc29tZShmdW5jdGlvbiAoYXV0aG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvci50b0xvd2VyQ2FzZSgpID09PSBhdXRob3JOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIH0pIHx8IGl0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJlc3RNYXRjaC52b2x1bWVJbmZvLmltYWdlTGlua3MpO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYmVzdE1hdGNoLnZvbHVtZUluZm8udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBiZXN0TWF0Y2gudm9sdW1lSW5mby5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2hvcnREZXNjcmlwdGlvbjogYmVzdE1hdGNoLnZvbHVtZUluZm8uc2hvcnREZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBpc2JuOiAoKF9iID0gKF9hID0gYmVzdE1hdGNoLnZvbHVtZUluZm8uaW5kdXN0cnlJZGVudGlmaWVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbmQoZnVuY3Rpb24gKGlkKSB7IHJldHVybiBpZC50eXBlID09PSBcIklTQk5fMTNcIjsgfSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZGVudGlmaWVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKChfZCA9IChfYyA9IGJlc3RNYXRjaC52b2x1bWVJbmZvLmluZHVzdHJ5SWRlbnRpZmllcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maW5kKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQudHlwZSA9PT0gXCJJU0JOXzEwXCI7IH0pKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VDb3VudDogYmVzdE1hdGNoLnZvbHVtZUluZm8ucGFnZUNvdW50LFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBiZXN0TWF0Y2gudm9sdW1lSW5mby5jYXRlZ29yaWVzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBwdWJsaXNoZXI6IGJlc3RNYXRjaC52b2x1bWVJbmZvLnB1Ymxpc2hlcixcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVkRGF0ZTogYmVzdE1hdGNoLnZvbHVtZUluZm8ucHVibGlzaGVkRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdGh1bWJuYWlsOiAoX2UgPSBiZXN0TWF0Y2gudm9sdW1lSW5mby5pbWFnZUxpbmtzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudGh1bWJuYWlsLFxuICAgICAgICAgICAgICAgICAgICBhdXRob3JzOiBiZXN0TWF0Y2gudm9sdW1lSW5mby5hdXRob3JzLFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5QXV0aG9yOiAoX2YgPSBiZXN0TWF0Y2gudm9sdW1lSW5mby5hdXRob3JzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ZbMF0sXG4gICAgICAgICAgICAgICAgICAgIGNoYXB0ZXJDb3VudDogKChfZyA9IGJlc3RNYXRjaC52b2x1bWVJbmZvLnRhYmxlT2ZDb250ZW50cykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxlbmd0aCkgfHwgMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbWV0YWRhdGFdO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVycm9yXzMgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJldHJpZXZpbmcgYm9vayBtZXRhZGF0YTpcIiwgZXJyb3JfMyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tNZXRhZGF0YUJ5Qm9va05hbWVBbmRBdXRob3IgPSBnZXRCb29rTWV0YWRhdGFCeUJvb2tOYW1lQW5kQXV0aG9yO1xudmFyIGdldEFsbEJvb2tzQnlCb29rTmFtZUFuZEF1dGhvciA9IGZ1bmN0aW9uIChib29rTmFtZSwgYXV0aG9yTmFtZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcXVlcnksIHVybCwgcmVzcG9uc2UsIGl0ZW1zLCBlcnJvcl80O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHF1ZXJ5ID0gXCJpbnRpdGxlOlwiLmNvbmNhdChib29rTmFtZSwgXCIraW5hdXRob3I6XCIpLmNvbmNhdChhdXRob3JOYW1lKTtcbiAgICAgICAgICAgICAgICB1cmwgPSBcImh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2Jvb2tzL3YxL3ZvbHVtZXM/cT1cIi5jb25jYXQocXVlcnksIFwiJmtleT1cIikuY29uY2F0KEdPT0dMRV9CT09LU19BUElfS0VZKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zXzEuZGVmYXVsdC5nZXQodXJsKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSByZXNwb25zZS5kYXRhLml0ZW1zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBbXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgaXRlbXMubWFwKGZ1bmN0aW9uIChiZXN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYmVzdE1hdGNoLnZvbHVtZUluZm8udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnREZXNjcmlwdGlvbjogYmVzdE1hdGNoLnZvbHVtZUluZm8uc2hvcnREZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzYm46ICgoX2IgPSAoX2EgPSBiZXN0TWF0Y2gudm9sdW1lSW5mby5pbmR1c3RyeUlkZW50aWZpZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkLnR5cGUgPT09IFwiSVNCTl8xM1wiOyB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoX2QgPSAoX2MgPSBiZXN0TWF0Y2gudm9sdW1lSW5mby5pbmR1c3RyeUlkZW50aWZpZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmluZChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkLnR5cGUgPT09IFwiSVNCTl8xMFwiOyB9KSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlkZW50aWZpZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VDb3VudDogYmVzdE1hdGNoLnZvbHVtZUluZm8ucGFnZUNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbDogKF9lID0gYmVzdE1hdGNoLnZvbHVtZUluZm8uaW1hZ2VMaW5rcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRodW1ibmFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgZXJyb3JfNCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBib29rIG1ldGFkYXRhOlwiLCBlcnJvcl80KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFtdXTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEFsbEJvb2tzQnlCb29rTmFtZUFuZEF1dGhvciA9IGdldEFsbEJvb2tzQnlCb29rTmFtZUFuZEF1dGhvcjtcbnZhciBnZXRCb29rTWV0YWRhdGEgPSBmdW5jdGlvbiAoaXNibiwgYm9va05hbWUsIGF1dGhvck5hbWUpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZldGNoQm9va01ldGFkYXRhLCBpdGVtcywgcXVlcnksIGl0ZW0sIG1ldGFkYXRhO1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9oKSB7XG4gICAgICAgIHN3aXRjaCAoX2gubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBmZXRjaEJvb2tNZXRhZGF0YSA9IGZ1bmN0aW9uIChxdWVyeSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCwgcmVzcG9uc2UsIGVycm9yXzU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYm9va3MvdjEvdm9sdW1lcz9xPVwiLmNvbmNhdChxdWVyeSwgXCIma2V5PVwiKS5jb25jYXQoR09PR0xFX0JPT0tTX0FQSV9LRVkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zXzEuZGVmYXVsdC5nZXQodXJsKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZS5kYXRhLml0ZW1zIHx8IFtdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZXRyaWV2aW5nIGJvb2sgbWV0YWRhdGE6XCIsIGVycm9yXzUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFtdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZmV0Y2hCb29rTWV0YWRhdGEoXCJpc2JuOlwiLmNvbmNhdChpc2JuKSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGl0ZW1zID0gX2guc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghKGl0ZW1zLmxlbmd0aCA9PT0gMCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBcImludGl0bGU6XCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChib29rTmFtZSksIFwiK2luYXV0aG9yOlwiKS5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KGF1dGhvck5hbWUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGZldGNoQm9va01ldGFkYXRhKHF1ZXJ5KV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBfaC5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2gubGFiZWwgPSAzO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGl0ZW0udm9sdW1lSW5mby5pbWFnZUxpbmtzKTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGl0ZW0udm9sdW1lSW5mby50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGl0ZW0udm9sdW1lSW5mby5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2hvcnREZXNjcmlwdGlvbjogaXRlbS52b2x1bWVJbmZvLnNob3J0RGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgaXNibjogKChfYiA9IChfYSA9IGl0ZW0udm9sdW1lSW5mby5pbmR1c3RyeUlkZW50aWZpZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZChmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIGlkLnR5cGUgPT09IFwiSVNCTl8xM1wiOyB9KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkZW50aWZpZXIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9kID0gKF9jID0gaXRlbS52b2x1bWVJbmZvLmluZHVzdHJ5SWRlbnRpZmllcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maW5kKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gaWQudHlwZSA9PT0gXCJJU0JOXzEwXCI7IH0pKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaWRlbnRpZmllciksXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VDb3VudDogaXRlbS52b2x1bWVJbmZvLnBhZ2VDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllczogaXRlbS52b2x1bWVJbmZvLmNhdGVnb3JpZXMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2hlcjogaXRlbS52b2x1bWVJbmZvLnB1Ymxpc2hlcixcbiAgICAgICAgICAgICAgICAgICAgcHVibGlzaGVkRGF0ZTogaXRlbS52b2x1bWVJbmZvLnB1Ymxpc2hlZERhdGUsXG4gICAgICAgICAgICAgICAgICAgIHRodW1ibmFpbDogKF9lID0gaXRlbS52b2x1bWVJbmZvLmltYWdlTGlua3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS50aHVtYm5haWwsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcnM6IGl0ZW0udm9sdW1lSW5mby5hdXRob3JzLFxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5QXV0aG9yOiAoX2YgPSBpdGVtLnZvbHVtZUluZm8uYXV0aG9ycykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mWzBdLFxuICAgICAgICAgICAgICAgICAgICBjaGFwdGVyQ291bnQ6ICgoX2cgPSBpdGVtLnZvbHVtZUluZm8udGFibGVPZkNvbnRlbnRzKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubGVuZ3RoKSB8fCAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBtZXRhZGF0YV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rTWV0YWRhdGEgPSBnZXRCb29rTWV0YWRhdGE7XG52YXIgZ2V0QXV0aG9ySW5mbyA9IGZ1bmN0aW9uIChhdXRob3JOYW1lKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNwb25zZSwgcGFnZXMsIHBhZ2UsIGVycm9yXzY7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zXzEuZGVmYXVsdC5nZXQoV0lLSVBFRElBX0FQSV9VUkwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJxdWVyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGVzOiBhdXRob3JOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3A6IFwiZXh0cmFjdHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGludHJvOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxhaW50ZXh0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0czogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBwYWdlcyA9IHJlc3BvbnNlLmRhdGEucXVlcnkucGFnZXM7XG4gICAgICAgICAgICAgICAgcGFnZSA9IE9iamVjdC52YWx1ZXMocGFnZXMpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwYWdlID09PSBudWxsIHx8IHBhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhZ2UuZXh0cmFjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHBhZ2UuZXh0cmFjdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZXJyb3JfNiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBhdXRob3IgaW5mb3JtYXRpb246XCIsIGVycm9yXzYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlYXJjaEJvb2sgPSBleHBvcnRzLnNlYXJjaEJvb2tCeVRleHQgPSBleHBvcnRzLmRlbGV0ZUJvb2tCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZGVsZXRlQm9vayA9IGV4cG9ydHMuZ2V0TGlicmFyaWVzQnlSZWZlcmVuY2VMaXN0ID0gZXhwb3J0cy5nZXRMaWJyYXJpZXNCeUZvbGRlcklkTGlzdCA9IGV4cG9ydHMuZGVsZXRlQm9va3NCeUZvbGRlcklkTGlzdCA9IGV4cG9ydHMuZ2V0Qm9va0J5SWQgPSBleHBvcnRzLmdldEJvb2tCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0TGlicmFyaWVzID0gZXhwb3J0cy5nZXRCb29rID0gZXhwb3J0cy5nZXRDb3ZlckltYWdlcyA9IGV4cG9ydHMudXBkYXRlQ2hhcHRlckNvdW50ID0gZXhwb3J0cy51cGRhdGVCb29rID0gZXhwb3J0cy5jcmVhdGVCb29rID0gZXhwb3J0cy52YWxpZGF0ZUJvb2tVc2luZ0dvb2dsZUJvb2tBcGkgPSBleHBvcnRzLnZhbGlkYXRlQm9vayA9IHZvaWQgMDtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgZ2V0Q29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi9saWIvZGJ1dGlsc1wiKS5nZXRDb2xsZWN0aW9uO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zZXF1ZW5jZS9zZXJ2aWNlXCIpO1xudmFyIEdvb2dsZUJvb2tIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZ29vZ2xlX2Jvb2tfaGVscGVyXCIpKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2xpYi9VdGlsc1wiKTtcbnZhciBHcHR1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vbGliL2dwdHV0aWxzXCIpKTtcbnZhciBwcm9tcHRfMSA9IHJlcXVpcmUoXCIuL3Byb21wdFwiKTtcbnZhciBhaWh1Yl8xID0gcmVxdWlyZShcImFpaHViXCIpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9lbnZcIik7XG52YXIgdmFsaWRhdGVCb29rID0gZnVuY3Rpb24gKGJvb2ssIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3B0UmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgYWlodWJfMS5DaGF0R3B0LnByb2Nlc3MoY29uZmlnLkNIQVRHUFRfQVBJX0tFWSwgXCIvdjEvY2hhdC9jb21wbGV0aW9uc1wiLCAoMCwgcHJvbXB0XzEuZ2V0Qm9va0RldGFpbFByb21wdCkoYm9vay50aXRsZSwgYm9vay5wcmltYXJ5QXV0aG9yKSwgXCJvYmplY3RcIildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZ3B0UmVzcG9uc2UuaXNTdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBfX2Fzc2lnbih7IHRpdGxlOiBncHRSZXNwb25zZS5yZXNwb25zZU9iamVjdC50aXRsZSwgZnVsbFRpdGxlOiBncHRSZXNwb25zZS5yZXNwb25zZU9iamVjdC5mdWxsQm9va05hbWUgfSwgZ3B0UmVzcG9uc2UucmVzcG9uc2VPYmplY3QpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGNvbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGdwdFJlc3BvbnNlLmlzU3VjY2Vzc2Z1bCAmJiAhZ3B0UmVzcG9uc2UucmVzcG9uc2VPYmplY3QuZXJyb3JEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwic3VjY2Vzc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJmYWlsdXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlOiBncHRSZXNwb25zZS5lcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzOiBncHRSZXNwb25zZS5lcnJvckRldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBncHRSZXNwb25zZS5yZXNwb25zZU9iamVjdC5lcnJvckRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy52YWxpZGF0ZUJvb2sgPSB2YWxpZGF0ZUJvb2s7XG52YXIgdmFsaWRhdGVCb29rVXNpbmdHb29nbGVCb29rQXBpID0gZnVuY3Rpb24gKHNwYWNlXzEsIF9hLCB1c2VySWRfMSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgW3NwYWNlXzEsIF9hLCB1c2VySWRfMV0sIHZvaWQgMCwgZnVuY3Rpb24gKHNwYWNlLCBfYiwgdXNlcklkKSB7XG4gICAgdmFyIGdwdFJlc3BvbnNlVGV4dCwgcmVzcG9uc2U7XG4gICAgdmFyIGJvb2sgPSBfYi5ib29rO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEdwdHV0aWxzLnByZWRpY3QoKDAsIHByb21wdF8xLmdldEJvb2tEZXRhaWxQcm9tcHQpKGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvcikpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZVRleHQgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBHb29nbGVCb29rSGVscGVyLmdldE1vc3RSZWxldmFudEJvb2tNZXRhZGF0YShib29rLnRpdGxlLCBib29rLnByaW1hcnlBdXRob3IpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRjb21lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJmYWlsdXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gYm9vayBjb3VsZCBiZSBmb3VuZCB3aXRoIHRoZSBkZXRhaWxzIHNwZWNpZmllZC4gUGxlYXNlIHByb3ZpZGUgbW9yZSBhY2N1cmF0ZSBkZXRhaWxzIHRvIGRvIHRoZSBzZWFyY2guXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGNvbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2s6IF9fYXNzaWduKHt9LCByZXNwb25zZSksXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudmFsaWRhdGVCb29rVXNpbmdHb29nbGVCb29rQXBpID0gdmFsaWRhdGVCb29rVXNpbmdHb29nbGVCb29rQXBpO1xudmFyIGNyZWF0ZUJvb2sgPSBmdW5jdGlvbiAoc3BhY2VfMSwgX2EsIHVzZXJJZF8xKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbc3BhY2VfMSwgX2EsIHVzZXJJZF8xXSwgdm9pZCAwLCBmdW5jdGlvbiAoc3BhY2UsIF9iLCB1c2VySWQpIHtcbiAgICB2YXIgYm9va01ldGFkYXRhLCBtb2RlbCwgcmVzcG9uc2UsIF9jLCBfZCwgX2U7XG4gICAgdmFyIF9mO1xuICAgIHZhciBib29rID0gX2IuYm9vaywgbWV0YSA9IF9iLm1ldGE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZykge1xuICAgICAgICBzd2l0Y2ggKF9nLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCFib29rLmlzTWFuYWdlZCkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEdvb2dsZUJvb2tIZWxwZXIuZ2V0Qm9va01ldGFkYXRhQnlCb29rTmFtZUFuZEF1dGhvcihib29rLnRpdGxlLCBib29rLnByaW1hcnlBdXRob3IpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rTWV0YWRhdGEgPSBfZy5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGJvb2tNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBib29rLnRodW1ibmFpbCA9IGJvb2tNZXRhZGF0YS50aHVtYm5haWw7XG4gICAgICAgICAgICAgICAgICAgIGJvb2sucHVibGlzaGVyID0gYm9va01ldGFkYXRhLnB1Ymxpc2hlcjtcbiAgICAgICAgICAgICAgICAgICAgYm9vay5wdWJsaXNoZWREYXRlID0gYm9va01ldGFkYXRhLnB1Ymxpc2hlZERhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9nLmxhYmVsID0gMjtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIF9kID0gKF9jID0gbW9kZWwpLmNyZWF0ZTtcbiAgICAgICAgICAgICAgICBfZSA9IFtfX2Fzc2lnbih7fSwgYm9vayldO1xuICAgICAgICAgICAgICAgIF9mID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgc2VydmljZV8xLm5leHR2YWwpKFwiYm9va0lkXCIsIHVuZGVmaW5lZCwgc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFs0LCBfZC5hcHBseShfYywgW19fYXNzaWduLmFwcGx5KHZvaWQgMCwgX2UuY29uY2F0KFsoX2YucmVmZXJlbmNlID0gX2cuc2VudCgpLCBfZildKSldKV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfZy5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVCb29rID0gY3JlYXRlQm9vaztcbnZhciB1cGRhdGVCb29rID0gZnVuY3Rpb24gKHNwYWNlLCBib29rSWQsIGRhdGEsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShib29rSWQsIGRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwc2VydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzcG9uc2VdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlQm9vayA9IHVwZGF0ZUJvb2s7XG52YXIgdXBkYXRlQ2hhcHRlckNvdW50ID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBjaGFwdGVyQ291bnQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRPbmVBbmRVcGRhdGUoeyByZWZlcmVuY2U6IGJvb2tyZWYgfSwgeyBjaGFwdGVyQ291bnQ6IGNoYXB0ZXJDb3VudCB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cHNlcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlQ2hhcHRlckNvdW50ID0gdXBkYXRlQ2hhcHRlckNvdW50O1xudmFyIGdldENvdmVySW1hZ2VzID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vaztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCAoMCwgZXhwb3J0cy5nZXRCb29rQnlSZWZlcmVuY2UpKHNwYWNlLCByZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgR29vZ2xlQm9va0hlbHBlci5nZXRBbGxCb29rc0J5Qm9va05hbWVBbmRBdXRob3IoYm9vay50aXRsZSwgYm9vay5wcmltYXJ5QXV0aG9yKV07XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldENvdmVySW1hZ2VzID0gZ2V0Q292ZXJJbWFnZXM7XG52YXIgZ2V0Qm9vayA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc107XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rID0gZ2V0Qm9vaztcbnZhciBnZXRMaWJyYXJpZXMgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldExpYnJhcmllcyA9IGdldExpYnJhcmllcztcbnZhciBnZXRCb29rQnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAoc3BhY2UsIHJlZmVyZW5jZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgcmVmZXJlbmNlOiByZWZlcmVuY2UgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc1swXV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rQnlSZWZlcmVuY2UgPSBnZXRCb29rQnlSZWZlcmVuY2U7XG52YXIgZ2V0Qm9va0J5SWQgPSBmdW5jdGlvbiAoc3BhY2UsIF9pZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0NvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va0J5SWQgPSBnZXRCb29rQnlJZDtcbnZhciBkZWxldGVCb29rc0J5Rm9sZGVySWRMaXN0ID0gZnVuY3Rpb24gKHNwYWNlLCBmb2xkZXJJZExpc3QpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyBmb2xkZXJJZDogeyAkaW46IGZvbGRlcklkTGlzdCB9IH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQm9va3NCeUZvbGRlcklkTGlzdCA9IGRlbGV0ZUJvb2tzQnlGb2xkZXJJZExpc3Q7XG52YXIgZ2V0TGlicmFyaWVzQnlGb2xkZXJJZExpc3QgPSBmdW5jdGlvbiAoc3BhY2UsIGZvbGRlcklkTGlzdCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGZvbGRlcklkOiB7ICRpbjogZm9sZGVySWRMaXN0IH0gfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRMaWJyYXJpZXNCeUZvbGRlcklkTGlzdCA9IGdldExpYnJhcmllc0J5Rm9sZGVySWRMaXN0O1xudmFyIGdldExpYnJhcmllc0J5UmVmZXJlbmNlTGlzdCA9IGZ1bmN0aW9uIChzcGFjZSwgcmVmTGlzdCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IHJlZmVyZW5jZTogeyAkaW46IHJlZkxpc3QgfSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldExpYnJhcmllc0J5UmVmZXJlbmNlTGlzdCA9IGdldExpYnJhcmllc0J5UmVmZXJlbmNlTGlzdDtcbnZhciBkZWxldGVCb29rID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyBfaWQ6IF9pZCB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBib29rOiBfaWQgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rID0gZGVsZXRlQm9vaztcbnZhciBkZWxldGVCb29rQnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAoc3BhY2UsIHJlZmVyZW5jZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IHJlZmVyZW5jZTogcmVmZXJlbmNlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGJvb2s6IHJlZmVyZW5jZSB9XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUJvb2tCeVJlZmVyZW5jZSA9IGRlbGV0ZUJvb2tCeVJlZmVyZW5jZTtcbnZhciBzZWFyY2hCb29rQnlUZXh0ID0gZnVuY3Rpb24gKHNwYWNlLCB0ZXh0KSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRleHQ6IHsgJHNlYXJjaDogXCJcXFwiXCIuY29uY2F0KHRleHQsIFwiXFxcIlwiKSwgJGNhc2VTZW5zaXRpdmU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuc2VhcmNoQm9va0J5VGV4dCA9IHNlYXJjaEJvb2tCeVRleHQ7XG52YXIgc2VhcmNoQm9vayA9IGZ1bmN0aW9uIChzcGFjZSwgdGV4dCwgdGV4dExpc3QsIHNlYXJjaFByZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90ZXh0LCBtb2RlbCwgY29uZGl0aW9uLCByZXM7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF90ZXh0ID0gKF9hID0gdGV4dCA9PT0gbnVsbCB8fCB0ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0LnRvTG93ZXJDYXNlKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8gKy9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX2dldFNlYXJjaENvbmRpdGlvbihzcGFjZSwgX3RleHQsIHRleHRMaXN0LCBzZWFyY2hQcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7ICRvcjogY29uZGl0aW9uIH0pLnNvcnQoeyBjcmVhdGVkQXQ6IC0xIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0uX2RvYyksIHsgc3VtbWFyeTogKDAsIFV0aWxzXzEuaXNFbXB0eU9yU3BhY2VzKShpdGVtLnN1bW1hcnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaXRlbS5hdXRvR2VuZXJhdGVkU3VtbWFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW0uc3VtbWFyeSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuc2VhcmNoQm9vayA9IHNlYXJjaEJvb2s7XG52YXIgX2dldFNlYXJjaENvbmRpdGlvbiA9IGZ1bmN0aW9uIChzcGFjZSwgdGV4dCwgdGV4dExpc3QsIHNlYXJjaFByZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlYXJjaEZpZWxkcywgY29uZGl0aW9uLCBpc1ZhbGlkVGV4dDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHNlYXJjaEZpZWxkcyA9IFtdO1xuICAgICAgICBpZiAoc2VhcmNoUHJlZikge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VhcmNoUHJlZikuZm9yRWFjaChmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaFByZWZbZmllbGROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBzZWFyY2hGaWVsZHMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbmRpdGlvbiA9IFtdO1xuICAgICAgICBpc1ZhbGlkVGV4dCA9ICEoMCwgVXRpbHNfMS5pc0VtcHR5T3JTcGFjZXMpKHRleHQpO1xuICAgICAgICBpZiAoaXNWYWxpZFRleHQgJiZcbiAgICAgICAgICAgIChzZWFyY2hGaWVsZHMubGVuZ3RoID09PSAwIHx8IHNlYXJjaEZpZWxkcy5pbmNsdWRlcyhcImNvbnRlbnRcIikpKSB7XG4gICAgICAgICAgICBjb25kaXRpb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogbmV3IFJlZ0V4cCh0ZXh0LCBcImlcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZFRleHQgJiYgc2VhcmNoRmllbGRzLmluY2x1ZGVzKFwibmFtZVwiKSkge1xuICAgICAgICAgICAgY29uZGl0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IG5ldyBSZWdFeHAodGV4dCwgXCJpXCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVmFsaWRUZXh0ICYmIHNlYXJjaEZpZWxkcy5pbmNsdWRlcyhcImxhYmVsc1wiKSkge1xuICAgICAgICAgICAgY29uZGl0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgICAgICAkaW46IHRleHQuc3BsaXQoXCIgXCIpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VhcmNoRmllbGRzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgc2VhcmNoRmllbGRzLmluY2x1ZGVzKFwibGFiZWxzXCIpICYmXG4gICAgICAgICAgICB0ZXh0TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25kaXRpb24ucHVzaCh7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICRpbjogdGV4dExpc3QsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25kaXRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gWzIsIFt7fV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbMiwgY29uZGl0aW9uXTtcbiAgICB9KTtcbn0pOyB9O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldExvZyA9IGV4cG9ydHMuZmluaXNoR2VuZXJhdGluZyA9IGV4cG9ydHMuc3RhcnRHZW5lcmF0aW5nID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbnZhciBnZXRDb2xsZWN0aW9uID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9kYnV0aWxzXCIpLmdldENvbGxlY3Rpb247XG52YXIgc3RhcnRHZW5lcmF0aW5nID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBzZWN0aW9ucmVmLCBzZWN0aW9udHlwZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tMb2dDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tMb2dTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IGJvb2tyZWY6IGJvb2tyZWYsIHNlY3Rpb25yZWY6IHNlY3Rpb25yZWYsIHNlY3Rpb250eXBlOiBzZWN0aW9udHlwZSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwudXBkYXRlT25lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2tyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9ucmVmOiBzZWN0aW9ucmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnR5cGU6IHNlY3Rpb250eXBlLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSdW5uaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSwgeyB1cHNlcnQ6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5zdGFydEdlbmVyYXRpbmcgPSBzdGFydEdlbmVyYXRpbmc7XG52YXIgZmluaXNoR2VuZXJhdGluZyA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgc2VjdGlvbnJlZiwgc2VjdGlvbnR5cGUpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rTG9nQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rTG9nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyBib29rcmVmOiBib29rcmVmLCBzZWN0aW9ucmVmOiBzZWN0aW9ucmVmLCBzZWN0aW9udHlwZTogc2VjdGlvbnR5cGUgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5maW5pc2hHZW5lcmF0aW5nID0gZmluaXNoR2VuZXJhdGluZztcbnZhciBnZXRMb2cgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIHNlY3Rpb25yZWYsIHNlY3Rpb250eXBlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va0xvZ0NvbGxlY3Rpb24sIG1vZGVsXzEuYm9va0xvZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCByZW1vdmVTdGFsZUxvZ3Moc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCEhc2VjdGlvbnJlZikgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyBib29rcmVmOiBib29rcmVmLCBzZWN0aW9ucmVmOiBudWxsIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGlmICghIXNlY3Rpb250eXBlKSByZXR1cm4gWzMsIDVdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYsIHNlY3Rpb25yZWY6IHNlY3Rpb25yZWYgfSldO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYsIHNlY3Rpb25yZWY6IHNlY3Rpb25yZWYsIHNlY3Rpb250eXBlOiBzZWN0aW9udHlwZSB9KV07XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldExvZyA9IGdldExvZztcbnZhciByZW1vdmVTdGFsZUxvZ3MgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rTG9nQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rTG9nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiB7ICRsdDogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDIgKiA2MCAqIDEwMDApIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29rTG9nQ29sbGVjdGlvbiA9IGV4cG9ydHMuYm9va0xvZ1NjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgYm9va0xvZ1NjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICAgIHNlY3Rpb250eXBlOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHNlY3Rpb25yZWY6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgYm9va3JlZjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBpc1J1bm5pbmc6IHsgdHlwZTogQm9vbGVhbiB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlLCBzdHJpY3Q6IGZhbHNlLCBzdHJpY3RRdWVyeTogZmFsc2UgfSk7XG5leHBvcnRzLmJvb2tMb2dTY2hlbWEgPSBib29rTG9nU2NoZW1hO1xudmFyIGJvb2tMb2dDb2xsZWN0aW9uID0gXCJib29rLmxvZ1wiO1xuZXhwb3J0cy5ib29rTG9nQ29sbGVjdGlvbiA9IGJvb2tMb2dDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLmdldChcIi9ib29rL2xvZy86c3BhY2UvOmJvb2tyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0TG9nKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL2xvZy86c3BhY2UvOmJvb2tyZWYvOnNlY3Rpb25yZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0TG9nKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL2xvZy86c3BhY2UvOmJvb2tyZWYvOnNlY3Rpb25yZWYvOnNlY3Rpb250eXBlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldExvZykpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldExvZyA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBnZXRMb2cgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRMb2cocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmLCByZXEucGFyYW1zLnNlY3Rpb25yZWYsIHJlcS5wYXJhbXMuc2VjdGlvbnR5cGUpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0TG9nID0gZ2V0TG9nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJvb2tDb2xsZWN0aW9uID0gZXhwb3J0cy5ib29rU2NoZW1hID0gdm9pZCAwO1xudmFyIG1vbmdvb3NlID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpO1xudmFyIFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbnZhciBib29rU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgdGl0bGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgZnVsbFRpdGxlOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHJlZmVyZW5jZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBkZXNjcmlwdGlvbjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBzaG9ydERlc2NyaXB0aW9uOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIG92ZXJ2aWV3OiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGF1dGhvcnM6IHsgdHlwZTogQXJyYXkgfSxcbiAgICBwcmltYXJ5QXV0aG9yOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGF1dGhvckluZm86IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY2F0ZWdvcmllczogeyB0eXBlOiBBcnJheSB9LFxuICAgIGlzTWFuYWdlZDogeyB0eXBlOiBCb29sZWFuIH0sXG4gICAgaXNibjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBwYWdlQ291bnQ6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgY2hhcHRlckNvdW50OiB7IHR5cGU6IE51bWJlciB9LFxuICAgIHB1Ymxpc2hlZERhdGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgcHVibGlzaGVyOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHRodW1ibmFpbDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICByZWFkaW5nUHJvZ3Jlc3M6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgc3RhcnRlZFJlYWRpbmdPbjogeyB0eXBlOiBEYXRlIH1cbn0sIHsgdGltZXN0YW1wczogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgc3RyaWN0UXVlcnk6IGZhbHNlIH0pO1xuZXhwb3J0cy5ib29rU2NoZW1hID0gYm9va1NjaGVtYTtcbnZhciBib29rQ29sbGVjdGlvbiA9IFwiYm9va1wiO1xuZXhwb3J0cy5ib29rQ29sbGVjdGlvbiA9IGJvb2tDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Qm9va0RldGFpbFByb21wdCA9IHZvaWQgMDtcbnZhciBIYW5kbGViYXJzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJoYW5kbGViYXJzXCIpKTtcbnZhciBsb2Rhc2hfMSA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG52YXIgX01PREVMX05BTUVfR1BUMyA9IFwiZ3B0LTMuNS10dXJib1wiO1xudmFyIF9NT0RFTF9OQU1FX0dQVDQgPSBcImdwdC00b1wiO1xudmFyIF9NT0RFTF9OQU1FID0gcHJvY2Vzcy5lbnYuQ0hBVEdQVF9NT0RFTF9OQU1FIHx8IFwiZ3B0LTRvLW1pbmlcIjtcbnZhciBnZXRCb29rRGV0YWlsUHJvbXB0ID0gZnVuY3Rpb24gKGJvb2tOYW1lLCBhdXRob3JOYW1lKSB7XG4gICAgdmFyIHByb21wdCA9ICgwLCBsb2Rhc2hfMS5jbG9uZURlZXApKF9CT09LX0RFVEFJTF9QUk9NUFQpO1xuICAgIHByb21wdC5tZXNzYWdlc1twcm9tcHQubWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudCA9IEhhbmRsZWJhcnMuY29tcGlsZShwcm9tcHQubWVzc2FnZXNbcHJvbXB0Lm1lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQpKHtcbiAgICAgICAgYm9va05hbWU6IGJvb2tOYW1lLFxuICAgICAgICBhdXRob3JOYW1lOiBhdXRob3JOYW1lLFxuICAgICAgICBtb2RlbE5hbWU6IF9NT0RFTF9OQU1FLFxuICAgIH0pO1xuICAgIHJldHVybiBwcm9tcHQ7XG59O1xuZXhwb3J0cy5nZXRCb29rRGV0YWlsUHJvbXB0ID0gZ2V0Qm9va0RldGFpbFByb21wdDtcbnZhciBfQk9PS19ERVRBSUxfUFJPTVBUID0ge1xuICAgIG1vZGVsOiBfTU9ERUxfTkFNRSxcbiAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgICAgY29udGVudDogXCJZb3UgYXJlIGEgaGlnaGx5IGludGVsbGlnZW50IGFzc2lzdGFudCB0aGF0IHByb2Nlc3NlcyBib29rIGRldGFpbHMuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIldoZW4gZ2l2ZW4gYSBib29rIG5hbWUgYW5kIGF1dGhvciBuYW1lLCB2ZXJpZnkgdGhlIGJvb2sncyBleGlzdGVuY2UuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIklmIHRoZSBib29rIGlzIHZhbGlkLCByZXR1cm4gb25seSBhIEpTT04gb2JqZWN0IHdpdGggJ2NhdGVnb3JpZXMnIChhcyBhbiBhcnJheSksICdkZXNjcmlwdGlvbicgKGEgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgMiB0byA1IHBhcmFncmFwaHMpLCAnc2hvcnREZXNjcmlwdGlvbicgKGEgc2luZ2xlIHBhcmFncmFwaCBzdW1tYXJ5KSwgJ2Z1bGxCb29rTmFtZScsICd0aXRsZScsICdwYWdlQ291bnQnLCAnYXV0aG9ycycgKGFzIGFuIGFycmF5KSwgJ3ByaW1hcnlBdXRob3InLCAncHVibGlzaGVkRGF0ZScsICdpc2JuJywgJ2F1dGhvckluZm8nIChhIHBhcmFncmFwaCBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYXV0aG9yJ3MgbWFqb3Igd29ya3MgYW5kIGFjaGlldmVtZW50cyksIGFuZCAnY2hhcHRlckNvdW50JyAodGhlIHRvdGFsIG51bWJlciBvZiBjaGFwdGVycyBpbiB0aGUgYm9vaykuIElmIHRoZSBib29rIGlzIHBhcnQgb2YgYSBtdWx0aS12b2x1bWUgc2VyaWVzLCBjb21iaW5lIHRoZSBudW1iZXIgb2YgY2hhcHRlcnMgZnJvbSBhbGwgdm9sdW1lcyBpbiAnY2hhcHRlckNvdW50Jy4gVGhlICdhdXRob3JzJyBmaWVsZCBzaG91bGQgYmUgYW4gYXJyYXkgb3JkZXJlZCBieSB0aGUgcG9wdWxhcml0eSBvZiB0aGUgYXV0aG9ycy4gSWYgdGhlIGJvb2sgY2Fubm90IGJlIGZvdW5kLCByZXR1cm4gb25seSBhIEpTT04gb2JqZWN0IHdpdGggJ2Vycm9yRGVzY3JpcHRpb24nLiBUaGUgcmVzcG9uc2UgbXVzdCBiZSBpbiBKU09OIGZvcm1hdCBvbmx5LCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIHRleHQuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogXCJQbGVhc2UgZmluZCB0aGUgZGV0YWlscyBmb3IgdGhlIGJvb2sgJ3t7Ym9va05hbWV9fScgYXV0aG9yZWQgYnkgJ3t7YXV0aG9yTmFtZX19Jy5cIixcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtdWx0ZXIgPSByZXF1aXJlKFwibXVsdGVyXCIpO1xudmFyIHN0b3JhZ2UgPSBtdWx0ZXIubWVtb3J5U3RvcmFnZSgpO1xudmFyIHVwbG9hZCA9IG11bHRlcih7IHN0b3JhZ2U6IHN0b3JhZ2UgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLnB1dChcIi9ib29rLzpzcGFjZS86aWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEudXBkYXRlQm9vaykpO1xuICAgIHJvdXRlci5wb3N0KFwiL2Jvb2svOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmNyZWF0ZUJvb2spKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rLzpzcGFjZS92YWxpZGF0ZS1ib29rXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLnZhbGlkYXRlQm9vaykpO1xuICAgIHJvdXRlci5wb3N0KFwiL2Jvb2svOnNwYWNlL3NlYXJjaFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5zZWFyY2hCb29rKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rLzpzcGFjZS9yZWZlcmVuY2UvOnJlZmVyZW5jZS9jb3Zlci1pbWFnZXNcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Q292ZXJJbWFnZXMpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2Jvb2svOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldExpYnJhcmllcykpO1xuICAgIHJvdXRlci5nZXQoXCIvYm9vay86c3BhY2UvaWQvOmlkXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldEJvb2tCeUlkKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rLzpzcGFjZS9yZWZlcmVuY2UvOnJlZmVyZW5jZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRCb29rQnlSZWZlcmVuY2UpKTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL2Jvb2svOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVCb29rKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ib29rLzpzcGFjZS9yZWZlcmVuY2UvOnJlZmVyZW5jZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVCb29rQnlSZWZlcmVuY2UpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkU2VjdGlvbnMgPSBleHBvcnRzLmRlbGV0ZUJvb2tTZWN0aW9uQnlSZWZlcmVuY2UgPSBleHBvcnRzLmRlbGV0ZUJvb2tTZWN0aW9uID0gZXhwb3J0cy5nZXRCb29rU2VjdGlvbkJ5SWQgPSBleHBvcnRzLmdldEJvb2tTZWN0aW9uQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy5nZXRCb29rU2VjdGlvbnNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tTZWN0aW9uID0gZXhwb3J0cy51cGRhdGVCb29rU2VjdGlvbiA9IGV4cG9ydHMuY3JlYXRlQm9va1NlY3Rpb24gPSBleHBvcnRzLmdlbmVyYXRlU2VjdGlvbnMgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgQm9va0hlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vaGVscGVyXCIpKTtcbnZhciBFeHRyYWN0SGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9leHRyYWN0L2hlbHBlclwiKSk7XG52YXIgTm90ZUhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vbm90ZS9oZWxwZXJcIikpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZXF1ZW5jZS9zZXJ2aWNlXCIpO1xudmFyIEdwdHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZ3B0dXRpbHNcIikpO1xudmFyIHByb21wdF8xID0gcmVxdWlyZShcIi4vcHJvbXB0XCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBBSV9BUEkgPSBwcm9jZXNzLmVudi5BSV9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDMvYXBpXCI7XG52YXIgU0lNSUxBUklUWV9BTEdPUklUSE0gPSBcInNpbWlsYXJpdHlcIjtcbnZhciBTRVFVRU5DRV9JRCA9IFwiYm9va1NlY3Rpb25SZWZlcmVuY2VcIjtcbnZhciBnZW5lcmF0ZVNlY3Rpb25zID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBib29rLCBjaGFwdGVyc0xpc3QsIGNoYXB0ZXJzLCBzZWN0aW9ucywgbW9kZWwsIF9wYXlsb2FkLCBpLCBfYSwgX2I7XG4gICAgdmFyIF9jLCBfZCwgX2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgQm9va0hlbHBlci5nZXRCb29rQnlSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghYm9vayB8fCAhYm9vay5pc01hbmFnZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBfZ2V0Q2hhcHRlcnNMaXN0KHNwYWNlLCBib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2hhcHRlcnNMaXN0ID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIGNoYXB0ZXJzID0gY2hhcHRlcnNMaXN0XG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNoYXB0ZXIpIHsgcmV0dXJuIFwiXCIuY29uY2F0KGNoYXB0ZXIudGl0bGUsIFwiOiBcIikuY29uY2F0KGNoYXB0ZXIuc3VidGl0bGUpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9jcmVhdGVTdW1tYXJ5KHNwYWNlLCBib29rcmVmLCBjaGFwdGVycyldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHNlY3Rpb25zID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU2VjdGlvbkNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NlY3Rpb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIF9wYXlsb2FkID0gW107XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgX2YubGFiZWwgPSA0O1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghKGkgPCBzZWN0aW9ucy5sZW5ndGgpKSByZXR1cm4gWzMsIDddO1xuICAgICAgICAgICAgICAgIF9iID0gKF9hID0gX3BheWxvYWQpLnB1c2g7XG4gICAgICAgICAgICAgICAgX2MgPSB7fTtcbiAgICAgICAgICAgICAgICBfZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlY3Rpb25zW2ldLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHNlY3Rpb25zW2ldLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2VjdGlvbnNbaV0uc3VtbWFyeVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgc2VydmljZV8xLm5leHR2YWwpKFNFUVVFTkNFX0lELCBib29rcmVmLCBzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF9iLmFwcGx5KF9hLCBbKF9jLnVwZGF0ZU9uZSA9IChfZC51cGRhdGUgPSAoX2UucmVmZXJlbmNlID0gX2Yuc2VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2QudXBzZXJ0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKV0pO1xuICAgICAgICAgICAgICAgIF9mLmxhYmVsID0gNjtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgYm9va3JlZjogYm9va3JlZiB9KV07XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuYnVsa1dyaXRlKF9wYXlsb2FkKV07XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgQm9va0hlbHBlci51cGRhdGVDaGFwdGVyQ291bnQoc3BhY2UsIGJvb2tyZWYsIF9wYXlsb2FkLmxlbmd0aCldO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBzZWN0aW9uc107XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZW5lcmF0ZVNlY3Rpb25zID0gZ2VuZXJhdGVTZWN0aW9ucztcbnZhciBfY3JlYXRlU3VtbWFyeSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgY2hhcHRlcnMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvb2ssIG5vdGVzLCBub3Rlc0xpc3QsIGV4dHJhY3RzLCBncHRSZXNwb25zZVRleHQsIGdwdFJlc3BvbnNlLCBfZGF0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBCb29rSGVscGVyLmdldEJvb2tCeVJlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBOb3RlSGVscGVyLmdldE5vdGVCeUJvb2tyZWYoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBub3RlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBub3Rlc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBub3Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBub3Rlc0xpc3QucHVzaChpdGVtLmNvbnRlbnQpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEV4dHJhY3RIZWxwZXIuZ2V0RXh0cmFjdENodW5rc0J5Qm9va1JlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGV4dHJhY3RzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGV4dHJhY3RzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIG5vdGVzTGlzdC5wdXNoKGl0ZW0uc3VtbWFyeSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgR3B0dXRpbHMucHJlZGljdCgoMCwgcHJvbXB0XzEuZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQpKGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvciwgY2hhcHRlcnMsIG5vdGVzTGlzdCkpXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZVRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZSA9IEpTT04ucGFyc2UoZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBfZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcFRleHQgPSBcIlwiLmNvbmNhdChzZWN0aW9uLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzZWN0aW9uLnN1YnNlY3Rpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFRleHQgKz0gXCI8Yj5cIi5jb25jYXQoc3Vic2VjdGlvbi50aXRsZSwgXCI8L2I+XCIpLmNvbmNhdChzdWJzZWN0aW9uLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX2RhdGEucHVzaCh7IHRpdGxlOiBzZWN0aW9uLnRpdGxlLCBzdW1tYXJ5OiB0ZW1wVGV4dCB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIF9kYXRhXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgX2dldENoYXB0ZXJzTGlzdCA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vaywgbm90ZXMsIG5vdGVzTGlzdCwgZXh0cmFjdHMsIGdwdFJlc3BvbnNlVGV4dCwgZ3B0UmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgQm9va0hlbHBlci5nZXRCb29rQnlSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTm90ZUhlbHBlci5nZXROb3RlQnlCb29rcmVmKHNwYWNlLCBib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbm90ZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgbm90ZXNMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgbm90ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gbm90ZXNMaXN0LnB1c2goaXRlbS5jb250ZW50KTsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBFeHRyYWN0SGVscGVyLmdldEV4dHJhY3RDaHVua3NCeUJvb2tSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBleHRyYWN0cyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBleHRyYWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBub3Rlc0xpc3QucHVzaChpdGVtLnN1bW1hcnkpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEdwdHV0aWxzLnByZWRpY3QoKDAsIHByb21wdF8xLmdldENoYXB0ZXJzTGlzdFByb21wdCkoYm9vay50aXRsZSwgYm9vay5wcmltYXJ5QXV0aG9yLCBib29rLmNoYXB0ZXJDb3VudCwgbm90ZXNMaXN0KSldO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlVGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZSA9IEpTT04ucGFyc2UoZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGdwdFJlc3BvbnNlXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgX3Byb2Nlc3NBaVJlc3BvbnNlID0gZnVuY3Rpb24gKHR5cGUsIHRleHQpIHtcbiAgICB2YXIgaHRtbFN0cmluZyA9IFwiXCI7XG4gICAgdmFyIGRhdGEgPSB0ZXh0O1xuICAgIGNvbnNvbGUubG9nKFwiKioqKlwiLCBkYXRhKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN1bW1hcnlcIjpcbiAgICAgICAgY2FzZSBcInByZXN1bW1hcnlcIjpcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJwcmVzdW1tYXJ5XCI6XG4gICAgICAgICAgICB2YXIgX2RhdGFfMSA9IFtdO1xuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wVGV4dCA9IFwiXCIuY29uY2F0KHNlY3Rpb24uY29udGVudCk7XG4gICAgICAgICAgICAgICAgKF9hID0gc2VjdGlvbi5zdWJzZWN0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKHN1YnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFRleHQgKz0gXCI8Yj5cIi5jb25jYXQoc3Vic2VjdGlvbi50aXRsZSwgXCI8L2I+XCIpLmNvbmNhdChzdWJzZWN0aW9uLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9kYXRhXzEucHVzaCh7IHRpdGxlOiBzZWN0aW9uLnRpdGxlLCBzdW1tYXJ5OiB0ZW1wVGV4dCB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaHRtbFN0cmluZyA9IF9kYXRhXzE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN1bW1hcnlcIjpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiLS1cIiwgZGF0YSk7XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBodG1sU3RyaW5nICs9IFwiPGg0PlwiLmNvbmNhdChzZWN0aW9uLnRpdGxlLCBcIjwvaDQ+XCIpO1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gc2VjdGlvbi5jb250ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGh0bWxTdHJpbmcgPSBkYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBodG1sU3RyaW5nO1xufTtcbnZhciBjcmVhdGVCb29rU2VjdGlvbiA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgZGF0YSwgdXNlcklkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzcG9uc2UsIF9hLCBfYiwgX2M7XG4gICAgdmFyIF9kO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU2VjdGlvbkNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NlY3Rpb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfYiA9IChfYSA9IG1vZGVsKS5jcmVhdGU7XG4gICAgICAgICAgICAgICAgX2MgPSBbX19hc3NpZ24oe30sIGRhdGEpXTtcbiAgICAgICAgICAgICAgICBfZCA9IHsgYm9va3JlZjogYm9va3JlZiB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIHNlcnZpY2VfMS5uZXh0dmFsKShTRVFVRU5DRV9JRCwgYm9va3JlZiwgc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFs0LCBfYi5hcHBseShfYSwgW19fYXNzaWduLmFwcGx5KHZvaWQgMCwgX2MuY29uY2F0KFsoX2QucmVmZXJlbmNlID0gX2Uuc2VudCgpLCBfZCldKSldKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVCb29rU2VjdGlvbiA9IGNyZWF0ZUJvb2tTZWN0aW9uO1xudmFyIHVwZGF0ZUJvb2tTZWN0aW9uID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBzZWN0aW9ucmVmLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZSwgX2EsIHRpdGxlLCBkZXNjcmlwdGlvbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1NlY3Rpb25Db2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTZWN0aW9uU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgX2EgPSBfX2Fzc2lnbih7fSwgZGF0YSksIHRpdGxlID0gX2EudGl0bGUsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kT25lQW5kVXBkYXRlKHsgYm9va3JlZjogYm9va3JlZiwgcmVmZXJlbmNlOiBzZWN0aW9ucmVmIH0sIHsgdGl0bGU6IHRpdGxlLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBzZXJ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVCb29rU2VjdGlvbiA9IHVwZGF0ZUJvb2tTZWN0aW9uO1xudmFyIF9haV9wb3B1bGF0ZV9mb3Jfc2VjdGlvbiA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgcmVmZXJlbmNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnJfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhib29rcmVmLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYXhpb3MuZ2V0KFwiXCIuY29uY2F0KEFJX0FQSSwgXCIvXCIpLmNvbmNhdChTSU1JTEFSSVRZX0FMR09SSVRITSwgXCIvXCIpLmNvbmNhdChzcGFjZSwgXCIvcG9wdWxhdGUtc2VjdGlvbi9cIikuY29uY2F0KGJvb2tyZWYsIFwiL1wiKS5jb25jYXQocmVmZXJlbmNlKSwge30pXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwb3B1bGF0ZWQga2V5d29yZHMgZm9yIFwiICsgYm9va3JlZiArIFwiLCBcIiArIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBlcnJfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJfMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgZ2V0Qm9va1NlY3Rpb24gPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXM7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tTZWN0aW9uQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2VjdGlvblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc107XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rU2VjdGlvbiA9IGdldEJvb2tTZWN0aW9uO1xudmFyIGdldEJvb2tTZWN0aW9uc0J5Qm9va1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tTZWN0aW9uQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2VjdGlvblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgYm9va3JlZjogYm9va3JlZiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tTZWN0aW9uc0J5Qm9va1JlZmVyZW5jZSA9IGdldEJvb2tTZWN0aW9uc0J5Qm9va1JlZmVyZW5jZTtcbnZhciBnZXRCb29rU2VjdGlvbkJ5Qm9va1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgc2VjdGlvbnJlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU2VjdGlvbkNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NlY3Rpb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYsIHJlZmVyZW5jZTogc2VjdGlvbnJlZiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZVswXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rU2VjdGlvbkJ5Qm9va1JlZmVyZW5jZSA9IGdldEJvb2tTZWN0aW9uQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldEJvb2tTZWN0aW9uQnlJZCA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU2VjdGlvbkNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NlY3Rpb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IF9pZDogX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tTZWN0aW9uQnlJZCA9IGdldEJvb2tTZWN0aW9uQnlJZDtcbnZhciBkZWxldGVCb29rU2VjdGlvbiA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1NlY3Rpb25Db2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTZWN0aW9uU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyBfaWQ6IF9pZCB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBib29rU2VjdGlvbjogX2lkIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQm9va1NlY3Rpb24gPSBkZWxldGVCb29rU2VjdGlvbjtcbnZhciBkZWxldGVCb29rU2VjdGlvbkJ5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU2VjdGlvbkNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1NlY3Rpb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IHJlZmVyZW5jZTogcmVmZXJlbmNlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGJvb2tTZWN0aW9uOiByZWZlcmVuY2UgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rU2VjdGlvbkJ5UmVmZXJlbmNlID0gZGVsZXRlQm9va1NlY3Rpb25CeVJlZmVyZW5jZTtcbnZhciBhZGRTZWN0aW9ucyA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgc2VjdGlvblRpdGxlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIF9wYXlsb2FkLCBpLCBfYSwgX2I7XG4gICAgdmFyIF9jLCBfZCwgX2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tTZWN0aW9uQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU2VjdGlvblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQgPSBbXTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IHNlY3Rpb25UaXRsZXMubGVuZ3RoKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICBfYiA9IChfYSA9IF9wYXlsb2FkKS5wdXNoO1xuICAgICAgICAgICAgICAgIF9jID0ge307XG4gICAgICAgICAgICAgICAgX2QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHNlY3Rpb25UaXRsZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF9lID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZWN0aW9uVGl0bGVzW2ldXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBzZXJ2aWNlXzEubmV4dHZhbCkoXCJzZWN0aW9uSWRcIiwgYm9va3JlZiwgc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfYi5hcHBseShfYSwgWyhfYy51cGRhdGVPbmUgPSAoX2QudXBkYXRlID0gKF9lLnJlZmVyZW5jZSA9IF9mLnNlbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kLnVwc2VydCA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBfZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyldKTtcbiAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDM7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCwgbW9kZWwuYnVsa1dyaXRlKF9wYXlsb2FkKV07XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiwgX2Yuc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmFkZFNlY3Rpb25zID0gYWRkU2VjdGlvbnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYm9va1NlY3Rpb25Db2xsZWN0aW9uID0gZXhwb3J0cy5ib29rU2VjdGlvblNjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgYm9va1NlY3Rpb25TY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICB0aXRsZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBkZXNjcmlwdGlvbjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICByZWZlcmVuY2U6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgYm9va3JlZjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB0aGVtZXM6IHsgdHlwZTogQXJyYXkgfSxcbn0sIHsgdGltZXN0YW1wczogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgc3RyaWN0UXVlcnk6IGZhbHNlIH0pO1xuZXhwb3J0cy5ib29rU2VjdGlvblNjaGVtYSA9IGJvb2tTZWN0aW9uU2NoZW1hO1xudmFyIGJvb2tTZWN0aW9uQ29sbGVjdGlvbiA9IFwiYm9vay5zZWN0aW9uXCI7XG5leHBvcnRzLmJvb2tTZWN0aW9uQ29sbGVjdGlvbiA9IGJvb2tTZWN0aW9uQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDaGFwdGVyc0xpc3RQcm9tcHQgPSBleHBvcnRzLmdldFN1bW1hcnlTZWN0aW9uUHJvbXB0ID0gdm9pZCAwO1xudmFyIGdwdHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2dwdHV0aWxzXCIpO1xudmFyIF9NT0RFTF9OQU1FX0dQVDMgPSBcImdwdC0zLjUtdHVyYm9cIjtcbnZhciBfTU9ERUxfTkFNRV9HUFQ0ID0gXCJncHQtNG9cIjtcbnZhciBfTU9ERUxfTkFNRV9HUFQ0X01JTkkgPSBcImdwdC00by1taW5pXCI7XG52YXIgX01PREVMX05BTUUgPSBwcm9jZXNzLmVudi5DSEFUR1BUX01PREVMX05BTUUgfHwgXCJncHQtNG8tbWluaVwiO1xudmFyIGdldFN1bW1hcnlTZWN0aW9uUHJvbXB0ID0gZnVuY3Rpb24gKGJvb2tOYW1lLCBhdXRob3JOYW1lLCBjaGFwdGVycywgbm90ZUxpc3QpIHtcbiAgICB2YXIgbm90ZXMgPSBub3RlTGlzdC5qb2luKFwiL25cIik7XG4gICAgcmV0dXJuICgwLCBncHR1dGlsc18xLmdldFByb21wdCkoX1NVTU1BUllfUFJPTVBULCB7XG4gICAgICAgIGJvb2tOYW1lOiBib29rTmFtZSxcbiAgICAgICAgYXV0aG9yTmFtZTogYXV0aG9yTmFtZSxcbiAgICAgICAgY2hhcHRlcnM6IGNoYXB0ZXJzLFxuICAgICAgICBub3Rlczogbm90ZXMsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5nZXRTdW1tYXJ5U2VjdGlvblByb21wdCA9IGdldFN1bW1hcnlTZWN0aW9uUHJvbXB0O1xudmFyIGdldENoYXB0ZXJzTGlzdFByb21wdCA9IGZ1bmN0aW9uIChib29rTmFtZSwgYXV0aG9yTmFtZSwgY2hhcHRlckNvdW50LCBub3RlTGlzdCkge1xuICAgIHZhciBub3RlcyA9IG5vdGVMaXN0LmpvaW4oXCIvblwiKTtcbiAgICByZXR1cm4gKDAsIGdwdHV0aWxzXzEuZ2V0UHJvbXB0KShfQ0hBUFRFUlNfUFJPTVBULCB7XG4gICAgICAgIGJvb2tOYW1lOiBib29rTmFtZSxcbiAgICAgICAgYXV0aG9yTmFtZTogYXV0aG9yTmFtZSxcbiAgICAgICAgY2hhcHRlckNvdW50OiBjaGFwdGVyQ291bnQsXG4gICAgICAgIG5vdGVzOiBub3RlcyxcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldENoYXB0ZXJzTGlzdFByb21wdCA9IGdldENoYXB0ZXJzTGlzdFByb21wdDtcbnZhciBfU1VNTUFSWV9QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGFuIEFJIGFzc2lzdGFudCBhbmQgZXhwZXJ0IGJvb2sgcmVhZGVyLlwiLFxuICAgICAgICAgICAgICAgIFwiUHJvdmlkZSBjb21wcmVoZW5zaXZlIGNoYXB0ZXItYnktY2hhcHRlciBzdW1tYXJpZXMsIGVuc3VyaW5nIGFsbCBtYWpvciBwbG90IHBvaW50cywgY2hhcmFjdGVyIGRldmVsb3BtZW50cywgYW5kIHRoZW1lcyBhcmUgaW5jbHVkZWQuXCIsXG4gICAgICAgICAgICAgICAgXCJGb2xsb3cgdGhlIGNoYXB0ZXJzIGFzIGdpdmVuIGJ5IHRoZSB1c2VyLCBlbnN1cmluZyBsb2dpY2FsIGZsb3cgYW5kIG9yZ2FuaXphdGlvbiBvZiB0aGUgYm9vaydzIGNvbnRlbnQuXCIsXG4gICAgICAgICAgICAgICAgXCJFbnN1cmUgdGhlIGNvbnRlbnQgaXMgZGlzdHJpYnV0ZWQgbmF0dXJhbGx5IGFjcm9zcyB0aGUgY2hhcHRlcnMsIGZpdHRpbmcgYWxsIGtleSBldmVudHMgYW5kIGVsZW1lbnRzIG9mIHRoZSBib29rIGFwcHJvcHJpYXRlbHkuXCIsXG4gICAgICAgICAgICAgICAgXCJFYWNoIHNlY3Rpb24gc2hvdWxkIGNhcHR1cmUgdGhlIGVzc2VuY2Ugb2YgdGhlIGNoYXB0ZXIgd2l0aCBhIGRldGFpbGVkIHN1bW1hcnkgb2YgYXQgbGVhc3Qgb25lIHBhcmFncmFwaCwgY292ZXJpbmcgYWxsIGltcG9ydGFudCBhc3BlY3RzIHdpdGhvdXQgb3ZlcnNpbXBsaWZ5aW5nLlwiLFxuICAgICAgICAgICAgICAgIFwiRm9ybWF0IHVzaW5nIDxwPiwgPGk+LCBhbmQgPGI+IHRhZ3Mgb25seSB3aGVuIG5lY2Vzc2FyeS5cIixcbiAgICAgICAgICAgICAgICAnRG8gbm90IGluY2x1ZGUgYW55IGV4cGxhbmF0aW9ucywgb25seSBwcm92aWRlIGEgIFJGQzgyNTkgY29tcGxpYW50IEpTT04gcmVzcG9uc2UgZm9sbG93aW5nIHRoaXMgZm9ybWF0IHdpdGhvdXQgZGV2aWF0aW9uLiBbe1widGl0bGVcIjogXCJzZWN0aW9uIHRpdGxlXCIsIFwiY29udGVudFwiOiBcInNlY3Rpb24gc3VtbWFyeVwiLCBcInN1YnNlY3Rpb25zXCI6IFt7XCJ0aXRsZVwiOiBcInN1Yi1zZWN0aW9uIHRpdGxlXCIsIFwiY29udGVudFwiOiBcInN1Yi1zZWN0aW9uIHN1bW1hcnlcIn1dfV0uJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFwiUHJvdmlkZSBhIGRldGFpbGVkIHN1bW1hcnkgb2Yge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19LlwiLFxuICAgICAgICAgICAgICAgIFwiVXNlIHRoZSBsaXN0IG9mIGNoYXB0ZXIgdGl0bGVzIHByb3ZpZGVkIGluIHt7Y2hhcHRlcnN9fSB0byBvcmdhbml6ZSB0aGUgYm9vaydzIGNvbnRlbnQgbG9naWNhbGx5LlwiLFxuICAgICAgICAgICAgICAgIFwiRW5zdXJlIGFsbCBrZXkgZGV0YWlscyBhbmQgY29udGVudCBvZiB0aGUgYm9vayBhcmUgY292ZXJlZCB3aXRoaW4gdGhlIGNoYXB0ZXIgc3VtbWFyaWVzLCBmbG93aW5nIGNvcnJlY3RseSBmcm9tIG9uZSBjaGFwdGVyIHRvIHRoZSBuZXh0IGFzIHBlciB0aGUgYm9vaydzIHN0cnVjdHVyZS5cIixcbiAgICAgICAgICAgICAgICBcIkVhY2ggc2VjdGlvbiBtdXN0IGNvdmVyIGtleSBkZXRhaWxzIGNvbXByZWhlbnNpdmVseSB3aXRob3V0IG92ZXJzaW1wbGlmaWNhdGlvbiBhbmQgbWFpbnRhaW4gY29uY2lzZW5lc3MsIHByb3ZpZGluZyBhdCBsZWFzdCBhIHBhcmFncmFwaCBmb3IgZWFjaCBjaGFwdGVyLlwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDgxOTIsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG52YXIgX0NIQVBURVJTX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIlVzZSB0aGUgcHJvdmlkZWQgYm9vayBuYW1lIHt7Ym9va05hbWV9fS5cIixcbiAgICAgICAgICAgICAgICBcIlVzZSB0aGUgYXV0aG9yIG5hbWUge3thdXRob3JOYW1lfX0uXCIsXG4gICAgICAgICAgICAgICAgXCJVc2UgdGhlIGNoYXB0ZXIgY291bnQge3tjaGFwdGVyQ291bnR9fS5cIixcbiAgICAgICAgICAgICAgICBcIkdlbmVyYXRlIGEgbGlzdCBvZiBjaGFwdGVyIHRpdGxlcyB0aGF0IGNsb3NlbHkgZm9sbG93IHRoZSBhY3R1YWwgc3RydWN0dXJlIGFuZCBmbG93IG9mIHRoZSBib29rLCB3aGVyZXZlciBwb3NzaWJsZS5cIixcbiAgICAgICAgICAgICAgICBcIklmIHRoZSBvcmlnaW5hbCBib29rIGRvZXMgbm90IGhhdmUgZW5vdWdoIGRpc3RpbmN0IGNoYXB0ZXJzIHRvIG1lZXQgdGhlIGNoYXB0ZXJDb3VudCwgZGlzdHJpYnV0ZSBhZGRpdGlvbmFsIGNoYXB0ZXJzIGV2ZW5seSB0aHJvdWdob3V0IHRoZSBib29r4oCZcyBjb250ZW50LCB3aGlsZSBtYWludGFpbmluZyBsb2dpY2FsIGRpdmlzaW9ucy5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGUgbnVtYmVyIG9mIGNoYXB0ZXJzIGdlbmVyYXRlZCBpcyBleGFjdGx5IGVxdWFsIHRvIHRoZSBjaGFwdGVyQ291bnQgc3BlY2lmaWVkLlwiLFxuICAgICAgICAgICAgICAgIFwiSWYgY2hhcHRlcnMgYXJlIG51bWJlcmVkIHdpdGhvdXQgdGl0bGVzLCBjcmVhdGUgc3VpdGFibGUgdGl0bGVzIGJhc2VkIG9uIHRoZWlyIGNvbnRlbnQuXCIsXG4gICAgICAgICAgICAgICAgXCJEbyBub3QgaW5jbHVkZSBhbnkgY2hhcHRlciBudW1iZXIgcHJlZml4IGluIHRoZSBjaGFwdGVyIHRpdGxlcy4gRG8gbm90IHJlcGVhdCBjaGFwdGVyIHRpdGxlIGluIGNoYXB0ZXIgc3VidGl0bGUuXCIsXG4gICAgICAgICAgICAgICAgJ0RvIG5vdCBpbmNsdWRlIGFueSBleHBsYW5hdGlvbnMsIG9ubHkgcHJvdmlkZSBhICBSRkM4MjU5IGNvbXBsaWFudCBKU09OIHJlc3BvbnNlIGZvbGxvd2luZyB0aGlzIGZvcm1hdCB3aXRob3V0IGRldmlhdGlvbi4gW3tcInRpdGxlXCI6IFwiY2hhcHRlciB0aXRsZVwiLCBcInN1YnRpdGxlXCI6IFwiYSBzaG9ydCBvbmUgbGluZSB0ZXh0IHRvIGdpdmUgYSBjb250ZXh0IG9mIHdodCB0aGUgY2hhcHRlciBpcyBhYm91dFwifV0uJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFwiQm9vayBuYW1lIGlzIHt7Ym9va05hbWV9fS5cIixcbiAgICAgICAgICAgICAgICBcIkF1dGhvciBuYW1lIGlzIHt7YXV0aG9yTmFtZX19LlwiLFxuICAgICAgICAgICAgICAgIFwiTnVtYmVyIG9mIGNoYXB0ZXJzIGlzIHt7Y2hhcHRlckNvdW50fX0uXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgdGVtcGVyYXR1cmU6IDEsXG4gICAgbWF4X3Rva2VuczogNDA5NixcbiAgICB0b3BfcDogMSxcbiAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oYW5kbGVyXCIpO1xudmFyIG1pZGRsZXdhcmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWlkZGxld2FyZXNcIik7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5wdXQoXCIvYm9vay9zZWN0aW9uLzpzcGFjZS86Ym9va3JlZi86c2VjdGlvbnJlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS51cGRhdGVCb29rU2VjdGlvbikpO1xuICAgIHJvdXRlci5wb3N0KFwiL2Jvb2svc2VjdGlvbi86c3BhY2UvOmJvb2tyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuY3JlYXRlQm9va1NlY3Rpb24pKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rL3NlY3Rpb24vOnNwYWNlLzpib29rcmVmL2dlbmVyYXRlLXNlY3Rpb25zXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdlbmVyYXRlU2VjdGlvbnMpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2Jvb2svc2VjdGlvbi86c3BhY2UvaWQvOmlkXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldEJvb2tTZWN0aW9uQnlJZCkpO1xuICAgIHJvdXRlci5nZXQoXCIvYm9vay9zZWN0aW9uLzpzcGFjZS86Ym9va3JlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRCb29rU2VjdGlvbnNCeUJvb2tSZWZlcmVuY2UpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2Jvb2svc2VjdGlvbi86c3BhY2UvOmJvb2tyZWYvOnNlY3Rpb25yZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Qm9va1NlY3Rpb25CeUJvb2tSZWZlcmVuY2UpKTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL2Jvb2svc2VjdGlvbi86c3BhY2UvOmlkXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmRlbGV0ZUJvb2tTZWN0aW9uKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ib29rL3NlY3Rpb24vOnNwYWNlL3JlZmVyZW5jZS86cmVmZXJlbmNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmRlbGV0ZUJvb2tTZWN0aW9uQnlSZWZlcmVuY2UpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVCb29rU2VjdGlvbkJ5UmVmZXJlbmNlID0gZXhwb3J0cy5kZWxldGVCb29rU2VjdGlvbiA9IGV4cG9ydHMuZ2V0Qm9va1NlY3Rpb25CeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tTZWN0aW9uc0J5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0Qm9va1NlY3Rpb25CeUlkID0gZXhwb3J0cy5nZXRCb29rU2VjdGlvbiA9IGV4cG9ydHMudXBkYXRlQm9va1NlY3Rpb24gPSBleHBvcnRzLmNyZWF0ZUJvb2tTZWN0aW9uID0gZXhwb3J0cy5nZW5lcmF0ZVNlY3Rpb25zID0gdm9pZCAwO1xudmFyIGhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2xvZy9oZWxwZXJcIik7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgZ2VuZXJhdGVTZWN0aW9ucyA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgaGVscGVyXzEuc3RhcnRHZW5lcmF0aW5nKShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDIpLnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlNlY3Rpb24gZ2VuZXJhdGlvbiBzdGFydGVkLiBZb3Ugd2lsbCBiZSBub3RpZmllZCB1cG9uIGNvbXBsZXRpb24uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2VuZXJhdGVTZWN0aW9ucyhyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgaGVscGVyXzEuZmluaXNoR2VuZXJhdGluZykocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZW5lcmF0ZVNlY3Rpb25zID0gZ2VuZXJhdGVTZWN0aW9ucztcbnZhciBjcmVhdGVCb29rU2VjdGlvbiA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rU2VjdGlvbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmNyZWF0ZUJvb2tTZWN0aW9uKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZiwgcmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tTZWN0aW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVCb29rU2VjdGlvbiA9IGNyZWF0ZUJvb2tTZWN0aW9uO1xudmFyIHVwZGF0ZUJvb2tTZWN0aW9uID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tTZWN0aW9uO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIudXBkYXRlQm9va1NlY3Rpb24ocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmLCByZXEucGFyYW1zLnNlY3Rpb25yZWYsIHJlcS5ib2R5LCB1c2VySWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rU2VjdGlvbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va1NlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlQm9va1NlY3Rpb24gPSB1cGRhdGVCb29rU2VjdGlvbjtcbnZhciBnZXRCb29rU2VjdGlvbiA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rU2VjdGlvbkxpc3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRCb29rU2VjdGlvbihyZXEucGFyYW1zLnNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va1NlY3Rpb25MaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rU2VjdGlvbkxpc3QpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va1NlY3Rpb24gPSBnZXRCb29rU2VjdGlvbjtcbnZhciBnZXRCb29rU2VjdGlvbkJ5SWQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va1NlY3Rpb247XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRCb29rU2VjdGlvbkJ5SWQocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tTZWN0aW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rU2VjdGlvbkJ5SWQgPSBnZXRCb29rU2VjdGlvbkJ5SWQ7XG52YXIgZ2V0Qm9va1NlY3Rpb25zQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tTZWN0aW9uO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va1NlY3Rpb25zQnlCb29rUmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tTZWN0aW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rU2VjdGlvbnNCeUJvb2tSZWZlcmVuY2UgPSBnZXRCb29rU2VjdGlvbnNCeUJvb2tSZWZlcmVuY2U7XG52YXIgZ2V0Qm9va1NlY3Rpb25CeUJvb2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va1NlY3Rpb247XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRCb29rU2VjdGlvbkJ5Qm9va1JlZmVyZW5jZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYsIHJlcS5wYXJhbXMuc2VjdGlvbnJlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tTZWN0aW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rU2VjdGlvbkJ5Qm9va1JlZmVyZW5jZSA9IGdldEJvb2tTZWN0aW9uQnlCb29rUmVmZXJlbmNlO1xudmFyIGRlbGV0ZUJvb2tTZWN0aW9uID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWxldGVCb29rU2VjdGlvbihyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmlkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rU2VjdGlvbiA9IGRlbGV0ZUJvb2tTZWN0aW9uO1xudmFyIGRlbGV0ZUJvb2tTZWN0aW9uQnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgb3V0Y29tZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZUJvb2tTZWN0aW9uQnlSZWZlcmVuY2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5yZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUJvb2tTZWN0aW9uQnlSZWZlcmVuY2UgPSBkZWxldGVCb29rU2VjdGlvbkJ5UmVmZXJlbmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVBbGxTZWN0aW9uU3VtbWFyaWVzID0gZXhwb3J0cy5hZGRTZWN0aW9uRGV0YWlsUGxhY2Vob2xkZXIgPSBleHBvcnRzLmRlbGV0ZURldGFpbCA9IGV4cG9ydHMuZ2V0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZVNob3J0Zm9ybSA9IGV4cG9ydHMuZ2V0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMudXBkYXRlRGV0YWlsID0gZXhwb3J0cy5jcmVhdGVEZXRhaWwgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgQm9va0hlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vaGVscGVyXCIpKTtcbnZhciBFeHRyYWN0SGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9leHRyYWN0L2hlbHBlclwiKSk7XG52YXIgU2VjdGlvbkhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vc2VjdGlvbi9oZWxwZXJcIikpO1xudmFyIE5vdGVIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uL25vdGUvaGVscGVyXCIpKTtcbnZhciBHcHR1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vLi4vbGliL2dwdHV0aWxzXCIpKTtcbnZhciBwcm9tcHRfMSA9IHJlcXVpcmUoXCIuL3Byb21wdFwiKTtcbnZhciBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9sb2cvaGVscGVyXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBBSV9BUEkgPSBwcm9jZXNzLmVudi5BSV9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDMvYXBpXCI7XG52YXIgY3JlYXRlRGV0YWlsID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBzZWN0aW9ucmVmLCBwYXlsb2FkLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvb2ssIG1vZGVsLCBjb250ZXh0TGlzdCwgdGhlbWVzQ29udGV4dExpc3QsIGdwdFJlc3BvbnNlVGV4dCwgY29udGVudCwgc2VjdGlvbmRldGFpbCwgc2hvcnRlclN1bW1hcnk7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCEocGF5bG9hZC50eXBlID09PSBcInN1bW1hcnlcIikpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBfY3JlYXRlU3VtbWFyeShzcGFjZSwgYm9va3JlZiwgc2VjdGlvbnJlZildO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCwgQm9va0hlbHBlci5nZXRCb29rQnlSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBib29rID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5zZWN0aW9uRGV0YWlsQ29sbGVjdGlvbiwgbW9kZWxfMS5zZWN0aW9uRGV0YWlsU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25yZWY6IHNlY3Rpb25yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNvbnRleHRMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnJlZjogc2VjdGlvbnJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGhlbWVzX2NvbnRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHRoZW1lc0NvbnRleHRMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0TGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7fV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgR3B0dXRpbHMucHJlZGljdCgoMCwgcHJvbXB0XzEuZ2V0U2Vjb25kYXJ5U2VjdGlvblByb21wdCkocGF5bG9hZC50eXBlLCBib29rLnRpdGxlLCBib29rLnByaW1hcnlBdXRob3IsIGNvbnRleHRMaXN0WzBdLmNvbnRlbnQsIHRoZW1lc0NvbnRleHRMaXN0Lmxlbmd0aCA+IDAgPyB0aGVtZXNDb250ZXh0TGlzdFswXS5jb250ZW50IDogdW5kZWZpbmVkKSldO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlVGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gX3Byb2Nlc3NBaVJlc3BvbnNlKHBheWxvYWQudHlwZSwgZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLnVwZGF0ZU9uZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnJlZjogc2VjdGlvbnJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHBheWxvYWQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVRpdGxlOiBwYXlsb2FkLnNlY3Rpb25UaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXNjcmlwdGlvbjogcGF5bG9hZC5zZWN0aW9uRGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgdXBzZXJ0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBzZWN0aW9uZGV0YWlsID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghKHBheWxvYWQudHlwZSA9PT0gXCJ0aGVtZXNcIikpIHJldHVybiBbMywgMTBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX2dlbmVyYXRlU2hvcnRlclRoZW1lc1N1bW1hcnlGb3JDb250ZXh0KGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvciwgZ3B0UmVzcG9uc2VUZXh0KV07XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgc2hvcnRlclN1bW1hcnkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC51cGRhdGVPbmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25yZWY6IHNlY3Rpb25yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRoZW1lc19jb250ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzaG9ydGVyU3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgdXBzZXJ0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxMDtcbiAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBbMiwgc2VjdGlvbmRldGFpbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVEZXRhaWwgPSBjcmVhdGVEZXRhaWw7XG52YXIgX2NyZWF0ZVN1bW1hcnkgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIHNlY3Rpb25yZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvb2ssIG5vdGVzLCBub3Rlc0xpc3QsIGV4dHJhY3RzLCBzZWN0aW9uLCBncHRSZXNwb25zZVRleHQsIGNvbnRlbnQsIG1vZGVsLCBzZWN0aW9uZGV0YWlsLCBzaG9ydGVyU3VtbWFyeTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBCb29rSGVscGVyLmdldEJvb2tCeVJlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBOb3RlSGVscGVyLmdldE5vdGVCeUJvb2tyZWYoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBub3RlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBub3Rlc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBub3Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBub3Rlc0xpc3QucHVzaChpdGVtLmNvbnRlbnQpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEV4dHJhY3RIZWxwZXIuZ2V0RXh0cmFjdENodW5rc0J5Qm9va1JlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGV4dHJhY3RzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGV4dHJhY3RzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIG5vdGVzTGlzdC5wdXNoKGl0ZW0uc3VtbWFyeSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgU2VjdGlvbkhlbHBlci5nZXRCb29rU2VjdGlvbkJ5Qm9va1JlZmVyZW5jZShzcGFjZSwgYm9va3JlZiwgc2VjdGlvbnJlZildO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHNlY3Rpb24gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgR3B0dXRpbHMucHJlZGljdCgoMCwgcHJvbXB0XzEuZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQpKGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvciwgc2VjdGlvbi50aXRsZSwgc2VjdGlvbi5kZXNjcmlwdGlvbikpXTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZVRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IF9wcm9jZXNzQWlSZXNwb25zZShcInN1bW1hcnlcIiwgZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuc2VjdGlvbkRldGFpbENvbGxlY3Rpb24sIG1vZGVsXzEuc2VjdGlvbkRldGFpbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC51cGRhdGVPbmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25yZWY6IHNlY3Rpb25yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN1bW1hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB7IHVwc2VydDogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgc2VjdGlvbmRldGFpbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9nZW5lcmF0ZVNob3J0ZXJTdW1tYXJ5Rm9yQ29udGV4dChib29rLnRpdGxlLCBib29rLnByaW1hcnlBdXRob3IsIGdwdFJlc3BvbnNlVGV4dCldO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHNob3J0ZXJTdW1tYXJ5ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwudXBkYXRlT25lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2tyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9ucmVmOiBzZWN0aW9ucmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjb250ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzaG9ydGVyU3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgdXBzZXJ0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBzZWN0aW9uZGV0YWlsXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgX2dlbmVyYXRlU2hvcnRlclN1bW1hcnlGb3JDb250ZXh0ID0gZnVuY3Rpb24gKGJvb2tOYW1lLCBhdXRob3JOYW1lLCBjb250ZW50KSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBncHRSZXNwb25zZVRleHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgR3B0dXRpbHMucHJlZGljdCgoMCwgcHJvbXB0XzEuZ2V0U2hvcnRlbkNvbnRlbnRQcm9tcHQpKGJvb2tOYW1lLCBhdXRob3JOYW1lLCBjb250ZW50KSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlVGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGdwdFJlc3BvbnNlVGV4dF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xudmFyIF9nZW5lcmF0ZVNob3J0ZXJUaGVtZXNTdW1tYXJ5Rm9yQ29udGV4dCA9IGZ1bmN0aW9uIChib29rTmFtZSwgYXV0aG9yTmFtZSwgY29udGVudCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZ3B0UmVzcG9uc2VUZXh0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEdwdHV0aWxzLnByZWRpY3QoKDAsIHByb21wdF8xLmdldFNob3J0ZW5UaGVtZXNQcm9tcHQpKGJvb2tOYW1lLCBhdXRob3JOYW1lLCBjb250ZW50KSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlVGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGdwdFJlc3BvbnNlVGV4dF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xudmFyIF9wcm9jZXNzQWlSZXNwb25zZSA9IGZ1bmN0aW9uICh0eXBlLCB0ZXh0KSB7XG4gICAgdmFyIGh0bWxTdHJpbmcgPSBcIlwiO1xuICAgIHZhciBkYXRhID0gdGV4dDtcbiAgICBjb25zb2xlLmxvZyhcIioqKipcIiwgZGF0YSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdW1tYXJ5XCI6XG4gICAgICAgIGNhc2UgXCJ0aGVtZXNcIjpcbiAgICAgICAgY2FzZSBcImFsdGVybmF0ZV90YWtlc1wiOlxuICAgICAgICBjYXNlIFwicHVycG9zZVwiOlxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN1bW1hcnlcIjpcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gXCI8Yj5cIi5jb25jYXQoc2VjdGlvbi50aXRsZSwgXCI8L2I+XCIpO1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gc2VjdGlvbi5jb250ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRoZW1lc1wiOlxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaHRtbFN0cmluZyArPSBcIjxiPlwiLmNvbmNhdChzZWN0aW9uLnRoZW1lVGl0bGUsIFwiPC9iPlwiKTtcbiAgICAgICAgICAgICAgICBodG1sU3RyaW5nICs9IHNlY3Rpb24uY29udGVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbHRlcm5hdGVfdGFrZXNcIjpcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gXCI8Yj5cIi5jb25jYXQoc2VjdGlvbi5hdXRob3IsIFwiPC9iPiBpbiA8aT5cIikuY29uY2F0KHNlY3Rpb24uYm9vaywgXCI8L2k+XCIpO1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gc2VjdGlvbi5jb250ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInB1cnBvc2VcIjpcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gXCIoPGk+XCIuY29uY2F0KHNlY3Rpb24uc2VjdGlvbiwgXCI8L2k+KSA8Yj5cIikuY29uY2F0KHNlY3Rpb24ucHVycG9zZSwgXCI8L2I+XCIpO1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gc2VjdGlvbi5hbmFseXNpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBodG1sU3RyaW5nID0gZGF0YTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gaHRtbFN0cmluZztcbn07XG52YXIgdXBkYXRlRGV0YWlsID0gZnVuY3Rpb24gKHNwYWNlLCBpZCwgZGF0YSwgdXNlcklkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLnNlY3Rpb25EZXRhaWxDb2xsZWN0aW9uLCBtb2RlbF8xLnNlY3Rpb25EZXRhaWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKGlkLCBkYXRhLCB7fSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzcG9uc2VdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlRGV0YWlsID0gdXBkYXRlRGV0YWlsO1xudmFyIGdldERldGFpbHNCeUJvb2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIHNlY3Rpb25yZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5zZWN0aW9uRGV0YWlsQ29sbGVjdGlvbiwgbW9kZWxfMS5zZWN0aW9uRGV0YWlsU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb25yZWY6IHNlY3Rpb25yZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB7ICRuaW46IFtcImNvbnRleHRcIiwgXCJ0aGVtZXNfY29udGV4dFwiXSB9LFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldERldGFpbHNCeUJvb2tSZWZlcmVuY2UgPSBnZXREZXRhaWxzQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldERldGFpbHNCeUJvb2tSZWZlcmVuY2VTaG9ydGZvcm0gPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5zZWN0aW9uRGV0YWlsQ29sbGVjdGlvbiwgbW9kZWxfMS5zZWN0aW9uRGV0YWlsU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyBib29rcmVmOiBib29rcmVmLCB0eXBlOiBcInN1bW1hcnlcIiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldERldGFpbHNCeUJvb2tSZWZlcmVuY2VTaG9ydGZvcm0gPSBnZXREZXRhaWxzQnlCb29rUmVmZXJlbmNlU2hvcnRmb3JtO1xudmFyIGRlbGV0ZURldGFpbCA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuc2VjdGlvbkRldGFpbENvbGxlY3Rpb24sIG1vZGVsXzEuc2VjdGlvbkRldGFpbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgc2VjdGlvbmRldGFpbDogX2lkIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlRGV0YWlsID0gZGVsZXRlRGV0YWlsO1xudmFyIGFkZFNlY3Rpb25EZXRhaWxQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgc2VjdGlvbnJlZiwgc2VjdGlvbnR5cGUpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCBzZWN0aW9uZGV0YWlsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5zZWN0aW9uRGV0YWlsQ29sbGVjdGlvbiwgbW9kZWxfMS5zZWN0aW9uRGV0YWlsU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLnVwZGF0ZU9uZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnJlZjogc2VjdGlvbnJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHNlY3Rpb250eXBlLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgdXBzZXJ0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzZWN0aW9uZGV0YWlsID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5hZGRTZWN0aW9uRGV0YWlsUGxhY2Vob2xkZXIgPSBhZGRTZWN0aW9uRGV0YWlsUGxhY2Vob2xkZXI7XG52YXIgZ2VuZXJhdGVBbGxTZWN0aW9uU3VtbWFyaWVzID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWN0aW9ucywgaSwgaTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBTZWN0aW9uSGVscGVyLmdldEJvb2tTZWN0aW9uc0J5Qm9va1JlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHNlY3Rpb25zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgc2VjdGlvbnMubGVuZ3RoKSkgcmV0dXJuIFszLCA2XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBoZWxwZXJfMS5zdGFydEdlbmVyYXRpbmcpKHNwYWNlLCBib29rcmVmLCBzZWN0aW9uc1tpXS5yZWZlcmVuY2UsIFwic3VtbWFyeVwiKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIGV4cG9ydHMuYWRkU2VjdGlvbkRldGFpbFBsYWNlaG9sZGVyKShzcGFjZSwgYm9va3JlZiwgc2VjdGlvbnNbaV0ucmVmZXJlbmNlLCBcInN1bW1hcnlcIildO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA3O1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIGlmICghKGkgPCBzZWN0aW9ucy5sZW5ndGgpKSByZXR1cm4gWzMsIDExXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9jcmVhdGVTdW1tYXJ5KHNwYWNlLCBib29rcmVmLCBzZWN0aW9uc1tpXS5yZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgaGVscGVyXzEuZmluaXNoR2VuZXJhdGluZykoc3BhY2UsIGJvb2tyZWYsIHNlY3Rpb25zW2ldLnJlZmVyZW5jZSwgXCJzdW1tYXJ5XCIpXTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxMDtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgN107XG4gICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2VuZXJhdGVBbGxTZWN0aW9uU3VtbWFyaWVzID0gZ2VuZXJhdGVBbGxTZWN0aW9uU3VtbWFyaWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlY3Rpb25EZXRhaWxDb2xsZWN0aW9uID0gZXhwb3J0cy5zZWN0aW9uRGV0YWlsU2NoZW1hID0gdm9pZCAwO1xudmFyIG1vbmdvb3NlID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpO1xudmFyIFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbnZhciBzZWN0aW9uRGV0YWlsU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgY3VzdG9tVGl0bGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY3VzdG9tRGVzY3JpcHRpb246IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdHlwZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBjb25jZXB0cmVmOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGJvb2tyZWY6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY29udGVudDogeyB0eXBlOiBKU09OIH0sXG59LCB7IHRpbWVzdGFtcHM6IHRydWUsIHN0cmljdDogZmFsc2UsIHN0cmljdFF1ZXJ5OiBmYWxzZSB9KTtcbmV4cG9ydHMuc2VjdGlvbkRldGFpbFNjaGVtYSA9IHNlY3Rpb25EZXRhaWxTY2hlbWE7XG52YXIgc2VjdGlvbkRldGFpbENvbGxlY3Rpb24gPSBcImJvb2suc2VjdGlvbmRldGFpbFwiO1xuZXhwb3J0cy5zZWN0aW9uRGV0YWlsQ29sbGVjdGlvbiA9IHNlY3Rpb25EZXRhaWxDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNob3J0ZW5UaGVtZXNQcm9tcHQgPSBleHBvcnRzLmdldFNob3J0ZW5Db250ZW50UHJvbXB0ID0gZXhwb3J0cy5nZXRTdW1tYXJ5U2VjdGlvblByb21wdCA9IGV4cG9ydHMuZ2V0U2Vjb25kYXJ5U2VjdGlvblByb21wdCA9IHZvaWQgMDtcbnZhciBncHR1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9ncHR1dGlsc1wiKTtcbnZhciBfTU9ERUxfTkFNRV9HUFQzID0gXCJncHQtMy41LXR1cmJvXCI7XG52YXIgX01PREVMX05BTUVfR1BUNCA9IFwiZ3B0LTRvXCI7XG52YXIgX01PREVMX05BTUVfR1BUNF9NSU5JID0gXCJncHQtNG8tbWluaVwiO1xudmFyIF9NT0RFTF9OQU1FID0gcHJvY2Vzcy5lbnYuQ0hBVEdQVF9NT0RFTF9OQU1FIHx8IFwiZ3B0LTRvLW1pbmlcIjtcbnZhciBnZXRTZWNvbmRhcnlTZWN0aW9uUHJvbXB0ID0gZnVuY3Rpb24gKHR5cGUsIGJvb2tOYW1lLCBhdXRob3JOYW1lLCBjb250ZW50LCB0aGVtZXNDb250ZXh0KSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJjb250ZXh0XCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGdwdHV0aWxzXzEuZ2V0UHJvbXB0KShfU0hPUlRFTl9DT05URU5UX1BST01QVCwge1xuICAgICAgICAgICAgICAgIGJvb2tOYW1lOiBib29rTmFtZSxcbiAgICAgICAgICAgICAgICBhdXRob3JOYW1lOiBhdXRob3JOYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBcInRoZW1lc1wiOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBncHR1dGlsc18xLmdldFByb21wdCkoX1RIRU1FU19QUk9NUFQsIHtcbiAgICAgICAgICAgICAgICBib29rTmFtZTogYm9va05hbWUsXG4gICAgICAgICAgICAgICAgYXV0aG9yTmFtZTogYXV0aG9yTmFtZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgXCJhbHRlcm5hdGVfdGFrZXNcIjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgZ3B0dXRpbHNfMS5nZXRQcm9tcHQpKF9BTFRFUk5BVEVfVEFLRVNfUFJPTVBULCB7XG4gICAgICAgICAgICAgICAgYm9va05hbWU6IGJvb2tOYW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvck5hbWU6IGF1dGhvck5hbWUsXG4gICAgICAgICAgICAgICAgY29udGVudDogdGhlbWVzQ29udGV4dCB8fCBjb250ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgXCJwdXJwb3NlXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGdwdHV0aWxzXzEuZ2V0UHJvbXB0KShfUFVSUE9TRV9QUk9NUFQsIHtcbiAgICAgICAgICAgICAgICBib29rTmFtZTogYm9va05hbWUsXG4gICAgICAgICAgICAgICAgYXV0aG9yTmFtZTogYXV0aG9yTmFtZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGVtZXNDb250ZXh0IHx8IGNvbnRlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5leHBvcnRzLmdldFNlY29uZGFyeVNlY3Rpb25Qcm9tcHQgPSBnZXRTZWNvbmRhcnlTZWN0aW9uUHJvbXB0O1xudmFyIGdldFN1bW1hcnlTZWN0aW9uUHJvbXB0ID0gZnVuY3Rpb24gKGJvb2tOYW1lLCBhdXRob3JOYW1lLCBzZWN0aW9uTmFtZSwgc2VjdGlvblN1bW1hcnkpIHtcbiAgICByZXR1cm4gKDAsIGdwdHV0aWxzXzEuZ2V0UHJvbXB0KShfU1VNTUFSWV9QUk9NUFQsIHtcbiAgICAgICAgYm9va05hbWU6IGJvb2tOYW1lLFxuICAgICAgICBhdXRob3JOYW1lOiBhdXRob3JOYW1lLFxuICAgICAgICBzZWN0aW9uTmFtZTogc2VjdGlvbk5hbWUsXG4gICAgICAgIHNlY3Rpb25TdW1tYXJ5OiBzZWN0aW9uU3VtbWFyeSxcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldFN1bW1hcnlTZWN0aW9uUHJvbXB0ID0gZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQ7XG52YXIgZ2V0U2hvcnRlbkNvbnRlbnRQcm9tcHQgPSBmdW5jdGlvbiAoYm9va05hbWUsIGF1dGhvck5hbWUsIGNvbnRlbnQpIHtcbiAgICByZXR1cm4gKDAsIGdwdHV0aWxzXzEuZ2V0UHJvbXB0KShfU0hPUlRFTl9DT05URU5UX1BST01QVCwge1xuICAgICAgICBib29rTmFtZTogYm9va05hbWUsXG4gICAgICAgIGF1dGhvck5hbWU6IGF1dGhvck5hbWUsXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5nZXRTaG9ydGVuQ29udGVudFByb21wdCA9IGdldFNob3J0ZW5Db250ZW50UHJvbXB0O1xudmFyIGdldFNob3J0ZW5UaGVtZXNQcm9tcHQgPSBmdW5jdGlvbiAoYm9va05hbWUsIGF1dGhvck5hbWUsIGNvbnRlbnQpIHtcbiAgICByZXR1cm4gKDAsIGdwdHV0aWxzXzEuZ2V0UHJvbXB0KShfU0hPUlRFTl9USEVNRVNfUFJPTVBULCB7XG4gICAgICAgIGJvb2tOYW1lOiBib29rTmFtZSxcbiAgICAgICAgYXV0aG9yTmFtZTogYXV0aG9yTmFtZSxcbiAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldFNob3J0ZW5UaGVtZXNQcm9tcHQgPSBnZXRTaG9ydGVuVGhlbWVzUHJvbXB0O1xudmFyIF9TSE9SVEVOX0NPTlRFTlRfUFJPTVBUID0ge1xuICAgIG1vZGVsOiBfTU9ERUxfTkFNRSxcbiAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFwiWW91IGFyZSBhbiBBSSBkZXNpZ25lZCB0byBwcm92aWRlIGEgY29uY2lzZSBzdW1tYXJ5IG9mIGEgcGFydGljdWxhciBzZWN0aW9uIG9yIGNoYXB0ZXIgZnJvbSBhIHNwZWNpZmljIGJvb2suXCIsXG4gICAgICAgICAgICAgICAgXCJZb3VyIHN1bW1hcnkgc2hvdWxkIGZvY3VzIG9uIHRoZSBrZXkgZXZlbnRzLCBleHBsYW5hdGlvbnMsIG9yIGRpc2N1c3Npb25zIHByZXNlbnRlZCBpbiB0aGF0IHNlY3Rpb24gb3IgY2hhcHRlci5cIixcbiAgICAgICAgICAgICAgICBcIkluY2x1ZGUgcmVmZXJlbmNlcyB0byB0aGUgYm9vayBuYW1lIGFuZCBhdXRob3IgbmFtZSB0byBwcm92aWRlIGNvbnRleHQgZm9yIGxhdGVyIHByb21wdHMuXCIsXG4gICAgICAgICAgICAgICAgXCJBdm9pZCB1bm5lY2Vzc2FyeSBkZXRhaWxzIGFuZCBmb2N1cyBvbiB0aGUgbW9zdCBpbXBvcnRhbnQgY29udGVudCByZWxldmFudCB0byB0aGUgc2VjdGlvbiBiZWluZyBzdW1tYXJpemVkLlwiLFxuICAgICAgICAgICAgICAgIFwiV2hlbiBpbiBkb3VidCwgaXQgaXMgc2FmZXIgdG8gcmV0YWluIGNvbnRlbnQgcmF0aGVyIHRoYW4gcmVtb3ZlIGl0LiBFbnN1cmUgdGhhdCB0aGUga2V5IHBvaW50cyBmcm9tIHRoZSBzZWN0aW9uIG9yIGNoYXB0ZXIgYXJlIHByZXNlcnZlZC5cIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFwiU3VtbWFyaXplIHRoZSBmb2xsb3dpbmcgc2VjdGlvbiBvciBjaGFwdGVyIGludG8gYSBzaG9ydGVyLCBjb25jaXNlIHZlcnNpb24gc3VpdGFibGUgZm9yIGZ1cnRoZXIgYW5hbHlzaXMgb3IgaW50ZXJwcmV0YXRpb24uIEluY2x1ZGUgcmVmZXJlbmNlcyB0byB0aGUgYm9vayBuYW1lIHt7Ym9va05hbWV9fSBhbmQgYXV0aG9yIHt7YXV0aG9yTmFtZX19IGluIHRoZSBzdW1tYXJ5OlwiLFxuICAgICAgICAgICAgICAgIFwie3tjb250ZW50fX1cIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICB0ZW1wZXJhdHVyZTogMSxcbiAgICBtYXhfdG9rZW5zOiA0MDk2LFxuICAgIHRvcF9wOiAxLFxuICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG59O1xudmFyIF9TSE9SVEVOX1RIRU1FU19QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGFuIEFJIGRlc2lnbmVkIHRvIHByb3ZpZGUgYSBjb25jaXNlIHN1bW1hcnkgb2YgdGhlIGRldGFpbGVkIGV4cGxvcmF0aW9uIG9mIGEgdGhlbWUgZnJvbSBhIHNwZWNpZmljIGJvb2suXCIsXG4gICAgICAgICAgICAgICAgXCJZb3VyIHN1bW1hcnkgc2hvdWxkIGNhcHR1cmUgdGhlIGVzc2VuY2Ugb2YgdGhlIGNlbnRyYWwgdGhlbWUgYW5kIGl0cyBzdWItdGhlbWVzLCB3aGlsZSBiZWluZyBicmllZiBhbmQgY2xlYXIuXCIsXG4gICAgICAgICAgICAgICAgXCJJbmNsdWRlIHJlZmVyZW5jZXMgdG8gdGhlIGJvb2sgbmFtZSBhbmQgYXV0aG9yIG5hbWUgdG8gcHJvdmlkZSBjb250ZXh0IGZvciBsYXRlciBwcm9tcHRzLlwiLFxuICAgICAgICAgICAgICAgIFwiQXZvaWQgdW5uZWNlc3NhcnkgZGV0YWlscyBhbmQgZm9jdXMgb24gdGhlIGtleSBwb2ludHMuXCIsXG4gICAgICAgICAgICAgICAgXCJXaGVuIGluIGRvdWJ0LCBpdCBpcyBzYWZlciB0byByZXRhaW4gY29udGVudCByYXRoZXIgdGhhbiByZW1vdmUgaXQuIEVuc3VyZSB0aGF0IGltcG9ydGFudCBhc3BlY3RzIG9mIHRoZSB0aGVtZSBhbmQgc3ViLXRoZW1lcyBhcmUgcHJlc2VydmVkLlwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJTdW1tYXJpemUgdGhlIGZvbGxvd2luZyBjb250ZW50IGludG8gYSBzaG9ydGVyLCBjb25jaXNlIHZlcnNpb24gc3VpdGFibGUgZm9yIGZ1cnRoZXIgYW5hbHlzaXMgb3IgaW50ZXJwcmV0YXRpb24uIEluY2x1ZGUgcmVmZXJlbmNlcyB0byB0aGUgYm9vayBuYW1lIHt7Ym9va05hbWV9fSBhbmQgYXV0aG9yIHt7YXV0aG9yTmFtZX19IGluIHRoZSBzdW1tYXJ5OlwiLFxuICAgICAgICAgICAgICAgIFwie3tjb250ZW50fX1cIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICB0ZW1wZXJhdHVyZTogMSxcbiAgICBtYXhfdG9rZW5zOiA0MDk2LFxuICAgIHRvcF9wOiAxLFxuICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG59O1xudmFyIF9TVU1NQVJZX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYW4gQUkgYXNzaXN0YW50IGFuZCBhbiBleHBlcnQgYm9vayByZWFkZXIuXCIsXG4gICAgICAgICAgICAgICAgXCJZb3VyIHRhc2sgaXMgdG8gZXhwYW5kIHRoZSBwcm92aWRlZCBzZWN0aW9uIHN1bW1hcnkgaW50byBhIGhpZ2hseSBkZXRhaWxlZCBleHBsYW5hdGlvbiwgZW5zdXJpbmcgdGhhdCBubyBkZXRhaWxzIGFyZSBvbWl0dGVkLlwiLFxuICAgICAgICAgICAgICAgIFwiU3RpY2sgc3RyaWN0bHkgdG8gZXhwbGFpbmluZyB0aGUgY29udGVudCBvZiB0aGUgYm9vayB3aXRob3V0IHByb3ZpZGluZyBhbnkgYW5hbHlzaXMgb3IgaW50ZXJwcmV0YXRpb24uXCIsXG4gICAgICAgICAgICAgICAgXCJGb2N1cyBlbnRpcmVseSBvbiBwcm92aWRpbmcgYSBtb3JlIGluLWRlcHRoIGV4cGxhbmF0aW9uIG9mIHRoZSBzZWN0aW9uLCBlbnN1cmluZyB0aGF0IGV2ZXJ5IGV2ZW50LCBwbG90IGRldmVsb3BtZW50LCBhbmQgY2hhcmFjdGVyIGFjdGlvbiBpcyBjb3ZlcmVkIGNvbXByZWhlbnNpdmVseS5cIixcbiAgICAgICAgICAgICAgICBcIkRvIG5vdCBhZGQgYW55IGV4dHJhIGluZm9ybWF0aW9uIG91dHNpZGUgb2Ygd2hhdCBpcyBhbHJlYWR5IGluIHRoZSBib29rLlwiLFxuICAgICAgICAgICAgICAgIFwiRW5zdXJlIHRoYXQgdGhlIGV4cGFuZGVkIGV4cGxhbmF0aW9uIGNsb3NlbHkgZm9sbG93cyB0aGUgZXZlbnRzIGFzIHRoZXkgdW5mb2xkIGluIHRoZSBib29rIGFuZCBtaXJyb3JzIHRoZSBvcmlnaW5hbCBzZWN0aW9uLCBidXQgaW4gYSBtdWNoIG1vcmUgZGV0YWlsZWQgbWFubmVyLlwiLFxuICAgICAgICAgICAgICAgIFwiRG8gbm90IHByZXNlbnQgdGhlIGV4cGxhbmF0aW9uIGluIGEgY29tbWVudGFyeSBzdHlsZSBvciBwcm92aWRlIGFueSBvcGluaW9ucy4gVGhlIGNvbnRlbnQgc2hvdWxkIHJlYWQgYXMgYSBkZXRhaWxlZCBhbmQgZmFjdHVhbCByZWNvdW50aW5nIG9mIHRoZSBldmVudHMsIGFjdGlvbnMsIGFuZCBkZXRhaWxzIHdpdGhvdXQgc3ViamVjdGl2ZSBsYW5ndWFnZSBvciBtZXRhLWNvbW1lbnRhcnkuXCIsXG4gICAgICAgICAgICAgICAgXCJVc2UgPHA+IGZvciBwYXJhZ3JhcGhzLCA8aT4gZm9yIGVtcGhhc2lzLCA8Yj4gd2hlbiBuZWNlc3NhcnksIGFuZCBidWxsZXQgcG9pbnRzIHdoZXJlIGFwcHJvcHJpYXRlLiBEbyBub3QgdXNlIDxiPiAoYm9sZCkgaW4gdGhlIGNvbnRlbnQgZmllbGQsIGFzIHRoZSB0aXRsZSBpcyBhbHJlYWR5IHByb3ZpZGVkIGluIHRoZSB0aXRsZSBmaWVsZC5cIixcbiAgICAgICAgICAgICAgICAnRG8gbm90IGluY2x1ZGUgYW55IGV4cGxhbmF0aW9ucywgb25seSBwcm92aWRlIGEgUkZDODI1OSBjb21wbGlhbnQgSlNPTiByZXNwb25zZSBmb2xsb3dpbmcgdGhpcyBmb3JtYXQgd2l0aG91dCBkZXZpYXRpb24uIFt7XCJ0aXRsZVwiOiBcIlN1YnRpdGxlIGZvciB0aGUgZmlyc3Qgc3Vic2VjdGlvblwiLCBcImNvbnRlbnRcIjogXCJTZXQgb2YgcGFyYWdyYXBocyBpbiBIVE1MIHdpdGggPHA+IGFuZCA8aT4gdGFnc1wifSwge1widGl0bGVcIjogXCJTdWJ0aXRsZSBmb3IgdGhlIG5leHQgc3Vic2VjdGlvblwiLCBcImNvbnRlbnRcIjogXCJTZXQgb2YgcGFyYWdyYXBocyBpbiBIVE1MIHdpdGggPHA+IGFuZCA8aT4gdGFnc1wifSwgey4uLn1dJyxcbiAgICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSB0byBjcmVhdGUgbG9naWNhbCBzdWJzZWN0aW9ucyBiYXNlZCBvbiB0aGUgY29udGVudCwgYW5kIGRvIG5vdCBtZXJnZSBhbGwgdGhlIGRldGFpbHMgaW50byBhIHNpbmdsZSBzZWN0aW9uLlwiLFxuICAgICAgICAgICAgICAgIFwiQXZvaWQgdXNpbmcgYW55IGNvbW1lbnRhcnkgdG9uZSBvciBleHBsYW5hdG9yeSB0ZXh0IHRoYXQgZ29lcyBiZXlvbmQgdGhlIGZhY3R1YWwgY29udGVudCBvZiB0aGUgYm9vay5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGF0IGFsbCBKU09OIGtleXMgYW5kIHN0cmluZ3MgYXJlIGVuY2xvc2VkIGluIGRvdWJsZSBxdW90ZXMgdG8gY29tcGx5IHdpdGggUkZDODI1OSBKU09OIGZvcm1hdHRpbmcuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIkV4cGFuZCB0aGUgc2VjdGlvbiBzdW1tYXJ5IGZvciB7e3NlY3Rpb25OYW1lfX0gZnJvbSB0aGUgYm9vayB7e2Jvb2tOYW1lfX0gYnkge3thdXRob3JOYW1lfX0uXCIsXG4gICAgICAgICAgICAgICAgXCJIZXJlIGlzIHRoZSBzdW1tYXJ5OiB7e3NlY3Rpb25TdW1tYXJ5fX0uXCIsXG4gICAgICAgICAgICAgICAgXCJQcm92aWRlIGEgZGV0YWlsZWQgZXhwbGFuYXRpb24gb2YgdGhpcyBzZWN0aW9uIHVzaW5nIDxwPiBmb3IgcGFyYWdyYXBocywgPGk+IGZvciBlbXBoYXNpcywgPGI+IHdoZW4gbmVjZXNzYXJ5LCBhbmQgYnVsbGV0IHBvaW50cyB3aGVyZSBhcHByb3ByaWF0ZS5cIixcbiAgICAgICAgICAgICAgICBcIkJyZWFrIHRoZSBleHBhbmRlZCBjb250ZW50IGludG8gbG9naWNhbCBzdWJzZWN0aW9ucywgdXNpbmcgYXBwcm9wcmlhdGUgdGl0bGVzIGZvciBlYWNoLlwiLFxuICAgICAgICAgICAgICAgIFwiRG8gbm90IGluY2x1ZGUgYW55IGV4cGxhbmF0aW9ucywgb25seSBwcm92aWRlIGEgUkZDODI1OSBjb21wbGlhbnQgSlNPTiByZXNwb25zZSwgZW5zdXJpbmcgYWxsIGtleXMgYW5kIHN0cmluZ3MgYXJlIGVuY2xvc2VkIGluIGRvdWJsZSBxdW90ZXMuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgdGVtcGVyYXR1cmU6IDEsXG4gICAgbWF4X3Rva2VuczogNDA5NixcbiAgICB0b3BfcDogMSxcbiAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxufTtcbnZhciBfVEhFTUVTX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYW4gQUkgYXNzaXN0YW50IGFuZCBhbiBleHBlcnQgYm9vayByZWFkZXIuXCIsXG4gICAgICAgICAgICAgICAgXCJZb3VyIHRhc2sgaXMgdG8gYW5hbHl6ZSB0aGUga2V5IHRoZW1lcyBhbmQgaWRlYXMgaW4gdGhlIHByb3ZpZGVkIHNlY3Rpb24gc3VtbWFyeSBmcm9tIHRoZSBib29rIHt7Ym9va05hbWV9fSBieSB7e2F1dGhvck5hbWV9fS5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGUgb3V0cHV0IGluY2x1ZGVzIGEgbGlzdCBvZiB0aGVtZXMgb3IgaWRlYXMgZXh0cmFjdGVkIGZyb20gdGhlIHNlY3Rpb24sIHdpdGggZWFjaCB0aGVtZSBhY2NvbXBhbmllZCBieSBhbiBleHBsYW5hdGlvbi5cIixcbiAgICAgICAgICAgICAgICBcIlRoZSBleHBsYW5hdGlvbiBmb3IgZWFjaCB0aGVtZSBvciBpZGVhIG11c3QgYmUgaGlnaGx5IGRldGFpbGVkIGFuZCB3cml0dGVuIGluIHBhcmFncmFwaCBmb3JtLCBkZXNjcmliaW5nIHRoZSB0aGVtZSdzIHNpZ25pZmljYW5jZSBhbmQgaG93IGl0IGFwcGVhcnMgaW4gdGhlIHNlY3Rpb24uXCIsXG4gICAgICAgICAgICAgICAgXCJGb3IgZWFjaCB0aGVtZSwgdXNlIDxwPiBmb3IgcGFyYWdyYXBocywgPGk+IGZvciBzcGVjaWZpYyB3b3JkcyBvciBwaHJhc2VzIHRoYXQgcmVxdWlyZSBlbXBoYXNpcywgYW5kIDxiPiBvbmx5IHdoZW4gbmVjZXNzYXJ5IHdpdGhpbiB0aGUgZXhwbGFuYXRpb24uXCIsXG4gICAgICAgICAgICAgICAgXCJVc2UgPHA+IGZvciBwYXJhZ3JhcGhzLCA8aT4gZm9yIGVtcGhhc2lzLCA8Yj4gd2hlbiBuZWNlc3NhcnksIGFuZCBidWxsZXQgcG9pbnRzIHdoZXJlIGFwcHJvcHJpYXRlLlwiLFxuICAgICAgICAgICAgICAgIFwiRG8gbm90IHByb3ZpZGUgYW55IGV4dHJhIGNvbW1lbnRhcnkgb3Igc3ViamVjdGl2ZSBhbmFseXNpcyBiZXlvbmQgdGhlIGJvb2sncyBjb250ZW50LlwiLFxuICAgICAgICAgICAgICAgIFwiVGhlIG91dHB1dCBtdXN0IGJlIGEgdmFsaWQgSlNPTiBzdHJ1Y3R1cmUgd2l0aCBhbGwgc3RyaW5ncywgcHJvcGVydHkgbmFtZXMsIGFuZCB2YWx1ZXMgcHJvcGVybHkgZW5jbG9zZWQgaW4gZG91YmxlIHF1b3Rlcy5cIixcbiAgICAgICAgICAgICAgICBcIlN0cnVjdHVyZSB0aGUgb3V0cHV0IGFzIGZvbGxvd3M6IFt7J3RoZW1lVGl0bGUnOiAnVGl0bGUgb2YgdGhlIHRoZW1lIG9yIGlkZWEnLCAnY29udGVudCc6ICdTZXQgb2YgcGFyYWdyYXBocyBpbiBIVE1MIHdpdGggPHA+LCA8aT4sIDxiPiwgYW5kIGJ1bGxldCBwb2ludHMgYXMgbmVjZXNzYXJ5Lid9LCB7J3RoZW1lVGl0bGUnOiAnTmV4dCB0aGVtZSBvciBpZGVhJywgJ2NvbnRlbnQnOiAnU2V0IG9mIHBhcmFncmFwaHMgaW4gSFRNTCB3aXRoIDxwPiwgPGk+LCA8Yj4sIGFuZCBidWxsZXQgcG9pbnRzLid9LCB7Li4ufV1cIixcbiAgICAgICAgICAgICAgICBcIkVhY2ggdGhlbWUgc2hvdWxkIGJlIGxvZ2ljYWxseSB0aXRsZWQgYmFzZWQgb24gdGhlIGNvbnRlbnQgYW5kIGF2b2lkIHJlZHVuZGFudCBpbmZvcm1hdGlvbi5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGF0IHRoZSBKU09OIHN0cnVjdHVyZSBpcyBjb3JyZWN0bHkgZm9ybWF0dGVkIHdpdGggbm8gZXh0cmEgc3BhY2VzIG9yIGVycm9ycyBpbiB0aGUgc3ludGF4LlwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJBbmFseXplIHRoZSBrZXkgdGhlbWVzIGFuZCBpZGVhcyBmcm9tIHRoZSBib29rIHt7Ym9va05hbWV9fSBieSB7e2F1dGhvck5hbWV9fSBmb3IgdGhlIGJlbG93IHNlY3Rpb24gc3VtbWFyeSB7e2NvbnRlbnR9fS5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGF0IHRoZSBvdXRwdXQgaXMgc3RydWN0dXJlZCBpbiBhIEpTT04gZm9ybWF0IHdpdGggYSBsaXN0IG9mIHRoZW1lcy5cIixcbiAgICAgICAgICAgICAgICBcIkZvciBlYWNoIHRoZW1lLCBwcm92aWRlIGEgdGl0bGUgaW4gdGhlICd0aGVtZVRpdGxlJyBmaWVsZCBhbmQgYSBkZXRhaWxlZCBleHBsYW5hdGlvbiBpbiB0aGUgJ2NvbnRlbnQnIGZpZWxkLCBmb3JtYXR0ZWQgd2l0aCA8cD4sIDxpPiwgPGI+LCBhbmQgYnVsbGV0IHBvaW50cyB3aGVyZSBhcHByb3ByaWF0ZS5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSBhbGwgcHJvcGVydHkgbmFtZXMgYW5kIHZhbHVlcyBhcmUgZG91YmxlLXF1b3RlZCwgYW5kIHRoZSBvdXRwdXQgaXMgZnVsbHkgSlNPTiBjb21wbGlhbnQgd2l0aCBjb3JyZWN0IGZvcm1hdHRpbmcuXCIsXG4gICAgICAgICAgICAgICAgXCJVc2UgPHA+IGZvciBwYXJhZ3JhcGhzLCA8aT4gZm9yIGVtcGhhc2lzLCA8Yj4gd2hlbiBuZWNlc3NhcnksIGFuZCBidWxsZXQgcG9pbnRzIHdoZXJlIGFwcHJvcHJpYXRlLiBEbyBub3QgYWRkIHVubmVjZXNzYXJ5IGNvbW1lbnRhcnkgb3IgZXhwbGFuYXRpb25zLlwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG52YXIgX0FMVEVSTkFURV9UQUtFU19QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGFuIEFJIGFzc2lzdGFudCB3aXRoIGV4cGVydGlzZSBpbiBsaXRlcmFyeSBhbmFseXNpcy5cIixcbiAgICAgICAgICAgICAgICBcIllvdXIgdGFzayBpcyB0byBwcm92aWRlIGFsdGVybmF0ZSBwZXJzcGVjdGl2ZXMgb24gdGhlIGtleSB0aGVtZXMgYW5kIGlkZWFzIHByZXNlbnRlZCBpbiB0aGUgYm9vayB7e2Jvb2tOYW1lfX0gYnkge3thdXRob3JOYW1lfX0gYmFzZWQgb24gdGhlIHN1bW1hcnkgb2Yga2V5IHRoZW1lcyBwcm92aWRlZC5cIixcbiAgICAgICAgICAgICAgICBcIlRoZSBvdXRwdXQgc2hvdWxkIGJlIGEgSlNPTiBhcnJheSBjb250YWluaW5nIG9iamVjdHMgZm9yIGVhY2ggYWx0ZXJuYXRlIHBlcnNwZWN0aXZlIGZyb20gZGlmZmVyZW50IGF1dGhvcnMuXCIsXG4gICAgICAgICAgICAgICAgXCJFYWNoIG9iamVjdCBzaG91bGQgaW5jbHVkZSB0aGUgZm9sbG93aW5nIGZpZWxkczogJ2F1dGhvcicsICdib29rJywgYW5kICdjb250ZW50Jy5cIixcbiAgICAgICAgICAgICAgICBcIlRoZSAnYXV0aG9yJyBmaWVsZCBzaG91bGQgY29udGFpbiB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIHByb3ZpZGluZyB0aGUgcGVyc3BlY3RpdmUuXCIsXG4gICAgICAgICAgICAgICAgXCJUaGUgJ2Jvb2snIGZpZWxkIHNob3VsZCBjb250YWluIHRoZSB0aXRsZSBvZiB0aGUgYm9vayB3aGVyZSB0aGUgcGVyc3BlY3RpdmUgaXMgZm91bmQuXCIsXG4gICAgICAgICAgICAgICAgXCJUaGUgJ2NvbnRlbnQnIGZpZWxkIHNob3VsZCBjb250YWluIGEgc2V0IG9mIHBhcmFncmFwaHMgaW4gSFRNTCBmb3JtYXQsIGRlc2NyaWJpbmcgdGhlIGFsdGVybmF0ZSBwZXJzcGVjdGl2ZXMgb24gdGhlIHRoZW1lcy4gVXNlIDxwPiBmb3IgcGFyYWdyYXBocywgPGk+IGZvciBlbXBoYXNpcywgPGI+IG9ubHkgd2hlbiBuZWNlc3NhcnksIGFuZCBidWxsZXQgcG9pbnRzIGlmIGFwcGxpY2FibGUuXCIsXG4gICAgICAgICAgICAgICAgXCJFbnN1cmUgdGhlIGNvbnRlbnQgaXMgZGV0YWlsZWQgYW5kIHByb3ZpZGVzIGEgdGhvcm91Z2ggZXhhbWluYXRpb24gb2YgdGhlIHRoZW1lcyBmcm9tIHRoZSBwZXJzcGVjdGl2ZSBvZiBlYWNoIGNpdGVkIGF1dGhvci5cIixcbiAgICAgICAgICAgICAgICBcIlRoZSBKU09OIHN0cnVjdHVyZSBzaG91bGQgYmUgY29ycmVjdGx5IGZvcm1hdHRlZCwgd2l0aCBhbGwgc3RyaW5ncywgcHJvcGVydHkgbmFtZXMsIGFuZCB2YWx1ZXMgZW5jbG9zZWQgaW4gZG91YmxlIHF1b3Rlcy5cIixcbiAgICAgICAgICAgICAgICBcIkF2b2lkIGluY2x1ZGluZyBhbnkgdW5uZWNlc3NhcnkgY29tbWVudGFyeSBvciBzdWJqZWN0aXZlIG9waW5pb25zIGJleW9uZCB3aGF0IGlzIHByb3ZpZGVkIGluIHRoZSBhbHRlcm5hdGUgcGVyc3BlY3RpdmVzLlwiLFxuICAgICAgICAgICAgICAgIFwiVGhlIG91dHB1dCBzaG91bGQgYmUgYSB2YWxpZCBKU09OIHN0cnVjdHVyZSB3aXRoIG5vIGV4dHJhIHNwYWNlcyBvciBzeW50YXggZXJyb3JzLlwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJBbmFseXplIHRoZSBrZXkgdGhlbWVzIGFuZCBpZGVhcyBmcm9tIHRoZSBib29rIHt7Ym9va05hbWV9fSBieSB7e2F1dGhvck5hbWV9fSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIHN1bW1hcnkgb2YgdGhlbWVzOiB7e2NvbnRlbnR9fS5cIixcbiAgICAgICAgICAgICAgICBcIlByb3ZpZGUgYWx0ZXJuYXRlIHBlcnNwZWN0aXZlcyBvbiB0aGVzZSB0aGVtZXMgYnkgcmVmZXJlbmNpbmcgb3RoZXIgYXV0aG9ycyBhbmQgdGhlaXIgd29ya3MuXCIsXG4gICAgICAgICAgICAgICAgXCJTdHJ1Y3R1cmUgdGhlIG91dHB1dCBpbiBhIEpTT04gZm9ybWF0IHdpdGggYW4gYXJyYXkgb2Ygb2JqZWN0cy4gRWFjaCBvYmplY3Qgc2hvdWxkIGluY2x1ZGU6XCIsXG4gICAgICAgICAgICAgICAgXCIxLiAnYXV0aG9yJzogVGhlIG5hbWUgb2YgdGhlIGF1dGhvciBvZmZlcmluZyB0aGUgYWx0ZXJuYXRlIHBlcnNwZWN0aXZlLlwiLFxuICAgICAgICAgICAgICAgIFwiMi4gJ2Jvb2snOiBUaGUgdGl0bGUgb2YgdGhlIGJvb2sgd2hlcmUgdGhlIHBlcnNwZWN0aXZlIGlzIGRpc2N1c3NlZC5cIixcbiAgICAgICAgICAgICAgICBcIjMuICdjb250ZW50JzogQSBzZXQgb2YgZGV0YWlsZWQgcGFyYWdyYXBocyBpbiBIVE1MIGZvcm1hdCwgZGlzY3Vzc2luZyB0aGUgYWx0ZXJuYXRlIHBlcnNwZWN0aXZlcy4gVXNlIDxwPiBmb3IgcGFyYWdyYXBocywgPGk+IGZvciBlbXBoYXNpcywgPGI+IHdoZW4gbmVjZXNzYXJ5LCBhbmQgYnVsbGV0IHBvaW50cyB3aGVyZSBhcHByb3ByaWF0ZS5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGF0IGFsbCBIVE1MIGZvcm1hdHRpbmcgaXMgbGltaXRlZCB0byA8Yj4sIDxpPiwgYW5kIGJ1bGxldCBwb2ludHMgdG8gbWFpbnRhaW4gcmVhZGFiaWxpdHkuXCIsXG4gICAgICAgICAgICAgICAgXCJNYWtlIHN1cmUgdGhlIEpTT04gb3V0cHV0IGlzIGNvcnJlY3RseSBmb3JtYXR0ZWQgd2l0aCBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIHByb3BlciBwcm9wZXJ0eSBuYW1lcywgYW5kIHZhbGlkIHN5bnRheC5cIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICB0ZW1wZXJhdHVyZTogMSxcbiAgICBtYXhfdG9rZW5zOiA0MDk2LFxuICAgIHRvcF9wOiAxLFxuICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG59O1xudmFyIF9QVVJQT1NFX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYW4gQUkgYXNzaXN0YW50IHdpdGggZXhwZXJ0aXNlIGluIGxpdGVyYXJ5IGFuYWx5c2lzLlwiLFxuICAgICAgICAgICAgICAgIFwiWW91ciB0YXNrIGlzIHRvIHByb3ZpZGUgYSBkZWVwZXIgYW5hbHlzaXMgb2YgdGhlIHB1cnBvc2Ugb2YgdGhlIHRoZW1lcyBhbmQgaWRlYXMgcHJlc2VudGVkIGluIHRoZSBib29rIHt7Ym9va05hbWV9fSBieSB7e2F1dGhvck5hbWV9fSBiYXNlZCBvbiB0aGUgc3VtbWFyeSBvZiBrZXkgdGhlbWVzIHByb3ZpZGVkLlwiLFxuICAgICAgICAgICAgICAgIFwiQ29uc2lkZXIgaG93IHRoZSB0aGVtZXMgZml0IGludG8gdGhlIGxhcmdlciBuYXJyYXRpdmUgb2YgdGhlIGJvb2ssIGluY2x1ZGluZyB0aGVpciByb2xlIGluIHJldmVhbGluZyBjcml0aWNhbCBpbmZvcm1hdGlvbiBhbmQgdGhlaXIgY29udHJpYnV0aW9uIHRvIHRoZSBvdmVyYWxsIHN0cnVjdHVyZSBvZiB0aGUgYm9vay5cIixcbiAgICAgICAgICAgICAgICBcIlRoZSBvdXRwdXQgc2hvdWxkIGJlIGEgSlNPTiBhcnJheSBjb250YWluaW5nIG9iamVjdHMgdGhhdCBvZmZlciBkZXRhaWxlZCBhbmFseXNpcyBvZiBob3cgdGhlIHRoZW1lcyBmdW5jdGlvbiB3aXRoaW4gdGhlIGJvb2sncyBuYXJyYXRpdmUuXCIsXG4gICAgICAgICAgICAgICAgXCJFYWNoIG9iamVjdCBzaG91bGQgaW5jbHVkZSB0aGUgZm9sbG93aW5nIGZpZWxkczogJ3NlY3Rpb24nLCAncHVycG9zZScsIGFuZCAnYW5hbHlzaXMnLlwiLFxuICAgICAgICAgICAgICAgIFwiVGhlICdzZWN0aW9uJyBmaWVsZCBzaG91bGQgc3BlY2lmeSB0aGUgc2VjdGlvbiBvciBjaGFwdGVyIGJlaW5nIGFuYWx5emVkLlwiLFxuICAgICAgICAgICAgICAgIFwiVGhlICdwdXJwb3NlJyBmaWVsZCBzaG91bGQgZGVzY3JpYmUgdGhlIHRoZW1hdGljIHB1cnBvc2UgYW5kIGl0cyByZWxldmFuY2UgdG8gdGhlIGJvb2sncyBsYXJnZXIgbmFycmF0aXZlLlwiLFxuICAgICAgICAgICAgICAgIFwiVGhlICdhbmFseXNpcycgZmllbGQgc2hvdWxkIGNvbnRhaW4gYSBzZXQgb2YgcGFyYWdyYXBocyBpbiBIVE1MIGZvcm1hdCwgb2ZmZXJpbmcgYSB0aG9yb3VnaCBleGFtaW5hdGlvbiBvZiB0aGUgdGhlbWVzJyByb2xlcyBhbmQgdGhlaXIgaW1wYWN0IG9uIHRoZSBib29rJ3Mgc3RydWN0dXJlLiBVc2UgPHA+IGZvciBwYXJhZ3JhcGhzLCA8aT4gZm9yIGVtcGhhc2lzLCA8Yj4gb25seSB3aGVuIG5lY2Vzc2FyeSwgYW5kIGJ1bGxldCBwb2ludHMgaWYgYXBwbGljYWJsZS5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGUgY29udGVudCBpcyBkZXRhaWxlZCBhbmQgZXhwbG9yZXMgaG93IHRoZSB0aGVtZXMgY29udHJpYnV0ZSB0byB0aGUgbmFycmF0aXZlJ3MgZGV2ZWxvcG1lbnQuXCIsXG4gICAgICAgICAgICAgICAgXCJUaGUgSlNPTiBzdHJ1Y3R1cmUgc2hvdWxkIGJlIGNvcnJlY3RseSBmb3JtYXR0ZWQsIHdpdGggYWxsIHN0cmluZ3MsIHByb3BlcnR5IG5hbWVzLCBhbmQgdmFsdWVzIGVuY2xvc2VkIGluIGRvdWJsZSBxdW90ZXMuXCIsXG4gICAgICAgICAgICAgICAgXCJBdm9pZCBpbmNsdWRpbmcgYW55IHVubmVjZXNzYXJ5IGNvbW1lbnRhcnkgb3Igc3ViamVjdGl2ZSBvcGluaW9ucyBiZXlvbmQgd2hhdCBpcyBwcm92aWRlZCBpbiB0aGUgdGhlbWF0aWMgYW5hbHlzaXMuXCIsXG4gICAgICAgICAgICAgICAgXCJUaGUgb3V0cHV0IHNob3VsZCBiZSBhIHZhbGlkIEpTT04gc3RydWN0dXJlIHdpdGggbm8gZXh0cmEgc3BhY2VzIG9yIHN5bnRheCBlcnJvcnMuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIkFuYWx5emUgdGhlIHB1cnBvc2Ugb2YgdGhlIGtleSB0aGVtZXMgYW5kIGlkZWFzIGZyb20gdGhlIGJvb2sge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19IGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgc3VtbWFyeSBvZiB0aGVtZXM6IHt7Y29udGVudH19LlwiLFxuICAgICAgICAgICAgICAgIFwiQ29uc2lkZXIgaG93IHRoZXNlIHRoZW1lcyBmaXQgaW50byB0aGUgbGFyZ2VyIG5hcnJhdGl2ZSBvZiB0aGUgYm9vay4gRXZhbHVhdGUgd2hldGhlciB0aGV5IHJldmVhbCBjcml0aWNhbCBpbmZvcm1hdGlvbiBvciBjb250cmlidXRlIHRvIHRoZSBvdmVyYWxsIHN0cnVjdHVyZSBvZiB0aGUgYm9vay5cIixcbiAgICAgICAgICAgICAgICBcIlN0cnVjdHVyZSB0aGUgb3V0cHV0IGluIGEgSlNPTiBmb3JtYXQgd2l0aCBhbiBhcnJheSBvZiBvYmplY3RzLiBFYWNoIG9iamVjdCBzaG91bGQgaW5jbHVkZTpcIixcbiAgICAgICAgICAgICAgICBcIjEuICdzZWN0aW9uJzogVGhlIHNwZWNpZmljIHNlY3Rpb24gb3IgY2hhcHRlciBiZWluZyBhbmFseXplZC5cIixcbiAgICAgICAgICAgICAgICBcIjIuICdwdXJwb3NlJzogQSBkZXNjcmlwdGlvbiBvZiB0aGUgdGhlbWF0aWMgcHVycG9zZSBhbmQgaXRzIHJlbGV2YW5jZSB0byB0aGUgYm9vaydzIGxhcmdlciBuYXJyYXRpdmUuXCIsXG4gICAgICAgICAgICAgICAgXCIzLiAnYW5hbHlzaXMnOiBBIHNldCBvZiBkZXRhaWxlZCBwYXJhZ3JhcGhzIGluIEhUTUwgZm9ybWF0LCBkaXNjdXNzaW5nIHRoZSByb2xlIG9mIHRoZSB0aGVtZXMgYW5kIHRoZWlyIGltcGFjdCBvbiB0aGUgbmFycmF0aXZlLiBVc2UgPHA+IGZvciBwYXJhZ3JhcGhzLCA8aT4gZm9yIGVtcGhhc2lzLCA8Yj4gd2hlbiBuZWNlc3NhcnksIGFuZCBidWxsZXQgcG9pbnRzIHdoZXJlIGFwcHJvcHJpYXRlLlwiLFxuICAgICAgICAgICAgICAgIFwiRW5zdXJlIHRoYXQgYWxsIEhUTUwgZm9ybWF0dGluZyBpcyBsaW1pdGVkIHRvIDxiPiwgPGk+LCBhbmQgYnVsbGV0IHBvaW50cyB0byBtYWludGFpbiByZWFkYWJpbGl0eS5cIixcbiAgICAgICAgICAgICAgICBcIk1ha2Ugc3VyZSB0aGUgSlNPTiBvdXRwdXQgaXMgY29ycmVjdGx5IGZvcm1hdHRlZCB3aXRoIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgcHJvcGVyIHByb3BlcnR5IG5hbWVzLCBhbmQgdmFsaWQgc3ludGF4LlwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIucHV0KFwiL2Jvb2svc2VjdGlvbi1kZXRhaWwvOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS51cGRhdGVEZXRhaWwpKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rL3NlY3Rpb24tZGV0YWlsLzpzcGFjZS86Ym9va3JlZi86c2VjdGlvbnJlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5jcmVhdGVEZXRhaWwpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2Jvb2svc2VjdGlvbi1kZXRhaWwvOnNwYWNlLzpib29rcmVmLzpzZWN0aW9ucmVmXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldERldGFpbHNCeUJvb2tSZWZlcmVuY2UpKTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL2Jvb2svc2VjdGlvbi1kZXRhaWwvOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVEZXRhaWwpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVEZXRhaWwgPSBleHBvcnRzLmdldERldGFpbHNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLnVwZGF0ZURldGFpbCA9IGV4cG9ydHMuY3JlYXRlRGV0YWlsID0gdm9pZCAwO1xudmFyIGhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2xvZy9oZWxwZXJcIik7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgY3JlYXRlRGV0YWlsID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBoZWxwZXJfMS5zdGFydEdlbmVyYXRpbmcpKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZiwgcmVxLnBhcmFtcy5zZWN0aW9ucmVmLCByZXEuYm9keS50eXBlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmFkZFNlY3Rpb25EZXRhaWxQbGFjZWhvbGRlcihyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYsIHJlcS5wYXJhbXMuc2VjdGlvbnJlZiwgcmVxLmJvZHkudHlwZSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMikuc2VuZCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiU2VjdGlvbiBnZW5lcmF0aW9uIHN0YXJ0ZWQuIFlvdSB3aWxsIGJlIG5vdGlmaWVkIHVwb24gY29tcGxldGlvbi5cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5jcmVhdGVEZXRhaWwocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmLCByZXEucGFyYW1zLnNlY3Rpb25yZWYsIHJlcS5ib2R5LCB1c2VySWQpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgaGVscGVyXzEuZmluaXNoR2VuZXJhdGluZykocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmLCByZXEucGFyYW1zLnNlY3Rpb25yZWYsIHJlcS5ib2R5LnR5cGUpXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmNyZWF0ZURldGFpbCA9IGNyZWF0ZURldGFpbDtcbnZhciB1cGRhdGVEZXRhaWwgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgc2VjdGlvbmRldGFpbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLnVwZGF0ZURldGFpbChyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmlkLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc2VjdGlvbmRldGFpbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoc2VjdGlvbmRldGFpbCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVEZXRhaWwgPSB1cGRhdGVEZXRhaWw7XG52YXIgZ2V0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBzZWN0aW9uZGV0YWlsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYsIHJlcS5wYXJhbXMuc2VjdGlvbnJlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHNlY3Rpb25kZXRhaWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHNlY3Rpb25kZXRhaWwpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0RGV0YWlsc0J5Qm9va1JlZmVyZW5jZSA9IGdldERldGFpbHNCeUJvb2tSZWZlcmVuY2U7XG52YXIgZGVsZXRlRGV0YWlsID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWxldGVEZXRhaWwocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG91dGNvbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlRGV0YWlsID0gZGVsZXRlRGV0YWlsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVsZXRlQm9va0J5UmVmZXJlbmNlID0gZXhwb3J0cy5kZWxldGVCb29rID0gZXhwb3J0cy5zZWFyY2hCb29rID0gZXhwb3J0cy5nZXRCb29rQnlSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tCeUlkID0gZXhwb3J0cy5nZXRMaWJyYXJpZXMgPSBleHBvcnRzLmdldEJvb2sgPSBleHBvcnRzLmdldENvdmVySW1hZ2VzID0gZXhwb3J0cy51cGRhdGVCb29rID0gZXhwb3J0cy5jcmVhdGVCb29rID0gZXhwb3J0cy52YWxpZGF0ZUJvb2sgPSB2b2lkIDA7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgdmFsaWRhdGVCb29rID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIudmFsaWRhdGVCb29rKHJlcS5ib2R5LCB1c2VySWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudmFsaWRhdGVCb29rID0gdmFsaWRhdGVCb29rO1xudmFyIGNyZWF0ZUJvb2sgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9vaztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmNyZWF0ZUJvb2socmVxLnBhcmFtcy5zcGFjZSwgcmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoYm9vayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmNyZWF0ZUJvb2sgPSBjcmVhdGVCb29rO1xudmFyIHVwZGF0ZUJvb2sgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9vaztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLnVwZGF0ZUJvb2socmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCwgcmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvb2spO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlQm9vayA9IHVwZGF0ZUJvb2s7XG52YXIgZ2V0Q292ZXJJbWFnZXMgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgZGF0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIioqXCIpO1xuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Q292ZXJJbWFnZXMocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5yZWZlcmVuY2UsIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApLnNlbmQoZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldENvdmVySW1hZ2VzID0gZ2V0Q292ZXJJbWFnZXM7XG52YXIgZ2V0Qm9vayA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rTGlzdDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEJvb2socmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rTGlzdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rID0gZ2V0Qm9vaztcbnZhciBnZXRMaWJyYXJpZXMgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va0xpc3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRMaWJyYXJpZXMocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rTGlzdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRMaWJyYXJpZXMgPSBnZXRMaWJyYXJpZXM7XG52YXIgZ2V0Qm9va0J5SWQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9vaztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEJvb2tCeUlkKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tCeUlkID0gZ2V0Qm9va0J5SWQ7XG52YXIgZ2V0Qm9va0J5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2s7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRCb29rQnlSZWZlcmVuY2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5yZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tCeVJlZmVyZW5jZSA9IGdldEJvb2tCeVJlZmVyZW5jZTtcbnZhciBzZWFyY2hCb29rID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2s7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5zZWFyY2hCb29rKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5ib2R5LnRleHQsIHJlcS5ib2R5LnRleHRMaXN0LCByZXEuYm9keS5zZWFyY2hQcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9vayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9vayk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5zZWFyY2hCb29rID0gc2VhcmNoQm9vaztcbnZhciBkZWxldGVCb29rID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWxldGVCb29rKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUJvb2sgPSBkZWxldGVCb29rO1xudmFyIGRlbGV0ZUJvb2tCeVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlQm9va0J5UmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rQnlSZWZlcmVuY2UgPSBkZWxldGVCb29rQnlSZWZlcmVuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVsZXRlU2hvcnRmb3JtID0gZXhwb3J0cy5nZXRTaG9ydGZvcm1zQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy51cGRhdGVTaG9ydGZvcm0gPSBleHBvcnRzLmNyZWF0ZVNob3J0Zm9ybSA9IHZvaWQgMDtcbnZhciBheGlvcyA9IHJlcXVpcmUoXCJheGlvc1wiKTtcbnZhciBPTkVBVVRIX0FQSSA9IHByb2Nlc3MuZW52Lk9ORUFVVEhfQVBJIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo0MDEwL2FwaVwiO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbnZhciBCb29rSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9oZWxwZXJcIikpO1xudmFyIENvbmNlcHRIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbmNlcHQvaGVscGVyXCIpKTtcbnZhciBOb3RlSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi9ub3RlL2hlbHBlclwiKSk7XG52YXIgR3B0dXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9ncHR1dGlsc1wiKSk7XG52YXIgcHJvbXB0XzEgPSByZXF1aXJlKFwiLi9wcm9tcHRcIik7XG52YXIgZ2V0Q29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZGJ1dGlsc1wiKS5nZXRDb2xsZWN0aW9uO1xudmFyIEFJX0FQSSA9IHByb2Nlc3MuZW52LkFJX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NTAwMy9hcGlcIjtcbnZhciBjcmVhdGVTaG9ydGZvcm0gPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIHBheWxvYWQsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vaywgbm90ZXMsIG5vdGVzTGlzdCwgY29uY2VwdHMsIGtleUluc2lnaHRzTGlzdCwgZ3B0UmVzcG9uc2VUZXh0LCBncHRSZXNwb25zZSwgbW9kZWwsIHNob3J0Zm9ybTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBCb29rSGVscGVyLmdldEJvb2tCeVJlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBOb3RlSGVscGVyLmdldE5vdGVCeUJvb2tyZWYoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBub3RlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBub3Rlc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBub3Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBub3Rlc0xpc3QucHVzaChpdGVtLmNvbnRlbnQpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIENvbmNlcHRIZWxwZXIuZ2V0Qm9va0NvbmNlcHRzQnlCb29rUmVmZXJlbmNlKHNwYWNlLCBib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY29uY2VwdHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAga2V5SW5zaWdodHNMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgY29uY2VwdHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlJbnNpZ2h0c0xpc3QucHVzaChpdGVtLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgR3B0dXRpbHMucHJlZGljdCgoMCwgcHJvbXB0XzEuZ2V0Qm9va1Nob3J0Rm9ybVByb21wdCkocGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLnR5cGUsIGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvciwgbm90ZXNMaXN0LCBrZXlJbnNpZ2h0c0xpc3QpKV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2VUZXh0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2UgPSBKU09OLnBhcnNlKGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLnNob3J0Zm9ybUNvbGxlY3Rpb24sIG1vZGVsXzEuc2hvcnRmb3JtU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXlsb2FkLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21UaXRsZTogcGF5bG9hZC5zZWN0aW9uVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21EZXNjcmlwdGlvbjogcGF5bG9hZC5zZWN0aW9uRGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogZ3B0UmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBzaG9ydGZvcm0gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBzaG9ydGZvcm1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuY3JlYXRlU2hvcnRmb3JtID0gY3JlYXRlU2hvcnRmb3JtO1xudmFyIHVwZGF0ZVNob3J0Zm9ybSA9IGZ1bmN0aW9uIChzcGFjZSwgcmVsb2FkLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZSwgc2hvcnRmb3JtUmVzcG9uc2UsIHNob3J0Zm9ybTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuc2hvcnRmb3JtQ29sbGVjdGlvbiwgbW9kZWxfMS5zaG9ydGZvcm1TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuX2lkKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoZGF0YS5faWQsIGRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwc2VydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKF9fYXNzaWduKHt9LCBkYXRhKSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0LCBtb2RlbC5maW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiByZXNwb25zZS5yZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHNob3J0Zm9ybVJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHNob3J0Zm9ybSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNob3J0Zm9ybVJlc3BvbnNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRmb3JtID0gc2hvcnRmb3JtUmVzcG9uc2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnRmb3JtOiBzaG9ydGZvcm0sXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlU2hvcnRmb3JtID0gdXBkYXRlU2hvcnRmb3JtO1xudmFyIGdldFNob3J0Zm9ybXNCeUJvb2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5zaG9ydGZvcm1Db2xsZWN0aW9uLCBtb2RlbF8xLnNob3J0Zm9ybVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgYm9va3JlZjogYm9va3JlZiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFNob3J0Zm9ybXNCeUJvb2tSZWZlcmVuY2UgPSBnZXRTaG9ydGZvcm1zQnlCb29rUmVmZXJlbmNlO1xudmFyIGRlbGV0ZVNob3J0Zm9ybSA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuc2hvcnRmb3JtQ29sbGVjdGlvbiwgbW9kZWxfMS5zaG9ydGZvcm1TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IF9pZDogX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IHNob3J0Zm9ybTogX2lkIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlU2hvcnRmb3JtID0gZGVsZXRlU2hvcnRmb3JtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNob3J0Zm9ybUNvbGxlY3Rpb24gPSBleHBvcnRzLnNob3J0Zm9ybVNjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgc2hvcnRmb3JtU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgY3VzdG9tVGl0bGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY3VzdG9tRGVzY3JpcHRpb246IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdHlwZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBib29rcmVmOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGNvbnRlbnQ6IHsgdHlwZTogSlNPTiB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlLCBzdHJpY3Q6IGZhbHNlLCBzdHJpY3RRdWVyeTogZmFsc2UgfSk7XG5leHBvcnRzLnNob3J0Zm9ybVNjaGVtYSA9IHNob3J0Zm9ybVNjaGVtYTtcbnZhciBzaG9ydGZvcm1Db2xsZWN0aW9uID0gXCJib29rLnNob3J0Zm9ybVwiO1xuZXhwb3J0cy5zaG9ydGZvcm1Db2xsZWN0aW9uID0gc2hvcnRmb3JtQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEJvb2tTaG9ydEZvcm1Qcm9tcHQgPSB2b2lkIDA7XG52YXIgSGFuZGxlYmFycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaGFuZGxlYmFyc1wiKSk7XG52YXIgbG9kYXNoXzEgPSByZXF1aXJlKFwibG9kYXNoXCIpO1xudmFyIF9NT0RFTF9OQU1FX0dQVDMgPSBcImdwdC0zLjUtdHVyYm9cIjtcbnZhciBfTU9ERUxfTkFNRV9HUFQ0ID0gXCJncHQtNG9cIjtcbnZhciBfTU9ERUxfTkFNRV9HUFQ0X01JTkkgPSBcImdwdC00by1taW5pXCI7XG52YXIgX01PREVMX05BTUUgPSBwcm9jZXNzLmVudi5DSEFUR1BUX01PREVMX05BTUUgfHwgXCJncHQtNG8tbWluaVwiO1xudmFyIGdldEJvb2tTaG9ydEZvcm1Qcm9tcHQgPSBmdW5jdGlvbiAodHlwZSwgYm9va05hbWUsIGF1dGhvck5hbWUsIG5vdGVzTGlzdCwga2V5SW5zaWdodHNMaXN0KSB7XG4gICAgdmFyIGtleUluc2lnaHRzID0ga2V5SW5zaWdodHNMaXN0LmpvaW4oXCIsIFwiKTtcbiAgICB2YXIgbm90ZXMgPSBub3Rlc0xpc3Quam9pbihcIiwgXCIpO1xuICAgIHZhciBwcm9tcHQgPSAoMCwgbG9kYXNoXzEuY2xvbmVEZWVwKShfU0hPUlRGT1JNX1BST01QVCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9tcHQubWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvbXB0Lm1lc3NhZ2VzW2ldLmNvbnRlbnQgPSBIYW5kbGViYXJzLmNvbXBpbGUocHJvbXB0Lm1lc3NhZ2VzW2ldLmNvbnRlbnQpKHtcbiAgICAgICAgICAgIGJvb2tOYW1lOiBib29rTmFtZSxcbiAgICAgICAgICAgIGF1dGhvck5hbWU6IGF1dGhvck5hbWUsXG4gICAgICAgICAgICBub3Rlczogbm90ZXMsXG4gICAgICAgICAgICBrZXlJbnNpZ2h0czoga2V5SW5zaWdodHMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhwcm9tcHQpO1xuICAgIHJldHVybiBwcm9tcHQ7XG59O1xuZXhwb3J0cy5nZXRCb29rU2hvcnRGb3JtUHJvbXB0ID0gZ2V0Qm9va1Nob3J0Rm9ybVByb21wdDtcbnZhciBfU0hPUlRGT1JNX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdZb3UgYXJlIGFuIEFJIGFzc2lzdGFudCB0YXNrZWQgd2l0aCBjcmVhdGluZyBhIGNvbXByZWhlbnNpdmUgYW5hbHlzaXMgb2YgYSBib29rIGluIEpTT04gZm9ybWF0LiBUaGUgb3V0cHV0IHNob3VsZCBiZSBkZXRhaWxlZCwgY292ZXJpbmcgYSB3b3JkIGNvdW50IG9mIDI1MDAtMzAwMCB3b3Jkcy4gVGhlIHN0cnVjdHVyZSBvZiB0aGUgSlNPTiBzaG91bGQgYmUgYXMgZm9sbG93czogXFxuXFxue1xcbiAgXCJib29rT3ZlcnZpZXdcIjoge1xcbiAgICBcIm92ZXJ2aWV3XCI6IFwic3RyaW5nXCIsXFxuICAgIFwiYXV0aG9ySW5mb1wiOiBcInN0cmluZ1wiXFxuICB9LFxcbiAgXCJrZXlJbnNpZ2h0c1wiOiBbXFxuICAgIHtcInRpdGxlXCI6IFwic3RyaW5nXCIsIFwiZGVzY3JpcHRpb25cIjogXCJodG1sXCJ9LFxcbiAgICB7XCJ0aXRsZVwiOiBcInN0cmluZ1wiLCBcImRlc2NyaXB0aW9uXCI6IFwiaHRtbFwifSxcXG4gICAgLi4uXFxuICBdXFxufS5cXG5cXG5JbnN0cnVjdGlvbnM6XFxuXFxuMS4gRm9yIHRoZSBcImJvb2tPdmVydmlld1wiOlxcbi0gUHJvdmlkZSBhIGRldGFpbGVkIHN1bW1hcnkgb2YgdGhlIGJvb2tcXCdzIG1haW4gcHJlbWlzZSBhbmQgc2lnbmlmaWNhbmNlICg0LTUgc2VudGVuY2VzKS5cXG4tIE1lbnRpb24gdGhlIGF1dGhvclxcJ3MgYmFja2dyb3VuZCBhbmQgZXhwZXJ0aXNlIHJlbGV2YW50IHRvIHRoZSBib29rXFwncyB0b3BpYyAoMi0zIHNlbnRlbmNlcykuXFxuXFxuMi4gRm9yIFwia2V5SW5zaWdodHNcIjpcXG4tIEVhY2gga2V5IGluc2lnaHQgc2hvdWxkIGhhdmUgYSB0aXRsZSBhbmQgYSBkZXRhaWxlZCBkZXNjcmlwdGlvbi5cXG4tIFRoZSBkZXNjcmlwdGlvbiBtdXN0IGJlIGluIEhUTUwgZm9ybWF0LCB3aXRoIGVhY2ggcGFyYWdyYXBoIGVuY2xvc2VkIHdpdGhpbiA8cD4gdGFncy4gT25seSA8cD4sIDxiPiwgYW5kIDxpPiB0YWdzIGFyZSBhbGxvd2VkLlxcbi0gVGhlIGRlc2NyaXB0aW9uIHNob3VsZCBpbmNsdWRlIGFuIGluLWRlcHRoIGV4cGxhbmF0aW9uIG9mIHRoZSBpbnNpZ2h0ICg0LTUgcGFyYWdyYXBocyksIHByYWN0aWNhbCBleGFtcGxlcyBvciBhcHBsaWNhdGlvbnMgKDItMyBwYXJhZ3JhcGhzKSwgYW5kIGFueSByZWxldmFudCBzdGF0aXN0aWNzIG9yIHJlc2VhcmNoIG1lbnRpb25lZCBpbiB0aGUgYm9vay5cXG5cXG5HdWlkZWxpbmVzOlxcbi0gRW5zdXJlIHRoYXQgdGhlIHRvdGFsIHdvcmQgY291bnQgb2YgdGhlIG91dHB1dCBpcyBiZXR3ZWVuIDI1MDAgYW5kIDMwMDAgd29yZHMuXFxuLSBFbnN1cmUgdGhhdCB0ZXh0IGlzIHBhcmFwaHJhc2VkIHRvIGF2b2lkIGRpcmVjdCBxdW90ZXMgZnJvbSB0aGUgYm9vay5cXG4tIEZvY3VzIG9uIHByZXNlbnRpbmcgY29udGVudCBpbiBhIHN0cnVjdHVyZWQgYW5kIGRldGFpbGVkIG1hbm5lciB3aXRoIHRob3JvdWdoIGV4cGxhbmF0aW9ucyBhbmQgZXhhbXBsZXMuJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiRW5zdXJlIHRoYXQgZWFjaCBrZXkgaW5zaWdodCBpcyBlbGFib3JhdGVkIHdpdGggbXVsdGlwbGUgcGFyYWdyYXBocyBhbmQgZGV0YWlsZWQgZXhwbGFuYXRpb25zLCB3aXRoIGVhY2ggcGFyYWdyYXBoIGVuY2xvc2VkIGluIDxwPiB0YWdzLiBGb3IgZWFjaCBrZXkgaW5zaWdodCBpbiB7e2tleUluc2lnaHRzfX0sIHByb3ZpZGUgYSBjb21wcmVoZW5zaXZlIGFuYWx5c2lzIHRoYXQgaW5jbHVkZXMgZXhhbXBsZXMsIGFwcGxpY2F0aW9ucywgYW5kIHN1cHBvcnRpbmcgZXZpZGVuY2UgdG8gbWVldCB0aGUgMjUwMC0zMDAwIHdvcmQgcmFuZ2UuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogXCJUaGUgYm9vayBpcyAne3tib29rTmFtZX19JyBieSB7e2F1dGhvck5hbWV9fS4gVGhlIGtleSBpbnNpZ2h0cyBhcmU6IHt7a2V5SW5zaWdodHN9fS5cIixcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIucHV0KFwiL2Jvb2svc2hvcnRmb3JtLzpzcGFjZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS51cGRhdGVTaG9ydGZvcm0pKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rL3Nob3J0Zm9ybS86c3BhY2UvOmJvb2tyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuY3JlYXRlU2hvcnRmb3JtKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL3Nob3J0Zm9ybS86c3BhY2UvOmJvb2tyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0U2hvcnRmb3Jtc0J5Qm9va1JlZmVyZW5jZSkpO1xuICAgIHJvdXRlci5kZWxldGUoXCIvYm9vay9zaG9ydGZvcm0vOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVTaG9ydGZvcm0pKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVTaG9ydGZvcm0gPSBleHBvcnRzLmdldFNob3J0Zm9ybXNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLnVwZGF0ZVNob3J0Zm9ybSA9IGV4cG9ydHMuY3JlYXRlU2hvcnRmb3JtID0gdm9pZCAwO1xudmFyIEhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJcIikpO1xudmFyIGNyZWF0ZVNob3J0Zm9ybSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBzaG9ydGZvcm07XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5jcmVhdGVTaG9ydGZvcm0ocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc2hvcnRmb3JtID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChzaG9ydGZvcm0pO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuY3JlYXRlU2hvcnRmb3JtID0gY3JlYXRlU2hvcnRmb3JtO1xudmFyIHVwZGF0ZVNob3J0Zm9ybSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBzaG9ydGZvcm07XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci51cGRhdGVTaG9ydGZvcm0ocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnF1ZXJ5LnJlbG9hZCwgcmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHNob3J0Zm9ybSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoc2hvcnRmb3JtKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZVNob3J0Zm9ybSA9IHVwZGF0ZVNob3J0Zm9ybTtcbnZhciBnZXRTaG9ydGZvcm1zQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHNob3J0Zm9ybTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldFNob3J0Zm9ybXNCeUJvb2tSZWZlcmVuY2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc2hvcnRmb3JtID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChzaG9ydGZvcm0pO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0U2hvcnRmb3Jtc0J5Qm9va1JlZmVyZW5jZSA9IGdldFNob3J0Zm9ybXNCeUJvb2tSZWZlcmVuY2U7XG52YXIgZGVsZXRlU2hvcnRmb3JtID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWxldGVTaG9ydGZvcm0ocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG91dGNvbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlU2hvcnRmb3JtID0gZGVsZXRlU2hvcnRmb3JtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRTdWJ0aGVtZXMgPSBleHBvcnRzLmRlbGV0ZUJvb2tTdWJ0aGVtZUJ5UmVmZXJlbmNlID0gZXhwb3J0cy5kZWxldGVCb29rU3VidGhlbWUgPSBleHBvcnRzLmdldEJvb2tTdWJ0aGVtZUJ5SWQgPSBleHBvcnRzLmdldEJvb2tTdWJ0aGVtZUJ5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0Qm9va1N1YnRoZW1lc0J5VGhlbWVSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tTdWJ0aGVtZXNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tTdWJ0aGVtZSA9IGV4cG9ydHMudXBkYXRlQm9va1N1YnRoZW1lID0gZXhwb3J0cy5jcmVhdGVCb29rU3VidGhlbWUgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9zZXF1ZW5jZS9zZXJ2aWNlXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBBSV9BUEkgPSBwcm9jZXNzLmVudi5BSV9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDMvYXBpXCI7XG52YXIgU0lNSUxBUklUWV9BTEdPUklUSE0gPSBcInNpbWlsYXJpdHlcIjtcbnZhciBjcmVhdGVCb29rU3VidGhlbWUgPSBmdW5jdGlvbiAoc3BhY2VfMSwgX2EsIHVzZXJJZF8xKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbc3BhY2VfMSwgX2EsIHVzZXJJZF8xXSwgdm9pZCAwLCBmdW5jdGlvbiAoc3BhY2UsIF9iLCB1c2VySWQpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgIHZhciBib29rU3VidGhlbWUgPSBfYi5ib29rU3VidGhlbWUsIG1ldGEgPSBfYi5tZXRhO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU3VidGhlbWVDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTdWJ0aGVtZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKF9fYXNzaWduKHt9LCBib29rU3VidGhlbWUpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVCb29rU3VidGhlbWUgPSBjcmVhdGVCb29rU3VidGhlbWU7XG52YXIgdXBkYXRlQm9va1N1YnRoZW1lID0gZnVuY3Rpb24gKHNwYWNlLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZSwgYm9va1N1YnRoZW1lUmVzcG9uc2UsIGJvb2tTdWJ0aGVtZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1N1YnRoZW1lQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU3VidGhlbWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuX2lkKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoZGF0YS5faWQsIGRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwc2VydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKF9fYXNzaWduKHt9LCBkYXRhKSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0LCBtb2RlbC5maW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiByZXNwb25zZS5yZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGJvb2tTdWJ0aGVtZVJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGJvb2tTdWJ0aGVtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGJvb2tTdWJ0aGVtZVJlc3BvbnNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYm9va1N1YnRoZW1lID0gYm9va1N1YnRoZW1lUmVzcG9uc2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va1N1YnRoZW1lOiBib29rU3VidGhlbWUsXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlQm9va1N1YnRoZW1lID0gdXBkYXRlQm9va1N1YnRoZW1lO1xudmFyIF9haV9wb3B1bGF0ZV9mb3Jfc3VidGhlbWUgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIHJlZmVyZW5jZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXJyXzE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYm9va3JlZiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zLmdldChcIlwiLmNvbmNhdChBSV9BUEksIFwiL1wiKS5jb25jYXQoU0lNSUxBUklUWV9BTEdPUklUSE0sIFwiL1wiKS5jb25jYXQoc3BhY2UsIFwiL3BvcHVsYXRlLXN1YnRoZW1lL1wiKS5jb25jYXQoYm9va3JlZiwgXCIvXCIpLmNvbmNhdChyZWZlcmVuY2UpLCB7fSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInBvcHVsYXRlZCBrZXl3b3JkcyBmb3IgXCIgKyBib29rcmVmICsgXCIsIFwiICsgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVycl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbnZhciBnZXRCb29rU3VidGhlbWUgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXM7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tTdWJ0aGVtZUNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1N1YnRoZW1lU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tTdWJ0aGVtZSA9IGdldEJvb2tTdWJ0aGVtZTtcbnZhciBnZXRCb29rU3VidGhlbWVzQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1N1YnRoZW1lQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU3VidGhlbWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rU3VidGhlbWVzQnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va1N1YnRoZW1lc0J5Qm9va1JlZmVyZW5jZTtcbnZhciBnZXRCb29rU3VidGhlbWVzQnlUaGVtZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgY29uY2VwdHJlZiwgdGhlbWVyZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU3VidGhlbWVDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTdWJ0aGVtZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYm9va3JlZiwgY29uY2VwdHJlZiwgdGhlbWVyZWYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYsIGNvbmNlcHRyZWY6IGNvbmNlcHRyZWYsIHRoZW1lcmVmOiB0aGVtZXJlZiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tTdWJ0aGVtZXNCeVRoZW1lUmVmZXJlbmNlID0gZ2V0Qm9va1N1YnRoZW1lc0J5VGhlbWVSZWZlcmVuY2U7XG52YXIgZ2V0Qm9va1N1YnRoZW1lQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmLCBzdWJ0aGVtZXJlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU3VidGhlbWVDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTdWJ0aGVtZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2tyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jZXB0cmVmOiBjb25jZXB0cmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBzdWJ0aGVtZXJlZixcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzcG9uc2VbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va1N1YnRoZW1lQnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va1N1YnRoZW1lQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldEJvb2tTdWJ0aGVtZUJ5SWQgPSBmdW5jdGlvbiAoc3BhY2UsIF9pZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1N1YnRoZW1lQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU3VidGhlbWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IF9pZDogX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tTdWJ0aGVtZUJ5SWQgPSBnZXRCb29rU3VidGhlbWVCeUlkO1xudmFyIGRlbGV0ZUJvb2tTdWJ0aGVtZSA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1N1YnRoZW1lQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rU3VidGhlbWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IF9pZDogX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IGJvb2tTdWJ0aGVtZTogX2lkIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQm9va1N1YnRoZW1lID0gZGVsZXRlQm9va1N1YnRoZW1lO1xudmFyIGRlbGV0ZUJvb2tTdWJ0aGVtZUJ5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rU3VidGhlbWVDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tTdWJ0aGVtZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgcmVmZXJlbmNlOiByZWZlcmVuY2UgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgYm9va1N1YnRoZW1lOiByZWZlcmVuY2UgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rU3VidGhlbWVCeVJlZmVyZW5jZSA9IGRlbGV0ZUJvb2tTdWJ0aGVtZUJ5UmVmZXJlbmNlO1xudmFyIGFkZFN1YnRoZW1lcyA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZiwgY29uY2VwdHJlZiwgc3VidGhlbWVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgX3BheWxvYWQsIGksIF9hLCBfYiwgX2M7XG4gICAgdmFyIF9kLCBfZSwgX2Y7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZykge1xuICAgICAgICBzd2l0Y2ggKF9nLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tTdWJ0aGVtZUNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1N1YnRoZW1lU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZCA9IFtdO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9nLmxhYmVsID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgc3VidGhlbWVzLmxlbmd0aCkpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBfcGF5bG9hZCkucHVzaDtcbiAgICAgICAgICAgICAgICBfZCA9IHt9O1xuICAgICAgICAgICAgICAgIF9lID0ge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvb2tyZWY6IGJvb2tyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jZXB0cmVmOiBjb25jZXB0cmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHN1YnRoZW1lc1tpXS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2MgPSBbX19hc3NpZ24oe30sIHN1YnRoZW1lc1tpXSldO1xuICAgICAgICAgICAgICAgIF9mID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgc2VydmljZV8xLm5leHR2YWwpKFwic3VidGhlbWVJZFwiLCBjb25jZXB0cmVmLCBzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9iLmFwcGx5KF9hLCBbKF9kLnVwZGF0ZU9uZSA9IChfZS51cGRhdGUgPSBfX2Fzc2lnbi5hcHBseSh2b2lkIDAsIF9jLmNvbmNhdChbKF9mLnJlZmVyZW5jZSA9IF9nLnNlbnQoKSwgX2YpXSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2UudXBzZXJ0ID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kKV0pO1xuICAgICAgICAgICAgICAgIF9nLmxhYmVsID0gMztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxXTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0LCBtb2RlbC5idWxrV3JpdGUoX3BheWxvYWQpXTtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyLCBfZy5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuYWRkU3VidGhlbWVzID0gYWRkU3VidGhlbWVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJvb2tTdWJ0aGVtZUNvbGxlY3Rpb24gPSBleHBvcnRzLmJvb2tTdWJ0aGVtZVNjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgYm9va1N1YnRoZW1lU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgbmFtZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBkZXNjcmlwdGlvbjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICByZWZlcmVuY2U6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgYm9va3JlZjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBjb25jZXB0cmVmOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHRoZW1lcmVmOiB7IHR5cGU6IFN0cmluZyB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlLCBzdHJpY3Q6IGZhbHNlLCBzdHJpY3RRdWVyeTogZmFsc2UgfSk7XG5leHBvcnRzLmJvb2tTdWJ0aGVtZVNjaGVtYSA9IGJvb2tTdWJ0aGVtZVNjaGVtYTtcbnZhciBib29rU3VidGhlbWVDb2xsZWN0aW9uID0gXCJib29rLnN1YnRoZW1lXCI7XG5leHBvcnRzLmJvb2tTdWJ0aGVtZUNvbGxlY3Rpb24gPSBib29rU3VidGhlbWVDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLnB1dChcIi9ib29rL3N1YnRoZW1lLzpzcGFjZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS51cGRhdGVCb29rU3VidGhlbWUpKTtcbiAgICByb3V0ZXIucG9zdChcIi9ib29rL3N1YnRoZW1lLzpzcGFjZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5jcmVhdGVCb29rU3VidGhlbWUpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL2Jvb2svc3VidGhlbWUvOnNwYWNlL2lkLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRCb29rU3VidGhlbWVCeUlkKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL3N1YnRoZW1lLzpzcGFjZS86Ym9va3JlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRCb29rU3VidGhlbWVzQnlCb29rUmVmZXJlbmNlKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL3N1YnRoZW1lLzpzcGFjZS86Ym9va3JlZi86Y29uY2VwdHJlZi86c3VidGhlbWVyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Qm9va1N1YnRoZW1lQnlCb29rUmVmZXJlbmNlKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ib29rL3N1YnRoZW1lLzpzcGFjZS86aWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZGVsZXRlQm9va1N1YnRoZW1lKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ib29rL3N1YnRoZW1lLzpzcGFjZS9yZWZlcmVuY2UvOnJlZmVyZW5jZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVCb29rU3VidGhlbWVCeVJlZmVyZW5jZSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlbGV0ZUJvb2tTdWJ0aGVtZUJ5UmVmZXJlbmNlID0gZXhwb3J0cy5kZWxldGVCb29rU3VidGhlbWUgPSBleHBvcnRzLmdldEJvb2tTdWJ0aGVtZUJ5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0Qm9va1N1YnRoZW1lc0J5Qm9va1JlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0Qm9va1N1YnRoZW1lQnlJZCA9IGV4cG9ydHMuZ2V0Qm9va1N1YnRoZW1lID0gZXhwb3J0cy51cGRhdGVCb29rU3VidGhlbWUgPSBleHBvcnRzLmNyZWF0ZUJvb2tTdWJ0aGVtZSA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBjcmVhdGVCb29rU3VidGhlbWUgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va1N1YnRoZW1lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuY3JlYXRlQm9va1N1YnRoZW1lKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5ib2R5LCB1c2VySWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rU3VidGhlbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvb2tTdWJ0aGVtZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVCb29rU3VidGhlbWUgPSBjcmVhdGVCb29rU3VidGhlbWU7XG52YXIgdXBkYXRlQm9va1N1YnRoZW1lID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tTdWJ0aGVtZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLnVwZGF0ZUJvb2tTdWJ0aGVtZShyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va1N1YnRoZW1lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rU3VidGhlbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlQm9va1N1YnRoZW1lID0gdXBkYXRlQm9va1N1YnRoZW1lO1xudmFyIGdldEJvb2tTdWJ0aGVtZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rU3VidGhlbWVMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va1N1YnRoZW1lKHJlcS5wYXJhbXMuc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rU3VidGhlbWVMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rU3VidGhlbWVMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tTdWJ0aGVtZSA9IGdldEJvb2tTdWJ0aGVtZTtcbnZhciBnZXRCb29rU3VidGhlbWVCeUlkID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tTdWJ0aGVtZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEJvb2tTdWJ0aGVtZUJ5SWQocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tTdWJ0aGVtZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va1N1YnRoZW1lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tTdWJ0aGVtZUJ5SWQgPSBnZXRCb29rU3VidGhlbWVCeUlkO1xudmFyIGdldEJvb2tTdWJ0aGVtZXNCeUJvb2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va1N1YnRoZW1lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va1N1YnRoZW1lc0J5Qm9va1JlZmVyZW5jZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rU3VidGhlbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvb2tTdWJ0aGVtZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rU3VidGhlbWVzQnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va1N1YnRoZW1lc0J5Qm9va1JlZmVyZW5jZTtcbnZhciBnZXRCb29rU3VidGhlbWVCeUJvb2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va1N1YnRoZW1lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Qm9va1N1YnRoZW1lQnlCb29rUmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZiwgcmVxLnBhcmFtcy5jb25jZXB0cmVmLCByZXEucGFyYW1zLnN1YnRoZW1lcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va1N1YnRoZW1lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rU3VidGhlbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va1N1YnRoZW1lQnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va1N1YnRoZW1lQnlCb29rUmVmZXJlbmNlO1xudmFyIGRlbGV0ZUJvb2tTdWJ0aGVtZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlQm9va1N1YnRoZW1lKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUJvb2tTdWJ0aGVtZSA9IGRlbGV0ZUJvb2tTdWJ0aGVtZTtcbnZhciBkZWxldGVCb29rU3VidGhlbWVCeVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlQm9va1N1YnRoZW1lQnlSZWZlcmVuY2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5yZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUJvb2tTdWJ0aGVtZUJ5UmVmZXJlbmNlID0gZGVsZXRlQm9va1N1YnRoZW1lQnlSZWZlcmVuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZFRoZW1lcyA9IGV4cG9ydHMuZGVsZXRlQm9va1RoZW1lQnlSZWZlcmVuY2UgPSBleHBvcnRzLmRlbGV0ZUJvb2tUaGVtZSA9IGV4cG9ydHMuZ2V0Qm9va1RoZW1lQnlJZCA9IGV4cG9ydHMuZ2V0Qm9va1RoZW1lQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy5nZXRCb29rVGhlbWVzQnlDb25jZXB0UmVmZXJlbmNlID0gZXhwb3J0cy5nZXRCb29rVGhlbWVzQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy5nZXRCb29rVGhlbWUgPSBleHBvcnRzLnVwZGF0ZUJvb2tUaGVtZSA9IGV4cG9ydHMuY3JlYXRlQm9va1RoZW1lID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vLi4vc2VxdWVuY2Uvc2VydmljZVwiKTtcbnZhciBtb2RlbF8yID0gcmVxdWlyZShcIi4uL3N1YnRoZW1lL21vZGVsXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBBSV9BUEkgPSBwcm9jZXNzLmVudi5BSV9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDMvYXBpXCI7XG52YXIgU0lNSUxBUklUWV9BTEdPUklUSE0gPSBcInNpbWlsYXJpdHlcIjtcbnZhciBjcmVhdGVCb29rVGhlbWUgPSBmdW5jdGlvbiAoc3BhY2VfMSwgX2EsIHVzZXJJZF8xKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbc3BhY2VfMSwgX2EsIHVzZXJJZF8xXSwgdm9pZCAwLCBmdW5jdGlvbiAoc3BhY2UsIF9iLCB1c2VySWQpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgIHZhciBib29rVGhlbWUgPSBfYi5ib29rVGhlbWUsIG1ldGEgPSBfYi5tZXRhO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rVGhlbWVDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tUaGVtZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKF9fYXNzaWduKHt9LCBib29rVGhlbWUpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVCb29rVGhlbWUgPSBjcmVhdGVCb29rVGhlbWU7XG52YXIgdXBkYXRlQm9va1RoZW1lID0gZnVuY3Rpb24gKHNwYWNlLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZSwgYm9va1RoZW1lUmVzcG9uc2UsIGJvb2tUaGVtZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1RoZW1lQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rVGhlbWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuX2lkKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoZGF0YS5faWQsIGRhdGEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwc2VydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKF9fYXNzaWduKHt9LCBkYXRhKSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFs0LCBtb2RlbC5maW5kKHtcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiByZXNwb25zZS5yZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGJvb2tUaGVtZVJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGJvb2tUaGVtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGJvb2tUaGVtZVJlc3BvbnNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYm9va1RoZW1lID0gYm9va1RoZW1lUmVzcG9uc2VbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va1RoZW1lOiBib29rVGhlbWUsXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlQm9va1RoZW1lID0gdXBkYXRlQm9va1RoZW1lO1xudmFyIF9haV9wb3B1bGF0ZV9mb3JfdGhlbWUgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIHJlZmVyZW5jZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXJyXzE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYm9va3JlZiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zLmdldChcIlwiLmNvbmNhdChBSV9BUEksIFwiL1wiKS5jb25jYXQoU0lNSUxBUklUWV9BTEdPUklUSE0sIFwiL1wiKS5jb25jYXQoc3BhY2UsIFwiL3BvcHVsYXRlLXRoZW1lL1wiKS5jb25jYXQoYm9va3JlZiwgXCIvXCIpLmNvbmNhdChyZWZlcmVuY2UpLCB7fSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInBvcHVsYXRlZCBrZXl3b3JkcyBmb3IgXCIgKyBib29rcmVmICsgXCIsIFwiICsgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVycl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbnZhciBnZXRCb29rVGhlbWUgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXM7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tUaGVtZUNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1RoZW1lU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tUaGVtZSA9IGdldEJvb2tUaGVtZTtcbnZhciBnZXRCb29rVGhlbWVzQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1RoZW1lQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rVGhlbWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rVGhlbWVzQnlCb29rUmVmZXJlbmNlID0gZ2V0Qm9va1RoZW1lc0J5Qm9va1JlZmVyZW5jZTtcbnZhciBnZXRCb29rVGhlbWVzQnlDb25jZXB0UmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuYm9va1RoZW1lQ29sbGVjdGlvbiwgbW9kZWxfMS5ib29rVGhlbWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGJvb2tyZWY6IGJvb2tyZWYsIGNvbmNlcHRyZWY6IGNvbmNlcHRyZWYgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rVGhlbWVzQnlDb25jZXB0UmVmZXJlbmNlID0gZ2V0Qm9va1RoZW1lc0J5Q29uY2VwdFJlZmVyZW5jZTtcbnZhciBnZXRCb29rVGhlbWVCeUJvb2tSZWZlcmVuY2UgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIGNvbmNlcHRyZWYsIHRoZW1lcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tUaGVtZUNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1RoZW1lU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNlcHRyZWY6IGNvbmNlcHRyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IHRoZW1lcmVmLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZVswXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rVGhlbWVCeUJvb2tSZWZlcmVuY2UgPSBnZXRCb29rVGhlbWVCeUJvb2tSZWZlcmVuY2U7XG52YXIgZ2V0Qm9va1RoZW1lQnlJZCA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rVGhlbWVDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tUaGVtZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNbMF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va1RoZW1lQnlJZCA9IGdldEJvb2tUaGVtZUJ5SWQ7XG52YXIgZGVsZXRlQm9va1RoZW1lID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ib29rVGhlbWVDb2xsZWN0aW9uLCBtb2RlbF8xLmJvb2tUaGVtZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgYm9va1RoZW1lOiBfaWQgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rVGhlbWUgPSBkZWxldGVCb29rVGhlbWU7XG52YXIgZGVsZXRlQm9va1RoZW1lQnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAoc3BhY2UsIHJlZmVyZW5jZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tUaGVtZUNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1RoZW1lU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyByZWZlcmVuY2U6IHJlZmVyZW5jZSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBib29rVGhlbWU6IHJlZmVyZW5jZSB9XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUJvb2tUaGVtZUJ5UmVmZXJlbmNlID0gZGVsZXRlQm9va1RoZW1lQnlSZWZlcmVuY2U7XG52YXIgYWRkVGhlbWVzID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmLCB0aGVtZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCBzdWJUaGVtZU1vZGVsLCBfcGF5bG9hZCwgX3BheWxvYWRTdWJUaGVtZXMsIGksIHJlZmVyZW5jZSwgaiwgX2EsIF9iLCBfYztcbiAgICB2YXIgX2QsIF9lLCBfZjtcbiAgICB2YXIgX2c7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfaCkge1xuICAgICAgICBzd2l0Y2ggKF9oLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmJvb2tUaGVtZUNvbGxlY3Rpb24sIG1vZGVsXzEuYm9va1RoZW1lU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBzdWJUaGVtZU1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMi5ib29rU3VidGhlbWVDb2xsZWN0aW9uLCBtb2RlbF8yLmJvb2tTdWJ0aGVtZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgX3BheWxvYWQgPSBbXTtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZFN1YlRoZW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9oLmxhYmVsID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgdGhlbWVzLmxlbmd0aCkpIHJldHVybiBbMywgN107XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgc2VydmljZV8xLm5leHR2YWwpKFwidGhlbWVJZFwiLCBjb25jZXB0cmVmLCBzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9oLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlT25lOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNlcHRyZWY6IGNvbmNlcHRyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRoZW1lc1tpXS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGVtZXNbaV0pLCB7IHJlZmVyZW5jZTogcmVmZXJlbmNlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBzZXJ0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgICAgIF9oLmxhYmVsID0gMztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoIShqIDwgKChfZyA9IHRoZW1lc1tpXS5zdWJUaGVtZXMpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5sZW5ndGgpKSkgcmV0dXJuIFszLCA2XTtcbiAgICAgICAgICAgICAgICBfYiA9IChfYSA9IF9wYXlsb2FkU3ViVGhlbWVzKS5wdXNoO1xuICAgICAgICAgICAgICAgIF9kID0ge307XG4gICAgICAgICAgICAgICAgX2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNlcHRyZWY6IGNvbmNlcHRyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVtZXJlZjogcmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRoZW1lc1tpXS50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX2MgPSBbX19hc3NpZ24oe30sIHRoZW1lc1tpXS5zdWJUaGVtZXNbal0pXTtcbiAgICAgICAgICAgICAgICBfZiA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIHNlcnZpY2VfMS5uZXh0dmFsKShcInN1YlRoZW1lSWRcIiwgXCJcIi5jb25jYXQoYm9va3JlZiwgXCJfXCIpLmNvbmNhdChjb25jZXB0cmVmLCBcIl9cIikuY29uY2F0KHJlZmVyZW5jZSksIHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgX2IuYXBwbHkoX2EsIFsoX2QudXBkYXRlT25lID0gKF9lLnVwZGF0ZSA9IF9fYXNzaWduLmFwcGx5KHZvaWQgMCwgX2MuY29uY2F0KFsoX2YucmVmZXJlbmNlID0gX2guc2VudCgpLCBfZildKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfZS51cHNlcnQgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2QpXSk7XG4gICAgICAgICAgICAgICAgX2gubGFiZWwgPSA1O1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzQsIHN1YlRoZW1lTW9kZWwuYnVsa1dyaXRlKF9wYXlsb2FkU3ViVGhlbWVzKV07XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2guc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuYnVsa1dyaXRlKF9wYXlsb2FkKV07XG4gICAgICAgICAgICBjYXNlIDk6IHJldHVybiBbMiwgX2guc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmFkZFRoZW1lcyA9IGFkZFRoZW1lcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ib29rVGhlbWVDb2xsZWN0aW9uID0gZXhwb3J0cy5ib29rVGhlbWVTY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIGJvb2tUaGVtZVNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgZGVzY3JpcHRpb246IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgcmVmZXJlbmNlOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGJvb2tyZWY6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY29uY2VwdHJlZjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBzdWJUaGVtZXM6IHsgdHlwZTogQXJyYXkgfSxcbn0sIHsgdGltZXN0YW1wczogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgc3RyaWN0UXVlcnk6IGZhbHNlIH0pO1xuZXhwb3J0cy5ib29rVGhlbWVTY2hlbWEgPSBib29rVGhlbWVTY2hlbWE7XG52YXIgYm9va1RoZW1lQ29sbGVjdGlvbiA9IFwiYm9vay50aGVtZVwiO1xuZXhwb3J0cy5ib29rVGhlbWVDb2xsZWN0aW9uID0gYm9va1RoZW1lQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oYW5kbGVyXCIpO1xudmFyIG1pZGRsZXdhcmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWlkZGxld2FyZXNcIik7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5wdXQoXCIvYm9vay90aGVtZS86c3BhY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEudXBkYXRlQm9va1RoZW1lKSk7XG4gICAgcm91dGVyLnBvc3QoXCIvYm9vay90aGVtZS86c3BhY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuY3JlYXRlQm9va1RoZW1lKSk7XG4gICAgcm91dGVyLmdldChcIi9ib29rL3RoZW1lLzpzcGFjZS9pZC86aWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Qm9va1RoZW1lQnlJZCkpO1xuICAgIHJvdXRlci5nZXQoXCIvYm9vay90aGVtZS86c3BhY2UvOmJvb2tyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Qm9va1RoZW1lc0J5Qm9va1JlZmVyZW5jZSkpO1xuICAgIHJvdXRlci5nZXQoXCIvYm9vay90aGVtZS86c3BhY2UvOmJvb2tyZWYvOmNvbmNlcHRyZWZcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Qm9va1RoZW1lc0J5Q29uY2VwdFJlZmVyZW5jZSkpO1xuICAgIHJvdXRlci5nZXQoXCIvYm9vay90aGVtZS86c3BhY2UvOmJvb2tyZWYvOmNvbmNlcHRyZWYvOnRoZW1lcmVmXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldEJvb2tUaGVtZUJ5Qm9va1JlZmVyZW5jZSkpO1xuICAgIHJvdXRlci5kZWxldGUoXCIvYm9vay90aGVtZS86c3BhY2UvOmlkXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmRlbGV0ZUJvb2tUaGVtZSkpO1xuICAgIHJvdXRlci5kZWxldGUoXCIvYm9vay90aGVtZS86c3BhY2UvcmVmZXJlbmNlLzpyZWZlcmVuY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZGVsZXRlQm9va1RoZW1lQnlSZWZlcmVuY2UpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVCb29rVGhlbWVCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZGVsZXRlQm9va1RoZW1lID0gZXhwb3J0cy5nZXRCb29rVGhlbWVCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tUaGVtZXNCeUNvbmNlcHRSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tUaGVtZXNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLmdldEJvb2tUaGVtZUJ5SWQgPSBleHBvcnRzLmdldEJvb2tUaGVtZSA9IGV4cG9ydHMudXBkYXRlQm9va1RoZW1lID0gZXhwb3J0cy5jcmVhdGVCb29rVGhlbWUgPSB2b2lkIDA7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgY3JlYXRlQm9va1RoZW1lID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tUaGVtZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmNyZWF0ZUJvb2tUaGVtZShyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va1RoZW1lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rVGhlbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuY3JlYXRlQm9va1RoZW1lID0gY3JlYXRlQm9va1RoZW1lO1xudmFyIHVwZGF0ZUJvb2tUaGVtZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rVGhlbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci51cGRhdGVCb29rVGhlbWUocmVxLnBhcmFtcy5zcGFjZSwgcmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tUaGVtZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va1RoZW1lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZUJvb2tUaGVtZSA9IHVwZGF0ZUJvb2tUaGVtZTtcbnZhciBnZXRCb29rVGhlbWUgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgYm9va1RoZW1lTGlzdDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEJvb2tUaGVtZShyZXEucGFyYW1zLnNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va1RoZW1lTGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va1RoZW1lTGlzdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rVGhlbWUgPSBnZXRCb29rVGhlbWU7XG52YXIgZ2V0Qm9va1RoZW1lQnlJZCA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rVGhlbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRCb29rVGhlbWVCeUlkKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBib29rVGhlbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvb2tUaGVtZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCb29rVGhlbWVCeUlkID0gZ2V0Qm9va1RoZW1lQnlJZDtcbnZhciBnZXRCb29rVGhlbWVzQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tUaGVtZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEJvb2tUaGVtZXNCeUJvb2tSZWZlcmVuY2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va1RoZW1lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rVGhlbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va1RoZW1lc0J5Qm9va1JlZmVyZW5jZSA9IGdldEJvb2tUaGVtZXNCeUJvb2tSZWZlcmVuY2U7XG52YXIgZ2V0Qm9va1RoZW1lc0J5Q29uY2VwdFJlZmVyZW5jZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBib29rVGhlbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRCb29rVGhlbWVzQnlDb25jZXB0UmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZiwgcmVxLnBhcmFtcy5jb25jZXB0cmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYm9va1RoZW1lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChib29rVGhlbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Qm9va1RoZW1lc0J5Q29uY2VwdFJlZmVyZW5jZSA9IGdldEJvb2tUaGVtZXNCeUNvbmNlcHRSZWZlcmVuY2U7XG52YXIgZ2V0Qm9va1RoZW1lQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGJvb2tUaGVtZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldEJvb2tUaGVtZUJ5Qm9va1JlZmVyZW5jZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmJvb2tyZWYsIHJlcS5wYXJhbXMuY29uY2VwdHJlZiwgcmVxLnBhcmFtcy50aGVtZXJlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2tUaGVtZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoYm9va1RoZW1lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEJvb2tUaGVtZUJ5Qm9va1JlZmVyZW5jZSA9IGdldEJvb2tUaGVtZUJ5Qm9va1JlZmVyZW5jZTtcbnZhciBkZWxldGVCb29rVGhlbWUgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgb3V0Y29tZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZUJvb2tUaGVtZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmlkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rVGhlbWUgPSBkZWxldGVCb29rVGhlbWU7XG52YXIgZGVsZXRlQm9va1RoZW1lQnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgb3V0Y29tZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZUJvb2tUaGVtZUJ5UmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVCb29rVGhlbWVCeVJlZmVyZW5jZSA9IGRlbGV0ZUJvb2tUaGVtZUJ5UmVmZXJlbmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVsZXRlVGhlbWVEZXRhaWwgPSBleHBvcnRzLmdldFRoZW1lRGV0YWlsc0J5Qm9va1JlZmVyZW5jZVNob3J0Zm9ybSA9IGV4cG9ydHMuZ2V0VGhlbWVEZXRhaWxzQnlCb29rUmVmZXJlbmNlID0gZXhwb3J0cy51cGRhdGVUaGVtZURldGFpbCA9IGV4cG9ydHMuY3JlYXRlVGhlbWVEZXRhaWwgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgQm9va0hlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vaGVscGVyXCIpKTtcbnZhciBUaGVtZUhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdGhlbWUvaGVscGVyXCIpKTtcbnZhciBTdWJUaGVtZUhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vc3VidGhlbWUvaGVscGVyXCIpKTtcbnZhciBFeHRyYWN0SGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9leHRyYWN0L2hlbHBlclwiKSk7XG52YXIgTm90ZUhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vbm90ZS9oZWxwZXJcIikpO1xudmFyIEdwdHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZ3B0dXRpbHNcIikpO1xudmFyIHByb21wdF8xID0gcmVxdWlyZShcIi4vcHJvbXB0XCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBBSV9BUEkgPSBwcm9jZXNzLmVudi5BSV9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDMvYXBpXCI7XG52YXIgY3JlYXRlVGhlbWVEZXRhaWwgPSBmdW5jdGlvbiAoc3BhY2UsIGJvb2tyZWYsIGNvbmNlcHRyZWYsIHRoZW1lcmVmLCBwYXlsb2FkLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJvb2ssIG1vZGVsLCBjb250ZXh0TGlzdCwgZ3B0UmVzcG9uc2VUZXh0LCBjb250ZW50LCB0aGVtZURldGFpbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIShwYXlsb2FkLnR5cGUgPT09IFwic3VtbWFyeVwiKSkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9jcmVhdGVTdW1tYXJ5KHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmLCB0aGVtZXJlZildO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCwgQm9va0hlbHBlci5nZXRCb29rQnlSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBib29rID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS50aGVtZURldGFpbENvbGxlY3Rpb24sIG1vZGVsXzEudGhlbWVEZXRhaWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2VwdHJlZjogY29uY2VwdHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lcmVmOiB0aGVtZXJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY29udGV4dExpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHRMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHt9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBHcHR1dGlscy5wcmVkaWN0KCgwLCBwcm9tcHRfMS5nZXRTZWNvbmRhcnlTZWN0aW9uUHJvbXB0KShwYXlsb2FkLnR5cGUsIGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvciwgY29udGV4dExpc3RbMF0uY29udGVudCkpXTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZVRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IF9wcm9jZXNzQWlSZXNwb25zZShwYXlsb2FkLnR5cGUsIGdwdFJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC51cGRhdGVPbmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9va3JlZjogYm9va3JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNlcHRyZWY6IGNvbmNlcHRyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVtZXJlZjogdGhlbWVyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXlsb2FkLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21UaXRsZTogcGF5bG9hZC5zZWN0aW9uVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGVzY3JpcHRpb246IHBheWxvYWQuc2VjdGlvbkRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB7IHVwc2VydDogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgdGhlbWVEZXRhaWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGVtZURldGFpbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVUaGVtZURldGFpbCA9IGNyZWF0ZVRoZW1lRGV0YWlsO1xudmFyIF9jcmVhdGVTdW1tYXJ5ID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmLCB0aGVtZXJlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vaywgdGhlbWUsIG5vdGVzLCBub3Rlc0xpc3QsIGV4dHJhY3RzLCBzdWJUaGVtZXNMaXN0LCBzdWJUaGVtZXMsIGdwdFJlc3BvbnNlVGV4dCwgY29udGVudCwgbW9kZWwsIHRoZW1lRGV0YWlsLCBzaG9ydGVyU3VtbWFyeTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBCb29rSGVscGVyLmdldEJvb2tCeVJlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBUaGVtZUhlbHBlci5nZXRCb29rVGhlbWVCeUJvb2tSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYsIGNvbmNlcHRyZWYsIHRoZW1lcmVmKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhlbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBOb3RlSGVscGVyLmdldE5vdGVCeUJvb2tyZWYoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBub3RlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBub3Rlc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBfZmlsdGVyQW5kU29ydERvbWFpbkJ5S2V5d29yZE92ZXJsYXAodGhlbWUua2V5d29yZHMsIG5vdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBub3Rlc0xpc3QucHVzaChpdGVtLmNvbnRlbnQpOyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEV4dHJhY3RIZWxwZXIuZ2V0RXh0cmFjdENodW5rc0J5Qm9va1JlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGV4dHJhY3RzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9maWx0ZXJBbmRTb3J0RG9tYWluQnlLZXl3b3JkT3ZlcmxhcCh0aGVtZS5rZXl3b3JkcywgZXh0cmFjdHMpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIG5vdGVzTGlzdC5wdXNoKGl0ZW0uc3VtbWFyeSk7IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgU3ViVGhlbWVIZWxwZXIuZ2V0Qm9va1N1YnRoZW1lc0J5VGhlbWVSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYsIGNvbmNlcHRyZWYsIHRoZW1lcmVmKV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgc3ViVGhlbWVzTGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBzdWJUaGVtZXMgPSBfZm9ybWF0VGhlbWVzRm9yUHJvbXB0KHN1YlRoZW1lc0xpc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgR3B0dXRpbHMucHJlZGljdCgoMCwgcHJvbXB0XzEuZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQpKGJvb2sudGl0bGUsIGJvb2sucHJpbWFyeUF1dGhvciwgdGhlbWUudGl0bGUsIHRoZW1lLmRlc2NyaXB0aW9uLCBzdWJUaGVtZXMsIG5vdGVzTGlzdCkpXTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZVRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IF9wcm9jZXNzQWlSZXNwb25zZShcInN1bW1hcnlcIiwgZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEudGhlbWVEZXRhaWxDb2xsZWN0aW9uLCBtb2RlbF8xLnRoZW1lRGV0YWlsU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLnVwZGF0ZU9uZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2VwdHJlZjogY29uY2VwdHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lcmVmOiB0aGVtZXJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3VtbWFyeVwiLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgdXBzZXJ0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICB0aGVtZURldGFpbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9nZW5lcmF0ZVNob3J0ZXJTdW1tYXJ5Rm9yQ29udGV4dChib29rLnRpdGxlLCBib29rLnByaW1hcnlBdXRob3IsIGNvbnRlbnQpXTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBzaG9ydGVyU3VtbWFyeSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLnVwZGF0ZU9uZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib29rcmVmOiBib29rcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2VwdHJlZjogY29uY2VwdHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lcmVmOiB0aGVtZXJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY29udGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc2hvcnRlclN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB7IHVwc2VydDogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhlbWVEZXRhaWxdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbnZhciBfZ2VuZXJhdGVTaG9ydGVyU3VtbWFyeUZvckNvbnRleHQgPSBmdW5jdGlvbiAoYm9va05hbWUsIGF1dGhvck5hbWUsIGNvbnRlbnQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdwdFJlc3BvbnNlVGV4dDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBHcHR1dGlscy5wcmVkaWN0KCgwLCBwcm9tcHRfMS5nZXRTZWNvbmRhcnlTZWN0aW9uUHJvbXB0KShcImNvbnRleHRcIiwgYm9va05hbWUsIGF1dGhvck5hbWUsIGNvbnRlbnQpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2VUZXh0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZ3B0UmVzcG9uc2VUZXh0XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgX3Byb2Nlc3NBaVJlc3BvbnNlID0gZnVuY3Rpb24gKHR5cGUsIHRleHQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgdmFyIGh0bWxTdHJpbmcgPSBcIlwiO1xuICAgIHZhciBkYXRhID0gdGV4dDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN1bW1hcnlcIjpcbiAgICAgICAgY2FzZSBcImFsdGVybmF0ZV90YWtlc1wiOlxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN1bW1hcnlcIjpcbiAgICAgICAgICAgIGh0bWxTdHJpbmcgPSBkYXRhLnRoZW1lRXhwbG9yYXRpb247XG4gICAgICAgICAgICAoX2EgPSBkYXRhLnN1YlRoZW1lcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goZnVuY3Rpb24gKHN1YlRoZW1lKSB7XG4gICAgICAgICAgICAgICAgaHRtbFN0cmluZyArPSBcIjxoND5cIi5jb25jYXQoc3ViVGhlbWUudGl0bGUsIFwiPC9oND5cIikuY29uY2F0KHN1YlRoZW1lLmV4cGxvcmF0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbHRlcm5hdGVfdGFrZXNcIjpcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGh0bWxTdHJpbmcgKz0gXCI8cD48Yj5cIi5jb25jYXQoaXRlbS5yZWZlcmVuY2UuYXV0aG9yLCBcIjwvYj4gaW4gPGk+XCIpLmNvbmNhdChpdGVtLnJlZmVyZW5jZS5ib29rLCBcIjwvaT48L3A+XCIpLmNvbmNhdChpdGVtLmNvbnRlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGh0bWxTdHJpbmcgPSBkYXRhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBodG1sU3RyaW5nO1xufTtcbmZ1bmN0aW9uIF9mb3JtYXRUaGVtZXNGb3JQcm9tcHQodGhlbWVzKSB7XG4gICAgcmV0dXJuIHRoZW1lc1xuICAgICAgICAubWFwKGZ1bmN0aW9uICh0aGVtZSkgeyByZXR1cm4gXCI8c3Ryb25nPlwiLmNvbmNhdCh0aGVtZS50aXRsZSwgXCI6PC9zdHJvbmc+IFwiKS5jb25jYXQodGhlbWUuZGVzY3JpcHRpb24pOyB9KVxuICAgICAgICAuam9pbihcIixcIik7XG59XG52YXIgX2ZpbHRlckFuZFNvcnREb21haW5CeUtleXdvcmRPdmVybGFwID0gZnVuY3Rpb24gKGlucHV0S2V5d29yZHMsIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGl0ZW0ua2V5d29yZHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGZ1bmN0aW9uIChrZXl3b3JkKSB7IHJldHVybiBpbnB1dEtleXdvcmRzID09PSBudWxsIHx8IGlucHV0S2V5d29yZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGlucHV0S2V5d29yZHMuaW5jbHVkZXMoa2V5d29yZCk7IH0pOyB9KVxuICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgb3ZlcmxhcEEgPSAoX2EgPSBhLmtleXdvcmRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmlsdGVyKGZ1bmN0aW9uIChrZXl3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRLZXl3b3Jkcy5pbmNsdWRlcyhrZXl3b3JkKTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICB2YXIgb3ZlcmxhcEIgPSAoX2IgPSBiLmtleXdvcmRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmlsdGVyKGZ1bmN0aW9uIChrZXl3b3JkKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRLZXl3b3Jkcy5pbmNsdWRlcyhrZXl3b3JkKTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gb3ZlcmxhcEIgLSBvdmVybGFwQTtcbiAgICB9KTtcbn07XG52YXIgdXBkYXRlVGhlbWVEZXRhaWwgPSBmdW5jdGlvbiAoc3BhY2UsIGlkLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEudGhlbWVEZXRhaWxDb2xsZWN0aW9uLCBtb2RlbF8xLnRoZW1lRGV0YWlsU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShpZCwgZGF0YSwge30pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3BvbnNlXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZVRoZW1lRGV0YWlsID0gdXBkYXRlVGhlbWVEZXRhaWw7XG52YXIgZ2V0VGhlbWVEZXRhaWxzQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmLCBjb25jZXB0cmVmLCB0aGVtZXJlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLnRoZW1lRGV0YWlsQ29sbGVjdGlvbiwgbW9kZWxfMS50aGVtZURldGFpbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgYm9va3JlZjogYm9va3JlZiwgY29uY2VwdHJlZjogY29uY2VwdHJlZiwgdGhlbWVyZWY6IHRoZW1lcmVmIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0VGhlbWVEZXRhaWxzQnlCb29rUmVmZXJlbmNlID0gZ2V0VGhlbWVEZXRhaWxzQnlCb29rUmVmZXJlbmNlO1xudmFyIGdldFRoZW1lRGV0YWlsc0J5Qm9va1JlZmVyZW5jZVNob3J0Zm9ybSA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLnRoZW1lRGV0YWlsQ29sbGVjdGlvbiwgbW9kZWxfMS50aGVtZURldGFpbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgYm9va3JlZjogYm9va3JlZiwgdHlwZTogXCJfc2hvcnRmb3JtXCIgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRUaGVtZURldGFpbHNCeUJvb2tSZWZlcmVuY2VTaG9ydGZvcm0gPSBnZXRUaGVtZURldGFpbHNCeUJvb2tSZWZlcmVuY2VTaG9ydGZvcm07XG52YXIgZGVsZXRlVGhlbWVEZXRhaWwgPSBmdW5jdGlvbiAoc3BhY2UsIF9pZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLnRoZW1lRGV0YWlsQ29sbGVjdGlvbiwgbW9kZWxfMS50aGVtZURldGFpbFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgdGhlbWVEZXRhaWw6IF9pZCB9XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZVRoZW1lRGV0YWlsID0gZGVsZXRlVGhlbWVEZXRhaWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGhlbWVEZXRhaWxDb2xsZWN0aW9uID0gZXhwb3J0cy50aGVtZURldGFpbFNjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgdGhlbWVEZXRhaWxTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICBjdXN0b21UaXRsZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBjdXN0b21EZXNjcmlwdGlvbjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB0eXBlOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHRoZW1lcmVmOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGJvb2tyZWY6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY29udGVudDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBjb250ZW50T2JqZWN0OiB7IHR5cGU6IEpTT04gfSxcbn0sIHsgdGltZXN0YW1wczogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgc3RyaWN0UXVlcnk6IGZhbHNlIH0pO1xuZXhwb3J0cy50aGVtZURldGFpbFNjaGVtYSA9IHRoZW1lRGV0YWlsU2NoZW1hO1xudmFyIHRoZW1lRGV0YWlsQ29sbGVjdGlvbiA9IFwiYm9vay50aGVtZWRldGFpbFwiO1xuZXhwb3J0cy50aGVtZURldGFpbENvbGxlY3Rpb24gPSB0aGVtZURldGFpbENvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQgPSBleHBvcnRzLmdldFNlY29uZGFyeVNlY3Rpb25Qcm9tcHQgPSB2b2lkIDA7XG52YXIgZ3B0dXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZ3B0dXRpbHNcIik7XG52YXIgX01PREVMX05BTUVfR1BUMyA9IFwiZ3B0LTMuNS10dXJib1wiO1xudmFyIF9NT0RFTF9OQU1FX0dQVDQgPSBcImdwdC00b1wiO1xudmFyIF9NT0RFTF9OQU1FX0dQVDRfTUlOSSA9IFwiZ3B0LTRvLW1pbmlcIjtcbnZhciBfTU9ERUxfTkFNRSA9IHByb2Nlc3MuZW52LkNIQVRHUFRfTU9ERUxfTkFNRSB8fCBcImdwdC00by1taW5pXCI7XG52YXIgZ2V0U2Vjb25kYXJ5U2VjdGlvblByb21wdCA9IGZ1bmN0aW9uICh0eXBlLCBib29rTmFtZSwgYXV0aG9yTmFtZSwgY29udGVudCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWx0ZXJuYXRlX3Rha2VzXCI6XG4gICAgICAgICAgICByZXR1cm4gKDAsIGdwdHV0aWxzXzEuZ2V0UHJvbXB0KShfQUxURVJOQVRFX1RBS0VTX1BST01QVCwge1xuICAgICAgICAgICAgICAgIGJvb2tOYW1lOiBib29rTmFtZSxcbiAgICAgICAgICAgICAgICBhdXRob3JOYW1lOiBhdXRob3JOYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBcImNvbnRleHRcIjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgZ3B0dXRpbHNfMS5nZXRQcm9tcHQpKF9TSE9SVEVOX0NPTlRFTlRfUFJPTVBULCB7XG4gICAgICAgICAgICAgICAgYm9va05hbWU6IGJvb2tOYW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvck5hbWU6IGF1dGhvck5hbWUsXG4gICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0U2Vjb25kYXJ5U2VjdGlvblByb21wdCA9IGdldFNlY29uZGFyeVNlY3Rpb25Qcm9tcHQ7XG52YXIgZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQgPSBmdW5jdGlvbiAoYm9va05hbWUsIGF1dGhvck5hbWUsIHRoZW1lVGl0bGUsIHRoZW1lRGVzY3JpcHRpb24sIHN1YlRoZW1lcywgbm90ZUxpc3QpIHtcbiAgICB2YXIgbm90ZXMgPSBub3RlTGlzdC5qb2luKFwiL25cIik7XG4gICAgcmV0dXJuICgwLCBncHR1dGlsc18xLmdldFByb21wdCkoX1NVTU1BUllfUFJPTVBULCB7XG4gICAgICAgIGJvb2tOYW1lOiBib29rTmFtZSxcbiAgICAgICAgYXV0aG9yTmFtZTogYXV0aG9yTmFtZSxcbiAgICAgICAgdGhlbWVUaXRsZTogdGhlbWVUaXRsZSxcbiAgICAgICAgdGhlbWVEZXNjcmlwdGlvbjogdGhlbWVEZXNjcmlwdGlvbixcbiAgICAgICAgbm90ZXM6IG5vdGVzLFxuICAgICAgICBzdWJUaGVtZXM6IHN1YlRoZW1lcyxcbiAgICB9KTtcbn07XG5leHBvcnRzLmdldFN1bW1hcnlTZWN0aW9uUHJvbXB0ID0gZ2V0U3VtbWFyeVNlY3Rpb25Qcm9tcHQ7XG52YXIgX1NVTU1BUllfUFJPTVBUID0ge1xuICAgIG1vZGVsOiBfTU9ERUxfTkFNRSxcbiAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICAgIFwiWW91IGFyZSBhbiBBSSBkZXNpZ25lZCB0byBwcm92aWRlIGEgZGV0YWlsZWQsIGxvZ2ljYWxseSBzdHJ1Y3R1cmVkLCBhbmQgaW5mb3JtYXRpdmUgZXhwbG9yYXRpb24gb2YgYSB0aGVtZSBmcm9tIGEgYm9vay5cIixcbiAgICAgICAgICAgICAgICBcIkVuc3VyZSB0aGF0IHlvdXIgZXhwbGFuYXRpb24gZGlyZWN0bHkgZGVzY3JpYmVzIHRoZSB0aGVtZSB3aXRob3V0IGZyYW1pbmcgaXQgYXMgdGhpcmQtcGVyc29uIGNvbW1lbnRhcnkgb3IgbmFycmF0aXZlLlwiLFxuICAgICAgICAgICAgICAgIFwiRm9ybWF0IHRoZSBvdXRwdXQgYXMgYSBKU09OIG9iamVjdCB3aXRoIHR3byBmaWVsZHM6ICd0aGVtZUV4cGxvcmF0aW9uJyBhbmQgJ3N1YlRoZW1lcycuXCIsXG4gICAgICAgICAgICAgICAgXCIndGhlbWVFeHBsb3JhdGlvbicgaXMgYSBkZXRhaWxlZCBzdHVkeSBvZiB0aGUgdGhlbWUsIGFuZCAnc3ViVGhlbWVzJyBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggJ3RpdGxlJyBhbmQgJ2V4cGxvcmF0aW9uJy5cIixcbiAgICAgICAgICAgICAgICBcIldoZW4gZXhwbG9yaW5nIHN1Yi10aGVtZXMsIGF2b2lkIHF1b3Rpbmcgb3IgcGFyYXBocmFzaW5nIHRoZWlyIHRpdGxlcyBvciBkZXNjcmlwdGlvbnMgYWdhaW4gd2l0aGluIHRoZSAnZXhwbG9yYXRpb24nLiBFbnN1cmUgdGhhdCB0aGVyZSBhcmUgbm8gc2VsZi1yZWZlcmVuY2VzIG9yIHBocmFzZXMgdGhhdCBleHBsaWNpdGx5IHBvaW50IHRvIHRoZSBzdWItdGhlbWUgb3IgaXRzIHRpdGxlLlwiLFxuICAgICAgICAgICAgICAgIFwiQW5hbHl6ZSBob3cgdGhlIHN1Yi10aGVtZXMgc3VwcG9ydCwgY2hhbGxlbmdlLCBvciBpbnRlcmFjdCB3aXRoIHRoZSBtYWluIHRoZW1lLlwiLFxuICAgICAgICAgICAgICAgIFwiSWYgbm8gc3ViLXRoZW1lcyBhcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXIsIHJldHVybiBhbiBlbXB0eSBhcnJheSBmb3IgJ3N1YlRoZW1lcycuXCIsXG4gICAgICAgICAgICAgICAgXCJEbyBub3QgY3JlYXRlIG9yIGluZmVyIHN1Yi10aGVtZXMgdW5sZXNzIHRoZXkgYXJlIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gdGhlIGlucHV0LlwiLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudCBzaG91bGQgYmUgaW4gSFRNTCBmb3JtYXQgd2l0aCBwYXJhZ3JhcGhzLCBib2xkLCBhbmQgaXRhbGljIHRhZ3MuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIkV4cGxvcmUgdGhlIHRoZW1lIG9mIHt7dGhlbWVUaXRsZX19IGZyb20gdGhlIGJvb2sge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19LCBmb3JtYXR0ZWQgaW4gSlNPTiB3aXRoIEhUTUwgcGFyYWdyYXBocywgYm9sZCwgYW5kIGl0YWxpYyBlbGVtZW50cy5cIixcbiAgICAgICAgICAgICAgICBcInt7dGhlbWVEZXNjcmlwdGlvbn19XCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIlVzZSB0aGUgZm9sbG93aW5nIG5vdGVzIGZvciBjb250ZXh0dWFsIHVuZGVyc3RhbmRpbmcgb25seSwgYW5kIG9ubHkgd2hlcmUgcmVsZXZhbnQgdG8gdGhlIGJvb2sge3tib29rTmFtZX19LCB0aGUgYXV0aG9yIHt7YXV0aG9yTmFtZX19LCBhbmQgdGhlbWUge3t0aGVtZVRpdGxlfX0uXCIsXG4gICAgICAgICAgICAgICAgXCJEbyBub3QgZGlyZWN0bHkgdXNlIHRoZXNlIG5vdGVzIGFzIGEgc291cmNlIGZvciBidWlsZGluZyB5b3VyIGV4cGxvcmF0aW9uOlwiLFxuICAgICAgICAgICAgICAgIFwie3tub3Rlc319XCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIkhlcmUgYXJlIHRoZSByZWxldmFudCBzdWItdGhlbWVzIGZvciBjb250ZXh0OlwiLFxuICAgICAgICAgICAgICAgIFwie3tzdWJUaGVtZXN9fVwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6ICd7XCJ0aGVtZUV4cGxvcmF0aW9uXCI6XCI8cD57e3RoZW1lRGVzY3JpcHRpb259fTwvcD48cD57VGhlbWVEZXRhaWxlZEV4cGxvcmF0aW9uMX08L3A+PHA+e1RoZW1lRGV0YWlsZWRFeHBsb3JhdGlvbjJ9PC9wPlwiLFwic3ViVGhlbWVzXCI6W3tcInRpdGxlXCI6XCJ7U3ViVGhlbWVUaXRsZTF9XCIsXCJleHBsb3JhdGlvblwiOlwiPHA+e0RldGFpbGVkU3ViVGhlbWVEZXNjcmlwdGlvbjFQYXJhZ3JhcGgxfTwvcD48cD57RGV0YWlsZWRTdWJUaGVtZURlc2NyaXB0aW9uMVBhcmFncmFwaDJ9PC9wPjxwPntEZXRhaWxlZFN1YlRoZW1lRGVzY3JpcHRpb24xUGFyYWdyYXBoM308L3A+XCJ9LHtcInRpdGxlXCI6XCJ7U3ViVGhlbWVUaXRsZTJ9XCIsXCJleHBsb3JhdGlvblwiOlwiPHA+e0RldGFpbGVkU3ViVGhlbWVEZXNjcmlwdGlvbjJQYXJhZ3JhcGgxfTwvcD48cD57RGV0YWlsZWRTdWJUaGVtZURlc2NyaXB0aW9uMlBhcmFncmFwaDJ9PC9wPjxwPntEZXRhaWxlZFN1YlRoZW1lRGVzY3JpcHRpb24yUGFyYWdyYXBoM308L3A+XCJ9LHtcInRpdGxlXCI6XCJ7U3ViVGhlbWVUaXRsZTN9XCIsXCJleHBsb3JhdGlvblwiOlwiPHA+e0RldGFpbGVkU3ViVGhlbWVEZXNjcmlwdGlvbjNQYXJhZ3JhcGgxfTwvcD48cD57RGV0YWlsZWRTdWJUaGVtZURlc2NyaXB0aW9uM1BhcmFncmFwaDJ9PC9wPjxwPntEZXRhaWxlZFN1YlRoZW1lRGVzY3JpcHRpb24zUGFyYWdyYXBoM308L3A+XCJ9LHtcInRpdGxlXCI6XCJ7U3ViVGhlbWVUaXRsZTR9XCIsXCJleHBsb3JhdGlvblwiOlwiPHA+e0RldGFpbGVkU3ViVGhlbWVEZXNjcmlwdGlvbjRQYXJhZ3JhcGgxfTwvcD48cD57RGV0YWlsZWRTdWJUaGVtZURlc2NyaXB0aW9uNFBhcmFncmFwaDJ9PC9wPjxwPntEZXRhaWxlZFN1YlRoZW1lRGVzY3JpcHRpb240UGFyYWdyYXBoM308L3A+XCJ9XX0nLFxuICAgICAgICB9LFxuICAgIF0sXG4gICAgdGVtcGVyYXR1cmU6IDEsXG4gICAgbWF4X3Rva2VuczogNDA5NixcbiAgICB0b3BfcDogMSxcbiAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxufTtcbnZhciBfU0hPUlRFTl9DT05URU5UX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYW4gQUkgZGVzaWduZWQgdG8gcHJvdmlkZSBhIGNvbmNpc2Ugc3VtbWFyeSBvZiB0aGUgZGV0YWlsZWQgZXhwbG9yYXRpb24gb2YgYSB0aGVtZSBmcm9tIGEgc3BlY2lmaWMgYm9vay5cIixcbiAgICAgICAgICAgICAgICBcIllvdXIgc3VtbWFyeSBzaG91bGQgY2FwdHVyZSB0aGUgZXNzZW5jZSBvZiB0aGUgY2VudHJhbCB0aGVtZSBhbmQgaXRzIHN1Yi10aGVtZXMsIHdoaWxlIGJlaW5nIGJyaWVmIGFuZCBjbGVhci5cIixcbiAgICAgICAgICAgICAgICBcIkluY2x1ZGUgcmVmZXJlbmNlcyB0byB0aGUgYm9vayBuYW1lIGFuZCBhdXRob3IgbmFtZSB0byBwcm92aWRlIGNvbnRleHQgZm9yIGxhdGVyIHByb21wdHMuXCIsXG4gICAgICAgICAgICAgICAgXCJBdm9pZCB1bm5lY2Vzc2FyeSBkZXRhaWxzIGFuZCBmb2N1cyBvbiB0aGUga2V5IHBvaW50cy5cIixcbiAgICAgICAgICAgICAgICBcIldoZW4gaW4gZG91YnQsIGl0IGlzIHNhZmVyIHRvIHJldGFpbiBjb250ZW50IHJhdGhlciB0aGFuIHJlbW92ZSBpdC4gRW5zdXJlIHRoYXQgaW1wb3J0YW50IGFzcGVjdHMgb2YgdGhlIHRoZW1lIGFuZCBzdWItdGhlbWVzIGFyZSBwcmVzZXJ2ZWQuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIlN1bW1hcml6ZSB0aGUgZm9sbG93aW5nIGNvbnRlbnQgaW50byBhIHNob3J0ZXIsIGNvbmNpc2UgdmVyc2lvbiBzdWl0YWJsZSBmb3IgZnVydGhlciBhbmFseXNpcyBvciBpbnRlcnByZXRhdGlvbi4gSW5jbHVkZSByZWZlcmVuY2VzIHRvIHRoZSBib29rIG5hbWUge3tib29rTmFtZX19IGFuZCBhdXRob3Ige3thdXRob3JOYW1lfX0gaW4gdGhlIHN1bW1hcnk6XCIsXG4gICAgICAgICAgICAgICAgXCJ7e2NvbnRlbnR9fVwiLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG52YXIgX0FMVEVSTkFURV9UQUtFU19QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGFuIEFJIGRlc2lnbmVkIHRvIHByb3ZpZGUgYWx0ZXJuYXRlIHRha2VzIG9uIHNwZWNpZmljIHRvcGljcyBjb3ZlcmVkIGluIHRoZSBwcm92aWRlZCBjb250ZW50IGZyb20gdGhlIGJvb2sge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19LlwiLFxuICAgICAgICAgICAgICAgIFwiWW91ciB0YXNrIGlzIHRvIGdlbmVyYXRlIGRldGFpbGVkIGV4cGxhbmF0aW9ucyBmcm9tIG90aGVyIGF1dGhvcnMnIHBlcnNwZWN0aXZlcyBvbiBob3cgdGhlaXIgbWF0ZXJpYWwgcmVsYXRlcyB0byBvciBjb250cmFkaWN0cyB0aGUgc3BlY2lmaWMgdG9waWNzIGNvdmVyZWQgaW4gdGhlIGNvbnRlbnQuXCIsXG4gICAgICAgICAgICAgICAgXCJUaGUgb3V0cHV0IHNob3VsZCBiZSBhIGxpc3Qgb2YgSlNPTiBvYmplY3RzIHdpdGggdHdvIGZpZWxkczogJ3JlZmVyZW5jZScgYW5kICdjb250ZW50Jy5cIixcbiAgICAgICAgICAgICAgICBcIidyZWZlcmVuY2UnIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCAnYm9vaycgYW5kICdhdXRob3InIGZpZWxkcywgaW5kaWNhdGluZyB0aGUgYm9vayBuYW1lIGFuZCBhdXRob3IgbmFtZSBvZiB0aGUgYWx0ZXJuYXRlIHBlcnNwZWN0aXZlLlwiLFxuICAgICAgICAgICAgICAgIFwiJ2NvbnRlbnQnIHNob3VsZCBiZSBIVE1MIGZvcm1hdHRlZCB3aXRoIGEgZmV3IHBhcmFncmFwaHMgZXhwbGFpbmluZyBkZWVwbHkgaG93IHRoZSBhbHRlcm5hdGUgbWF0ZXJpYWwgcmVsYXRlcyB0byBvciBjb250cmFkaWN0cyB0aGUgc3BlY2lmaWMgdG9waWNzIGNvdmVyZWQuXCIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICBcIlByb3ZpZGUgYWx0ZXJuYXRlIHRha2VzIGJ5IG90aGVyIGF1dGhvcnMgb24gdGhlIHNwZWNpZmljIHRvcGljcyBjb3ZlcmVkIGluIHRoZSBjb250ZW50IGZyb20gdGhlIGJvb2sge3tib29rTmFtZX19IGJ5IHt7YXV0aG9yTmFtZX19LiBGb3IgZWFjaCBhbHRlcm5hdGUgdGFrZSwgaW5jbHVkZSB0aGUgZm9sbG93aW5nIGRldGFpbHM6XCIsXG4gICAgICAgICAgICAgICAgXCIxLiBSZWZlcmVuY2UgYXMgYW4gb2JqZWN0IHdpdGggJ2Jvb2snIGFuZCAnYXV0aG9yJyBmaWVsZHMgZm9yIHRoZSBhbHRlcm5hdGUgcGVyc3BlY3RpdmUuXCIsXG4gICAgICAgICAgICAgICAgXCIyLiBIVE1MIGZvcm1hdHRlZCBjb250ZW50IHdpdGggYSBmZXcgcGFyYWdyYXBocyBleHBsYWluaW5nIGhvdyB0aGUgYWx0ZXJuYXRlIG1hdGVyaWFsIHJlbGF0ZXMgdG8gb3IgY29udHJhZGljdHMgdGhlIHNwZWNpZmljIHRvcGljcyBjb3ZlcmVkLlwiLFxuICAgICAgICAgICAgICAgIFwiSGVyZSBpcyB0aGUgY29udGVudCBmb3IgcmVmZXJlbmNlOlwiLFxuICAgICAgICAgICAgICAgIFwie3tjb250ZW50fX1cIixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICB0ZW1wZXJhdHVyZTogMSxcbiAgICBtYXhfdG9rZW5zOiA0MDk2LFxuICAgIHRvcF9wOiAxLFxuICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLnB1dChcIi9ib29rL3RoZW1lLWRldGFpbC86c3BhY2UvOmlkXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLnVwZGF0ZVRoZW1lRGV0YWlsKSk7XG4gICAgcm91dGVyLnBvc3QoXCIvYm9vay90aGVtZS1kZXRhaWwvOnNwYWNlLzpib29rcmVmLzpjb25jZXB0cmVmLzp0aGVtZXJlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5jcmVhdGVUaGVtZURldGFpbCkpO1xuICAgIHJvdXRlci5nZXQoXCIvYm9vay90aGVtZS1kZXRhaWwvOnNwYWNlLzpib29rcmVmLzpjb25jZXB0cmVmLzp0aGVtZXJlZlwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRUaGVtZURldGFpbHNCeUJvb2tSZWZlcmVuY2UpKTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL2Jvb2svdGhlbWUtZGV0YWlsLzpzcGFjZS86aWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZGVsZXRlVGhlbWVEZXRhaWwpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVUaGVtZURldGFpbCA9IGV4cG9ydHMuZ2V0VGhlbWVEZXRhaWxzQnlCb29rUmVmZXJlbmNlU2hvcnRmb3JtID0gZXhwb3J0cy5nZXRUaGVtZURldGFpbHNCeUJvb2tSZWZlcmVuY2UgPSBleHBvcnRzLnVwZGF0ZVRoZW1lRGV0YWlsID0gZXhwb3J0cy5jcmVhdGVUaGVtZURldGFpbCA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBjcmVhdGVUaGVtZURldGFpbCA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCB0aGVtZURldGFpbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmNyZWF0ZVRoZW1lRGV0YWlsKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZiwgcmVxLnBhcmFtcy5jb25jZXB0cmVmLCByZXEucGFyYW1zLnRoZW1lcmVmLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhlbWVEZXRhaWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHRoZW1lRGV0YWlsKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmNyZWF0ZVRoZW1lRGV0YWlsID0gY3JlYXRlVGhlbWVEZXRhaWw7XG52YXIgdXBkYXRlVGhlbWVEZXRhaWwgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgdGhlbWVEZXRhaWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci51cGRhdGVUaGVtZURldGFpbChyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmlkLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhlbWVEZXRhaWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHRoZW1lRGV0YWlsKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZVRoZW1lRGV0YWlsID0gdXBkYXRlVGhlbWVEZXRhaWw7XG52YXIgZ2V0VGhlbWVEZXRhaWxzQnlCb29rUmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHRoZW1lRGV0YWlsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0VGhlbWVEZXRhaWxzQnlCb29rUmVmZXJlbmNlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZiwgcmVxLnBhcmFtcy5jb25jZXB0cmVmLCByZXEucGFyYW1zLnRoZW1lcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhlbWVEZXRhaWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHRoZW1lRGV0YWlsKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFRoZW1lRGV0YWlsc0J5Qm9va1JlZmVyZW5jZSA9IGdldFRoZW1lRGV0YWlsc0J5Qm9va1JlZmVyZW5jZTtcbnZhciBnZXRUaGVtZURldGFpbHNCeUJvb2tSZWZlcmVuY2VTaG9ydGZvcm0gPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgdGhlbWVEZXRhaWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRUaGVtZURldGFpbHNCeUJvb2tSZWZlcmVuY2VTaG9ydGZvcm0ocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5ib29rcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdGhlbWVEZXRhaWwgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHRoZW1lRGV0YWlsKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFRoZW1lRGV0YWlsc0J5Qm9va1JlZmVyZW5jZVNob3J0Zm9ybSA9IGdldFRoZW1lRGV0YWlsc0J5Qm9va1JlZmVyZW5jZVNob3J0Zm9ybTtcbnZhciBkZWxldGVUaGVtZURldGFpbCA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlVGhlbWVEZXRhaWwocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG91dGNvbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlVGhlbWVEZXRhaWwgPSBkZWxldGVUaGVtZURldGFpbDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubW92ZSA9IGV4cG9ydHMuZGVsZXRlQ29sb3JmaWx0ZXIgPSBleHBvcnRzLmdldENvbG9yZmlsdGVyID0gZXhwb3J0cy51cGRhdGVDb2xvcmZpbHRlckl0ZW0gPSBleHBvcnRzLnVwZGF0ZUNvbG9yZmlsdGVyID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciB1cGRhdGVDb2xvcmZpbHRlciA9IGZ1bmN0aW9uIChzcGFjZSwgZGF0YSwgdXNlcklkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzcG9uc2UsIG9yZGVyO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5jb2xvcmZpbHRlckNvbGxlY3Rpb24sIG1vZGVsXzEuY29sb3JmaWx0ZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuX2lkKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoZGF0YS5faWQsIGRhdGEsIHsgbmV3OiB0cnVlLCB1cHNlcnQ6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNV07XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCwgbW9kZWwuZmluZCgpLmNvdW50KCldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG9yZGVyID0gKF9hLnNlbnQoKSkgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyBvcmRlcjogb3JkZXIgfSkpXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCwgKDAsIGV4cG9ydHMuZ2V0Q29sb3JmaWx0ZXIpKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZUNvbG9yZmlsdGVyID0gdXBkYXRlQ29sb3JmaWx0ZXI7XG52YXIgdXBkYXRlQ29sb3JmaWx0ZXJJdGVtID0gZnVuY3Rpb24gKHNwYWNlLCBkYXRhKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmNvbG9yZmlsdGVyQ29sbGVjdGlvbiwgbW9kZWxfMS5jb2xvcmZpbHRlclNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YS5faWQpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShkYXRhLl9pZCwgZGF0YSwgeyBuZXc6IHRydWUsIHVwc2VydDogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0LCBtb2RlbC5jcmVhdGUoZGF0YSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVDb2xvcmZpbHRlckl0ZW0gPSB1cGRhdGVDb2xvcmZpbHRlckl0ZW07XG52YXIgZ2V0Q29sb3JmaWx0ZXIgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5jb2xvcmZpbHRlckNvbGxlY3Rpb24sIG1vZGVsXzEuY29sb3JmaWx0ZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCgpLnNvcnQoeyBvcmRlcjogXCJhc2NlbmRpbmdcIiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldENvbG9yZmlsdGVyID0gZ2V0Q29sb3JmaWx0ZXI7XG52YXIgZGVsZXRlQ29sb3JmaWx0ZXIgPSBmdW5jdGlvbiAoc3BhY2UsIF9pZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmNvbG9yZmlsdGVyQ29sbGVjdGlvbiwgbW9kZWxfMS5jb2xvcmZpbHRlclNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgY29sb3JmaWx0ZXI6IFtfaWRdIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQ29sb3JmaWx0ZXIgPSBkZWxldGVDb2xvcmZpbHRlcjtcbnZhciBtb3ZlID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQsIG1vZGUpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCBkYXRhLCBjdXJyZW50SXRlbSwgaW1wYWN0ZWRJdGVtO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5jb2xvcmZpbHRlckNvbGxlY3Rpb24sIG1vZGVsXzEuY29sb3JmaWx0ZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCgpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVtID0gZGF0YS5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLl9pZC50b1N0cmluZygpID09PSBfaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50SXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgJ3N0YXR1cyc6ICdkYXRhIG5vdCBmb3VuZCcgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoX2lkLCB7IG9yZGVyOiBtb2RlID09PSAndXAnID8gY3VycmVudEl0ZW0ub3JkZXIgLSAxIDogY3VycmVudEl0ZW0ub3JkZXIgKyAxIH0sIHsgbmV3OiB0cnVlLCB1cHNlcnQ6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpbXBhY3RlZEl0ZW0gPSBkYXRhLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09ICd1cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLm9yZGVyID09PSBjdXJyZW50SXRlbS5vcmRlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5vcmRlciA9PT0gY3VycmVudEl0ZW0ub3JkZXIgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShpbXBhY3RlZEl0ZW0uX2lkLCB7IG9yZGVyOiBtb2RlID09PSAndXAnID8gaW1wYWN0ZWRJdGVtLm9yZGVyICsgMSA6IGltcGFjdGVkSXRlbS5vcmRlciAtIDEgfSwgeyBuZXc6IHRydWUsIHVwc2VydDogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIGV4cG9ydHMuZ2V0Q29sb3JmaWx0ZXIpKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLm1vdmUgPSBtb3ZlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbG9yZmlsdGVyQ29sbGVjdGlvbiA9IGV4cG9ydHMuY29sb3JmaWx0ZXJTY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIGNvbG9yZmlsdGVyU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgbmFtZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBjb2xvcjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB0ZXh0OiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHRleHRMaXN0OiB7IHR5cGU6IEFycmF5IH0sXG4gICAgc2VhcmNoUHJlZjogeyB0eXBlOiBPYmplY3QgfSxcbiAgICBvcmRlcjogeyB0eXBlOiBOdW1iZXIgfVxufSwgeyB0aW1lc3RhbXBzOiB0cnVlLCBtaW5pbWl6ZTogZmFsc2UgfSk7XG5leHBvcnRzLmNvbG9yZmlsdGVyU2NoZW1hID0gY29sb3JmaWx0ZXJTY2hlbWE7XG52YXIgY29sb3JmaWx0ZXJDb2xsZWN0aW9uID0gXCJjb2xvcmZpbHRlclwiO1xuZXhwb3J0cy5jb2xvcmZpbHRlckNvbGxlY3Rpb24gPSBjb2xvcmZpbHRlckNvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLnB1dChcIi9jb2xvci1maWx0ZXIvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLnVwZGF0ZUNvbG9yZmlsdGVyKSk7XG4gICAgcm91dGVyLmdldChcIi9jb2xvci1maWx0ZXIvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldENvbG9yZmlsdGVyKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9jb2xvci1maWx0ZXIvOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVDb2xvcmZpbHRlcikpO1xuICAgIHJvdXRlci5wb3N0KFwiL2NvbG9yLWZpbHRlci86c3BhY2UvdXAvOmlkXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLm1vdmVVcCkpO1xuICAgIHJvdXRlci5wb3N0KFwiL2NvbG9yLWZpbHRlci86c3BhY2UvZG93bi86aWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEubW92ZURvd24pKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb3ZlRG93biA9IGV4cG9ydHMubW92ZVVwID0gZXhwb3J0cy5kZWxldGVDb2xvcmZpbHRlciA9IGV4cG9ydHMuZ2V0Q29sb3JmaWx0ZXIgPSBleHBvcnRzLnVwZGF0ZUNvbG9yZmlsdGVySXRlbSA9IGV4cG9ydHMudXBkYXRlQ29sb3JmaWx0ZXIgPSB2b2lkIDA7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xudmFyIHVwZGF0ZUNvbG9yZmlsdGVyID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGNvbG9yZmlsdGVyO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIudXBkYXRlQ29sb3JmaWx0ZXIocmVxLnBhcmFtcy5zcGFjZSwgcmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbG9yZmlsdGVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChjb2xvcmZpbHRlcik7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVDb2xvcmZpbHRlciA9IHVwZGF0ZUNvbG9yZmlsdGVyO1xudmFyIHVwZGF0ZUNvbG9yZmlsdGVySXRlbSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBjb2xvcmZpbHRlcjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLnVwZGF0ZUNvbG9yZmlsdGVySXRlbShyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbG9yZmlsdGVyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChjb2xvcmZpbHRlcik7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVDb2xvcmZpbHRlckl0ZW0gPSB1cGRhdGVDb2xvcmZpbHRlckl0ZW07XG52YXIgZ2V0Q29sb3JmaWx0ZXIgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgY29sb3JmaWx0ZXJMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Q29sb3JmaWx0ZXIocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbG9yZmlsdGVyTGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoY29sb3JmaWx0ZXJMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldENvbG9yZmlsdGVyID0gZ2V0Q29sb3JmaWx0ZXI7XG52YXIgZGVsZXRlQ29sb3JmaWx0ZXIgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgb3V0Y29tZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZUNvbG9yZmlsdGVyKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUNvbG9yZmlsdGVyID0gZGVsZXRlQ29sb3JmaWx0ZXI7XG52YXIgbW92ZVVwID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5tb3ZlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQsICd1cCcpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLm1vdmVVcCA9IG1vdmVVcDtcbnZhciBtb3ZlRG93biA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIubW92ZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmlkLCAnZG93bicpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLm1vdmVEb3duID0gbW92ZURvd247XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q29tcGFueUJ5SWRMaXN0ID0gZXhwb3J0cy5nZXRDb21wYW55QnlSZWZlcmVuY2UgPSBleHBvcnRzLmdldENvbXBhbnkgPSBleHBvcnRzLnVwZGF0ZUNvbXBhbnkgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgZGJ1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2xpYi9kYnV0aWxzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuLi9zZXF1ZW5jZS9zZXJ2aWNlXCIpO1xudmFyIFN0b3B3b3Jkc0hlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vc3RvcHdvcmRzL2hlbHBlclwiKSk7XG52YXIgdXBkYXRlQ29tcGFueSA9IGZ1bmN0aW9uIChkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXNwb25zZV8xLCByZXNwb25zZSwgX2EsIF9iLCBfYztcbiAgICB2YXIgX2Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSAoMCwgZGJ1dGlsc18xLmdldEdsb2JhbENvbGxlY3Rpb24pKG1vZGVsXzEuY29tcGFueUNvbGxlY3Rpb24sIG1vZGVsXzEuY29tcGFueVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLl9pZCkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKGRhdGEuX2lkLCBfX2Fzc2lnbih7fSwgZGF0YSksIHsgbmV3OiB0cnVlLCB1cHNlcnQ6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlXzEgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZV8xXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfYiA9IChfYSA9IG1vZGVsKS5jcmVhdGU7XG4gICAgICAgICAgICAgICAgX2MgPSBbX19hc3NpZ24oe30sIGRhdGEpXTtcbiAgICAgICAgICAgICAgICBfZCA9IHt9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIHNlcnZpY2VfMS5uZXh0dmFsKShcImNvbXBhbnlJZFwiKV07XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCwgX2IuYXBwbHkoX2EsIFtfX2Fzc2lnbi5hcHBseSh2b2lkIDAsIF9jLmNvbmNhdChbKF9kLnJlZmVyZW5jZSA9IF9lLnNlbnQoKSwgX2QpXSkpXSldO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIHNlcnZpY2VfMS5jcmVhdGVfc2VxdWVuY2UpKFwibm90ZUlkXCIsIG51bGwsIDEsIHJlc3BvbnNlLnJlZmVyZW5jZSldO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBzZXJ2aWNlXzEuY3JlYXRlX3NlcXVlbmNlKShcImxpYnJhcnlJZFwiLCBudWxsLCAxLCByZXNwb25zZS5yZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBTdG9wd29yZHNIZWxwZXIucmVzZXRTdG9wd29yZHMocmVzcG9uc2UucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzcG9uc2VdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlQ29tcGFueSA9IHVwZGF0ZUNvbXBhbnk7XG52YXIgZ2V0Q29tcGFueSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRHbG9iYWxDb2xsZWN0aW9uKShtb2RlbF8xLmNvbXBhbnlDb2xsZWN0aW9uLCBtb2RlbF8xLmNvbXBhbnlTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCgpXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Q29tcGFueSA9IGdldENvbXBhbnk7XG52YXIgZ2V0Q29tcGFueUJ5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlZmVyZW5jZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSAoMCwgZGJ1dGlsc18xLmdldEdsb2JhbENvbGxlY3Rpb24pKG1vZGVsXzEuY29tcGFueUNvbGxlY3Rpb24sIG1vZGVsXzEuY29tcGFueVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kT25lKHsgcmVmZXJlbmNlOiByZWZlcmVuY2UgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRDb21wYW55QnlSZWZlcmVuY2UgPSBnZXRDb21wYW55QnlSZWZlcmVuY2U7XG52YXIgZ2V0Q29tcGFueUJ5SWRMaXN0ID0gZnVuY3Rpb24gKGlkTGlzdCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSAoMCwgZGJ1dGlsc18xLmdldEdsb2JhbENvbGxlY3Rpb24pKG1vZGVsXzEuY29tcGFueUNvbGxlY3Rpb24sIG1vZGVsXzEuY29tcGFueVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgX2lkOiB7ICRpbjogaWRMaXN0IH0gfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRDb21wYW55QnlJZExpc3QgPSBnZXRDb21wYW55QnlJZExpc3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcGFueUNvbGxlY3Rpb24gPSBleHBvcnRzLmNvbXBhbnlTY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIGNvbXBhbnlTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGRlc2NyaXB0aW9uOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHJlZmVyZW5jZTogeyB0eXBlOiBOdW1iZXIgfSxcbiAgICBjdXJyZW5jeTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBudW1iZXJGb3JtYXQ6IHsgdHlwZTogU3RyaW5nIH0sXG59LCB7IHRpbWVzdGFtcHM6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBhbnlTY2hlbWEgPSBjb21wYW55U2NoZW1hO1xudmFyIGNvbXBhbnlDb2xsZWN0aW9uID0gXCJjb21wYW55XCI7XG5leHBvcnRzLmNvbXBhbnlDb2xsZWN0aW9uID0gY29tcGFueUNvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLnB1dChcIi9jb21wYW55XCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCBzZXJ2aWNlXzEudXBkYXRlQ29tcGFueSk7XG4gICAgcm91dGVyLmdldChcIi9jb21wYW55XCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCBzZXJ2aWNlXzEuZ2V0Q29tcGFueSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0Q29tcGFueUJ5UmVmZXJlbmNlID0gZXhwb3J0cy5nZXRDb21wYW55ID0gZXhwb3J0cy51cGRhdGVDb21wYW55ID0gdm9pZCAwO1xudmFyIEhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJcIikpO1xudmFyIHVzZXJJbnZpdGVTZXJ2aWNlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91c2VyL2ludml0ZS9zZXJ2aWNlXCIpKTtcbnZhciBQZXJtaXNzaW9uSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9wZXJtaXNzaW9uL2hlbHBlclwiKSk7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xudmFyIHVwZGF0ZUNvbXBhbnkgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgY29tcGFueTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLnVwZGF0ZUNvbXBhbnkocmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbXBhbnkgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgdXNlckludml0ZVNlcnZpY2UucmVnaXN0ZXJVc2VySW52aXRlKGNvbXBhbnkuX2RvYy5yZWZlcmVuY2UsIGNvbXBhbnkuX2RvYy5faWQsIHVzZXJJZCwgcmVxLnVzZXIuZW1haWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgUGVybWlzc2lvbkhlbHBlci5hZGRSb2xlKHJlcS51c2VyLmVtYWlsLCBjb21wYW55Ll9kb2MucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChjb21wYW55KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZUNvbXBhbnkgPSB1cGRhdGVDb21wYW55O1xudmFyIGdldENvbXBhbnkgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgY29tcGFueUxpc3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRDb21wYW55KCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbXBhbnlMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChjb21wYW55TGlzdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRDb21wYW55ID0gZ2V0Q29tcGFueTtcbnZhciBnZXRDb21wYW55QnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVmZXJlbmNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEhlbHBlci5nZXRDb21wYW55QnlSZWZlcmVuY2UocmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldENvbXBhbnlCeVJlZmVyZW5jZSA9IGdldENvbXBhbnlCeVJlZmVyZW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmltcG9ydEZpbGVGb3JGbGFzaGNhcmQgPSB2b2lkIDA7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbnZhciBHcHR1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vbGliL2dwdHV0aWxzXCIpKTtcbnZhciBwcm9tcHRfMSA9IHJlcXVpcmUoXCIuL3Byb21wdFwiKTtcbnZhciBpbXBvcnRGaWxlRm9yRmxhc2hjYXJkID0gZnVuY3Rpb24gKHNwYWNlLCBmaWxlcywgdXNlcklkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXh0LCBncHRSZXNwb25zZVRleHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgKDAsIHNlcnZpY2VfMS5pbWFnZVRvVGV4dCkoZmlsZXMpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0ZXh0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgR3B0dXRpbHMucHJlZGljdCgoMCwgcHJvbXB0XzEuZ2V0Q2xlYW5UZXh0UHJvbXB0KSh0ZXh0KSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlVGV4dCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGdwdFJlc3BvbnNlVGV4dF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5pbXBvcnRGaWxlRm9yRmxhc2hjYXJkID0gaW1wb3J0RmlsZUZvckZsYXNoY2FyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENsZWFuVGV4dFByb21wdCA9IGV4cG9ydHMuZ2V0Rmxhc3RDYXJkUHJvbXB0ID0gdm9pZCAwO1xudmFyIEhhbmRsZWJhcnMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImhhbmRsZWJhcnNcIikpO1xudmFyIGxvZGFzaF8xID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbnZhciBfTU9ERUxfTkFNRV9HUFQzID0gXCJncHQtMy41LXR1cmJvXCI7XG52YXIgX01PREVMX05BTUVfR1BUNCA9IFwiZ3B0LTRvXCI7XG52YXIgX01PREVMX05BTUUgPSBwcm9jZXNzLmVudi5DSEFUR1BUX01PREVMX05BTUUgfHwgXCJncHQtNG8tbWluaVwiO1xuO1xudmFyIGdldEZsYXN0Q2FyZFByb21wdCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIHByb21wdCA9ICgwLCBsb2Rhc2hfMS5jbG9uZURlZXApKF9DTEVBTl9URVhUX1BST01QVCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9tcHQubWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvbXB0Lm1lc3NhZ2VzW2ldLmNvbnRlbnQgPSBIYW5kbGViYXJzLmNvbXBpbGUocHJvbXB0Lm1lc3NhZ2VzW2ldLmNvbnRlbnQpKHsgdGV4dDogdGV4dCB9KTtcbiAgICB9XG4gICAgY29uc29sZS5sb2cocHJvbXB0KTtcbiAgICByZXR1cm4gcHJvbXB0O1xufTtcbmV4cG9ydHMuZ2V0Rmxhc3RDYXJkUHJvbXB0ID0gZ2V0Rmxhc3RDYXJkUHJvbXB0O1xudmFyIGdldENsZWFuVGV4dFByb21wdCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIHByb21wdCA9ICgwLCBsb2Rhc2hfMS5jbG9uZURlZXApKF9DTEVBTl9URVhUX1BST01QVCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9tcHQubWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvbXB0Lm1lc3NhZ2VzW2ldLmNvbnRlbnQgPSBIYW5kbGViYXJzLmNvbXBpbGUocHJvbXB0Lm1lc3NhZ2VzW2ldLmNvbnRlbnQpKHsgdGV4dDogdGV4dCB9KTtcbiAgICB9XG4gICAgY29uc29sZS5sb2cocHJvbXB0KTtcbiAgICByZXR1cm4gcHJvbXB0O1xufTtcbmV4cG9ydHMuZ2V0Q2xlYW5UZXh0UHJvbXB0ID0gZ2V0Q2xlYW5UZXh0UHJvbXB0O1xudmFyIF9GTEFTSF9DQVJEX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiWW91IGFyZSBhbiBBSSBhc3Npc3RhbnQgdGhhdCB3aWxsIGhlbHAgd2l0aCB0ZXh0IGV4dHJhY3Rpb24gYW5kIGNyZWF0aW5nIGVkdWNhdGlvbmFsIG1hdGVyaWFscy4gWW91IHNob3VsZCBjbGVhbiB1cCBhbmQgY29ycmVjdCB0ZXh0IGV4dHJhY3RlZCBmcm9tIGEgc2Nhbm5lZCBjb3B5IG9mIGEgYm9vayBiZWZvcmUgZ2VuZXJhdGluZyBmbGFzaGNhcmRzLiBUaGUgcmVzcG9uc2UgbXVzdCBiZSBpbiBKU09OIGZvcm1hdCBvbmx5LCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIHRleHQuXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgY29udGVudDogXCJJIGhhdmUgdGV4dCBjb250ZW50IGV4dHJhY3RlZCBmcm9tIGEgc2Nhbm5lZCBjb3B5IG9mIGEgZmV3IHBhZ2VzIG9mIGEgYm9vayB1c2luZyB0ZXNzZXJhY3QuanMuIFRoZSBleHRyYWN0aW9uIHByb2Nlc3Mgd2FzIG5vdCBhY2N1cmF0ZSwgc28gcGxlYXNlIGNvcnJlY3QgYW5kIGNsZWFuIHRoZSB0ZXh0LiBBZnRlciBjbGVhbmluZywgZ2VuZXJhdGUgYSBzZXQgb2YgMjUgZmxhc2hjYXJkcyB0byBoZWxwIG1lIGxlYXJuIGFuZCB1bmRlcnN0YW5kIHRoZSBjb25jZXB0IGJldHRlci4gRWFjaCBmbGFzaGNhcmQgc2hvdWxkIGJlIGNvbmNpc2UgZW5vdWdoIHRvIGZpdCBvbnRvIGEgY2FyZCBhbmQgZm9ybWF0dGVkIGFzIGEgSlNPTiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIGZpZWxkcyAnZnJvbnQnIGFuZCAnYmFjaycuIEhlcmUgaXMgdGhlIHRleHQ6IHt7dGV4dH19XCIsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICB0ZW1wZXJhdHVyZTogMSxcbiAgICBtYXhfdG9rZW5zOiA0MDk2LFxuICAgIHRvcF9wOiAxLFxuICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG59O1xudmFyIF9DTEVBTl9URVhUX1BST01QVCA9IHtcbiAgICBtb2RlbDogX01PREVMX05BTUUsXG4gICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiWW91IGFyZSBDaGF0R1BULCBhbiBhZHZhbmNlZCBhc3Npc3RhbnQuIFlvdXIgcm9sZSBpcyB0byB0YWtlIHJhdywgdW5zdHJ1Y3R1cmVkIHRleHQgZXh0cmFjdGVkIGZyb20gc2Nhbm5lZCBib29rIHBhZ2VzLCBjb3JyZWN0IGFueSBlcnJvcnMgaW4gdGhlIHRleHQsIGFuZCByZXBocmFzZSBpdCBpbnRvIGEgY29oZXJlbnQsIHN0cnVjdHVyZWQgZm9ybWF0IHN1aXRhYmxlIGZvciBzdHVkeS4gQWZ0ZXIgY2xlYW5pbmcgdGhlIHRleHQsIGludGVycHJldCB0aGUgc3ViamVjdCBtYXR0ZXIgaW4gZGVwdGggYW5kIGdlbmVyYXRlIGEgZGV0YWlsZWQsIHdlbGwtb3JnYW5pemVkIGVzc2F5LiBUaGUgZXNzYXkgc2hvdWxkIGJlIHdyaXR0ZW4gaW4gYSBzZXJpZXMgb2Ygc2ltcGxlIHBhcmFncmFwaHMsIGNvdmVyaW5nIHRoZSBjb21wbGV0ZSBzdWJqZWN0LCB3aXRob3V0IHVzaW5nIGhlYWRpbmdzIG9yIGJ1bGxldCBwb2ludHMuIFRoZSBvdXRwdXQgc2hvdWxkIGJlIGluIEhUTUwgZm9ybWF0LCB1dGlsaXppbmcgb25seSBwYXJhZ3JhcGgsIGJvbGQsIGFuZCBpdGFsaWMgdGFncyB0byBlbXBoYXNpemUgaW1wb3J0YW50IHBvaW50cywgZW5zdXJpbmcgaXQgaXMgZWFzeSB0byBmb2xsb3cgZm9yIGEgc3R1ZGVudC5cIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICBjb250ZW50OiBcInt7dGV4dH19XCIsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICB0ZW1wZXJhdHVyZTogMSxcbiAgICBtYXhfdG9rZW5zOiA0MDk2LFxuICAgIHRvcF9wOiAxLFxuICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiAwLFxuICAgIHByZXNlbmNlX3BlbmFsdHk6IDAsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xudmFyIG11bHRlciA9IHJlcXVpcmUoXCJtdWx0ZXJcIik7XG52YXIgc3RvcmFnZSA9IG11bHRlci5tZW1vcnlTdG9yYWdlKCk7XG52YXIgdXBsb2FkID0gbXVsdGVyKHsgc3RvcmFnZTogc3RvcmFnZSB9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5wb3N0KFwiL2ZsYXNoY2FyZC86c3BhY2UvdXBsb2FkXCIsIHVwbG9hZC5hcnJheShcImZpbGVzXCIpLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5pbXBvcnRGaWxlRm9yRmxhc2hjYXJkKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW1hZ2VUb1RleHQgPSBleHBvcnRzLmltcG9ydEZpbGVGb3JGbGFzaGNhcmQgPSB2b2lkIDA7XG52YXIgdGVzc2VyYWN0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInRlc3NlcmFjdC5qc1wiKSk7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xudmFyIGltcG9ydEZpbGVGb3JGbGFzaGNhcmQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCIqXCIpO1xuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuaW1wb3J0RmlsZUZvckZsYXNoY2FyZChyZXEucGFyYW1zLnNwYWNlLCByZXEuZmlsZXMsIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5pbXBvcnRGaWxlRm9yRmxhc2hjYXJkID0gaW1wb3J0RmlsZUZvckZsYXNoY2FyZDtcbnZhciBpbWFnZVRvVGV4dCA9IGZ1bmN0aW9uIChmaWxlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xlYW5UZXh0LCB0ZXh0cywgaSwgdGV4dCwgZXJyb3JfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjbGVhblRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXGQrXFxzKlxcbi9nbSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eKFBhZ2UgXFxkKylcXHMqXFxuL2dtLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXHMqXFxuL2dtLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRleHRzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCA2LCAsIDddKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IGZpbGVzLmxlbmd0aCkpIHJldHVybiBbMywgNV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0ZXNzZXJhY3RfanNfMS5kZWZhdWx0LnJlY29nbml6ZShmaWxlc1tpXS5idWZmZXIsIFwiZW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcjogZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGNvbnNvbGUubG9nKG0pOyB9LFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgdGV4dCA9IChfYS5zZW50KCkpLmRhdGEudGV4dDtcbiAgICAgICAgICAgICAgICB0ZXh0cyArPSBcIlxcblwiICsgY2xlYW5UZXh0KHRleHQpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszLCA3XTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcm9jZXNzaW5nIGZpbGVzOlwiLCBlcnJvcl8xKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcHJvY2VzcyBmaWxlcy5cIik7XG4gICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiwgdGV4dHNdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuaW1hZ2VUb1RleHQgPSBpbWFnZVRvVGV4dDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYWluX3NpbWlsYXJpdHlfbW9kZWwgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBOb3RlSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9ub3RlL2hlbHBlclwiKSk7XG52YXIgQUlfQVBJID0gcHJvY2Vzcy5lbnYuQUlfQVBJIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo1MDAzL2FwaVwiO1xudmFyIHRyYWluX3NpbWlsYXJpdHlfbW9kZWwgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZG1pbiB0cmFpbmluZyBzdGFydGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTm90ZUhlbHBlci5fYWlfdHJhaW4oc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZG1pbiBwb3B1bGF0ZSBzdGFydGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTm90ZUhlbHBlci5fYWlfcG9wdWxhdGUoc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJhZG1pbiB0cmFpbmluZyBhbmQgcG9wdWxhdGUgZmluaXNoZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IFwic3RhdHVzXCI6IFwic3VjY2Vzc1wiIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudHJhaW5fc2ltaWxhcml0eV9tb2RlbCA9IHRyYWluX3NpbWlsYXJpdHlfbW9kZWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vaGFuZGxlclwiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLmdldChcIi9hZG1pblwiLCBmdW5jdGlvbiAoXywgcmVzKSB7XG4gICAgICAgIHJlcy5zZW5kKFwiYmFzaWMgY29ubmVjdGlvbiB0byBzZXJ2ZXIgd29ya3MuIGRhdGFiYXNlIGNvbm5lY3Rpb24gaXMgbm90IHZhbGlkYXRlZFwiKTtcbiAgICAgICAgcmVzLmVuZCgpO1xuICAgIH0pO1xuICAgIHJvdXRlci5nZXQoXCIvYWRtaW4vOnNwYWNlL3RyYWluXCIsICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEudHJhaW5fc2ltaWxhcml0eV9tb2RlbCkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYWluX3NpbWlsYXJpdHlfbW9kZWwgPSB2b2lkIDA7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xudmFyIHRyYWluX3NpbWlsYXJpdHlfbW9kZWwgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdGU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgSGVscGVyLnRyYWluX3NpbWlsYXJpdHlfbW9kZWwocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG5vdGUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG5vdGUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudHJhaW5fc2ltaWxhcml0eV9tb2RlbCA9IHRyYWluX3NpbWlsYXJpdHlfbW9kZWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW1wb3J0RXhwZW5zZSA9IGV4cG9ydHMudHJhbnNmb3JtQnVkZ2V0RGF0YUZvckV4cG9ydCA9IGV4cG9ydHMudHJhbnNmb3JtSW5jb21lRGF0YUZvckV4cG9ydCA9IGV4cG9ydHMudHJhbnNmb3JtRXhwZW5zZURhdGFGb3JFeHBvcnQgPSBleHBvcnRzLmV4cG9ydERhdGEgPSBleHBvcnRzLmRlbGV0ZVRyYW5zYWN0aW9uID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG52YXIgUGFwYSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicGFwYXBhcnNlXCIpKTtcbnZhciBkYXRlX2Zuc18xID0gcmVxdWlyZShcImRhdGUtZm5zXCIpO1xudmFyIHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xudmFyIExvZ0hlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9sb2cvaGVscGVyXCIpKTtcbnZhciBOb3RlSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9ub3RlL2hlbHBlclwiKSk7XG52YXIgTm90ZWxpbmtIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL25vdGVsaW5rL2hlbHBlclwiKSk7XG52YXIgcmVmRGF0ZSA9IG5ldyBEYXRlKCk7XG52YXIgZGVsZXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoc3BhY2UsIHRyYW5zYWN0aW9uSWQsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBMb2dIZWxwZXIuZGVsZXRlTG9nQnlUcmFuc2FjdGlvbklkKHNwYWNlLCB0cmFuc2FjdGlvbklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVUcmFuc2FjdGlvbiA9IGRlbGV0ZVRyYW5zYWN0aW9uO1xudmFyIGV4cG9ydERhdGEgPSBmdW5jdGlvbiAoc3BhY2UsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm90ZSwgbm90ZWxpbmssIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIE5vdGVIZWxwZXIuZ2V0Tm90ZShzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG5vdGUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBOb3RlbGlua0hlbHBlci5nZXROb3RlbGluayhzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG5vdGVsaW5rID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBub3RlOiBub3RlLFxuICAgICAgICAgICAgICAgICAgICBub3RlbGluazogbm90ZWxpbmtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzcG9uc2VdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZXhwb3J0RGF0YSA9IGV4cG9ydERhdGE7XG52YXIgdHJhbnNmb3JtRXhwZW5zZURhdGFGb3JFeHBvcnQgPSBmdW5jdGlvbiAoZXhwZW5zZUxpc3QsIHJlY2VpcHRNYXAsIGNhdGVnb3J5TWFwKSB7XG4gICAgcmV0dXJuIGV4cGVuc2VMaXN0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImV4cGVuc2VcIixcbiAgICAgICAgICAgIGNhdGVnb3J5OiAoKF9hID0gY2F0ZWdvcnlNYXBbaXRlbS5jYXRlZ29yeV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSB8fCBcIlwiLFxuICAgICAgICAgICAga2FrZWlibzogKChfYiA9IGNhdGVnb3J5TWFwW2l0ZW0uY2F0ZWdvcnldKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iua2FrZWlibykgfHwgXCJcIixcbiAgICAgICAgICAgIGRhdGU6IGl0ZW0uYmlsbERhdGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaXRlbS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGFtb3VudDogaXRlbS5hbW91bnQsXG4gICAgICAgICAgICBiaWxsRGVzY3JpcHRpb246IChfYyA9IHJlY2VpcHRNYXBbaXRlbS5iaWxsSWRdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBiaWxsTnVtYmVyOiAoX2QgPSByZWNlaXB0TWFwW2l0ZW0uYmlsbElkXSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm51bWJlcixcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5leHBvcnRzLnRyYW5zZm9ybUV4cGVuc2VEYXRhRm9yRXhwb3J0ID0gdHJhbnNmb3JtRXhwZW5zZURhdGFGb3JFeHBvcnQ7XG52YXIgdHJhbnNmb3JtSW5jb21lRGF0YUZvckV4cG9ydCA9IGZ1bmN0aW9uIChpbmNvbWVMaXN0LCBjYXRlZ29yeU1hcCkge1xuICAgIHJldHVybiBpbmNvbWVMaXN0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImluY29tZVwiLFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICgoX2EgPSBjYXRlZ29yeU1hcFtpdGVtLmNhdGVnb3J5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpIHx8IFwiXCIsXG4gICAgICAgICAgICBkYXRlOiBpdGVtLmJpbGxEYXRlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGl0ZW0uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBhbW91bnQ6IGl0ZW0uYW1vdW50LFxuICAgICAgICB9O1xuICAgIH0pO1xufTtcbmV4cG9ydHMudHJhbnNmb3JtSW5jb21lRGF0YUZvckV4cG9ydCA9IHRyYW5zZm9ybUluY29tZURhdGFGb3JFeHBvcnQ7XG52YXIgdHJhbnNmb3JtQnVkZ2V0RGF0YUZvckV4cG9ydCA9IGZ1bmN0aW9uIChidWRnZXRMaXN0LCBjYXRlZ29yeU1hcCkge1xuICAgIHJldHVybiBidWRnZXRMaXN0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJidWRnZXRcIixcbiAgICAgICAgICAgIGNhdGVnb3J5OiAoKF9hID0gY2F0ZWdvcnlNYXBbaXRlbS5jYXRlZ29yeUlkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpIHx8IFwiXCIsXG4gICAgICAgICAgICBrYWtlaWJvOiAoKF9iID0gY2F0ZWdvcnlNYXBbaXRlbS5jYXRlZ29yeUlkXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmtha2VpYm8pIHx8IFwiXCIsXG4gICAgICAgICAgICB5ZWFyOiBpdGVtLnllYXIsXG4gICAgICAgICAgICBtb250aDogaXRlbS5tb250aCxcbiAgICAgICAgICAgIGFtb3VudDogaXRlbS5hbW91bnQsXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuZXhwb3J0cy50cmFuc2Zvcm1CdWRnZXREYXRhRm9yRXhwb3J0ID0gdHJhbnNmb3JtQnVkZ2V0RGF0YUZvckV4cG9ydDtcbnZhciBpbXBvcnRFeHBlbnNlID0gZnVuY3Rpb24gKHNwYWNlLCBmaWxlLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRlbnQsIGV4cGVuc2VDb250ZW50LCBpbmNvbWVDb250ZW50LCBidWRnZXRDb250ZW50LCB0cmFuc2FjdGlvbklkLCBsb2dSZXNwb25zZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gUGFwYS5wYXJzZShmaWxlLmJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiksIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVDaGFyOiAnXCInLFxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVDaGFyOiAnXCInLFxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXI6IFwiLFwiLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmU6IFwiXFxyXFxuXCIsXG4gICAgICAgICAgICAgICAgICAgIHNraXBFbXB0eUxpbmVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1IZWFkZXI6IGZ1bmN0aW9uIChoKSB7IHJldHVybiBoLnRyaW0oKS5yZXBsYWNlKC9cIi9nLCBcIlwiKTsgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBleHBlbnNlQ29udGVudCA9IGNvbnRlbnQuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuICFbXCJpbmNvbWVcIiwgXCJidWRnZXRcIl0uaW5jbHVkZXMoaXRlbS50eXBlKTsgfSk7XG4gICAgICAgICAgICAgICAgaW5jb21lQ29udGVudCA9IGNvbnRlbnQuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udHlwZSA9PT0gXCJpbmNvbWVcIjsgfSk7XG4gICAgICAgICAgICAgICAgYnVkZ2V0Q29udGVudCA9IGNvbnRlbnQuZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0udHlwZSA9PT0gXCJidWRnZXRcIjsgfSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZCA9ICgwLCB1dWlkXzEudjQpKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBMb2dIZWxwZXIuYWRkTG9nKHNwYWNlLCB0cmFuc2FjdGlvbklkLCBuZXcgRGF0ZSgpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbG9nUmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2c6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBsb2dSZXNwb25zZS5fZG9jKSwgeyB0cmFuc2FjdGlvbkRhdGU6ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkobG9nUmVzcG9uc2UudHJhbnNhY3Rpb25EYXRlLCBcInl5eXktTU0tZGRcIikgfSksXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuaW1wb3J0RXhwZW5zZSA9IGltcG9ydEV4cGVuc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlbGV0ZUxvZ0J5VHJhbnNhY3Rpb25JZCA9IGV4cG9ydHMuYWRkTG9nID0gZXhwb3J0cy5nZXRMb2cgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgZ2V0Q29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZGJ1dGlsc1wiKS5nZXRDb2xsZWN0aW9uO1xudmFyIGRhdGVfZm5zXzEgPSByZXF1aXJlKFwiZGF0ZS1mbnNcIik7XG52YXIgZ2V0TG9nID0gZnVuY3Rpb24gKHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmltcG9ydExvZ0NvbGxlY3Rpb24sIG1vZGVsXzEuaW1wb3J0TG9nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoe30pLnNvcnQoeyB0cmFuc2FjdGlvbkRhdGU6IC0xIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3BvbnNlLm1hcChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHJlY29yZC5fZG9jKSwgeyBfaWQ6IHJlY29yZC5faWQsIHRyYW5zYWN0aW9uRGF0ZTogKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShyZWNvcmQudHJhbnNhY3Rpb25EYXRlLCBcInl5eXktTU0tZGRcIikgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldExvZyA9IGdldExvZztcbnZhciBhZGRMb2cgPSBmdW5jdGlvbiAoc3BhY2UsIHRyYW5zYWN0aW9uSWQsIHRyYW5zYWN0aW9uRGF0ZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmltcG9ydExvZ0NvbGxlY3Rpb24sIG1vZGVsXzEuaW1wb3J0TG9nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiB0cmFuc2FjdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25EYXRlOiB0cmFuc2FjdGlvbkRhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuYWRkTG9nID0gYWRkTG9nO1xudmFyIGRlbGV0ZUxvZ0J5VHJhbnNhY3Rpb25JZCA9IGZ1bmN0aW9uIChzcGFjZSwgdHJhbnNhY3Rpb25JZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLmltcG9ydExvZ0NvbGxlY3Rpb24sIG1vZGVsXzEuaW1wb3J0TG9nU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogdHJhbnNhY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVMb2dCeVRyYW5zYWN0aW9uSWQgPSBkZWxldGVMb2dCeVRyYW5zYWN0aW9uSWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW1wb3J0TG9nQ29sbGVjdGlvbiA9IGV4cG9ydHMuaW1wb3J0TG9nU2NoZW1hID0gdm9pZCAwO1xudmFyIG1vbmdvb3NlID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpO1xudmFyIFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbnZhciBpbXBvcnRMb2dTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICB0cmFuc2FjdGlvbklkOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHRyYW5zYWN0aW9uRGF0ZTogeyB0eXBlOiBEYXRlIH0sXG4gICAgZXhwZW5zZVJlY29yZHM6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgZXhwZW5zZVRvdGFsOiB7IHR5cGU6IE51bWJlciB9LFxuICAgIGluY29tZVJlY29yZHM6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgaW5jb21lVG90YWw6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgcmVjZWlwdFJlY29yZHM6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgcmVjZWlwdFRvdGFsOiB7IHR5cGU6IE51bWJlciB9LFxuICAgIGJ1ZGdldFJlY29yZHM6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgYnVkZ2V0VG90YWw6IHsgdHlwZTogTnVtYmVyIH0sXG4gICAgY2F0ZWdvcnlSZWNvcmRzOiB7IHR5cGU6IE51bWJlciB9LFxuICAgIGluY29tZUNhdGVnb3J5UmVjb3JkczogeyB0eXBlOiBOdW1iZXIgfSxcbiAgICB0YWdSZWNvcmRzOiB7IHR5cGU6IE51bWJlciB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlIH0pO1xuZXhwb3J0cy5pbXBvcnRMb2dTY2hlbWEgPSBpbXBvcnRMb2dTY2hlbWE7XG52YXIgaW1wb3J0TG9nQ29sbGVjdGlvbiA9IFwiaW1wb3J0LmxvZ1wiO1xuZXhwb3J0cy5pbXBvcnRMb2dDb2xsZWN0aW9uID0gaW1wb3J0TG9nQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1pZGRsZXdhcmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWlkZGxld2FyZXNcIik7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIuZ2V0KFwiL2ltcG9ydC9sb2cvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCBzZXJ2aWNlXzEuZ2V0TG9nKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRMb2cgPSB2b2lkIDA7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xudmFyIGdldExvZyA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBsb2dMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0TG9nKHJlcS5wYXJhbXMuc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBsb2dMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChsb2dMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldExvZyA9IGdldExvZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9oYW5kbGVyXCIpO1xudmFyIG1pZGRsZXdhcmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vbWlkZGxld2FyZXNcIik7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbnZhciBtdWx0ZXIgPSByZXF1aXJlKFwibXVsdGVyXCIpO1xudmFyIHVwbG9hZCA9IG11bHRlcigpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5wb3N0KFwiL2ltcG9ydC86c3BhY2VcIiwgdXBsb2FkLnNpbmdsZShcImZpbGVcIiksIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmltcG9ydEV4cGVuc2UpKTtcbiAgICByb3V0ZXIucG9zdChcIi9leHBvcnQvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmV4cG9ydERhdGEpKTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL2ltcG9ydC86c3BhY2UvdHJhbnNhY3Rpb24vOnRyYW5zYWN0aW9uSWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZGVsZXRlVHJhbnNhY3Rpb24pKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVUcmFuc2FjdGlvbiA9IGV4cG9ydHMuZXhwb3J0RGF0YSA9IGV4cG9ydHMuaW1wb3J0RXhwZW5zZSA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG52YXIgaW1wb3J0RXhwZW5zZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCByZXNwb25zZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmltcG9ydEV4cGVuc2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLmZpbGUsIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5pbXBvcnRFeHBlbnNlID0gaW1wb3J0RXhwZW5zZTtcbnZhciBleHBvcnREYXRhID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZXhwb3J0RGF0YShyZXEucGFyYW1zLnNwYWNlLCB1c2VySWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZXhwb3J0RGF0YSA9IGV4cG9ydERhdGE7XG52YXIgZGVsZXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWxldGVUcmFuc2FjdGlvbihyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLnRyYW5zYWN0aW9uSWQsIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVUcmFuc2FjdGlvbiA9IGRlbGV0ZVRyYW5zYWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEtleXdvcmRzID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBnZXRLZXl3b3JkcyA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEua2V5d29yZHNDb2xsZWN0aW9uLCBtb2RlbF8xLmtleXdvcmRzU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc1swXS5kYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBbXV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRLZXl3b3JkcyA9IGdldEtleXdvcmRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmtleXdvcmRzQ29sbGVjdGlvbiA9IGV4cG9ydHMua2V5d29yZHNTY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIGtleXdvcmRzU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgZGF0YTogeyB0eXBlOiBBcnJheSB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlLCBtaW5pbWl6ZTogZmFsc2UgfSk7XG5leHBvcnRzLmtleXdvcmRzU2NoZW1hID0ga2V5d29yZHNTY2hlbWE7XG52YXIga2V5d29yZHNDb2xsZWN0aW9uID0gXCJrZXl3b3Jkc1wiO1xuZXhwb3J0cy5rZXl3b3Jkc0NvbGxlY3Rpb24gPSBrZXl3b3Jkc0NvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLmdldChcIi9rZXl3b3Jkcy86c3BhY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0S2V5d29yZHMpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRLZXl3b3JkcyA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG52YXIgZ2V0S2V5d29yZHMgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleXdvcmRzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEhlbHBlci5nZXRLZXl3b3JkcyhyZXEucGFyYW1zLnNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAga2V5d29yZHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGtleXdvcmRzKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldEtleXdvcmRzID0gZ2V0S2V5d29yZHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRMYWJlbCA9IHZvaWQgMDtcbnZhciBheGlvcyA9IHJlcXVpcmUoXCJheGlvc1wiKTtcbnZhciBPTkVBVVRIX0FQSSA9IHByb2Nlc3MuZW52Lk9ORUFVVEhfQVBJIHx8IFwiaHR0cDovL2xvY2FsaG9zdDo0MDEwL2FwaVwiO1xudmFyIE5vdGVUYWdIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL25vdGUvdGFnL2hlbHBlclwiKSk7XG52YXIgTm90ZUhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vbm90ZS9oZWxwZXJcIikpO1xudmFyIGdldExhYmVsID0gZnVuY3Rpb24gKHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3RlVGFncywgbGFiZWxzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIE5vdGVUYWdIZWxwZXIuZ2V0VGFnKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbm90ZVRhZ3MgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBOb3RlSGVscGVyLmdldExhYmVscyhzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGxhYmVscyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGxhYmVsc107XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRMYWJlbCA9IGdldExhYmVsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5nZXQoXCIvbGFiZWwvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldExhYmVsKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TGFiZWwgPSB2b2lkIDA7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xudmFyIGdldExhYmVsID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIGxhYmVsTGlzdDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldExhYmVsKHJlcS5wYXJhbXMuc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBsYWJlbExpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKGxhYmVsTGlzdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRMYWJlbCA9IGdldExhYmVsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVNZXRhZGF0YURlZmluaXRpb24gPSBleHBvcnRzLmdldE1ldGFkYXRhRGVmaW5pdGlvbiA9IGV4cG9ydHMudXBkYXRlTWV0YWRhdGFEZWZpbml0aW9uID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciB1cGRhdGVNZXRhZGF0YURlZmluaXRpb24gPSBmdW5jdGlvbiAoc3BhY2UsIGRhdGEsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlLCBhbGxSZWNvcmRzLCByZXNwb25zZUxpc3QsIGlkTGlzdCwgaSwgcmVzcG9uc2VfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubWV0YWRhdGFEZWZpbml0aW9uQ29sbGVjdGlvbiwgbW9kZWxfMS5tZXRhZGF0YURlZmluaXRpb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYWxsUmVjb3JkcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZUxpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBpZExpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IGRhdGEubGVuZ3RoKSkgcmV0dXJuIFszLCA1XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHVwZGF0ZU1ldGFkYXRhRGVmaW5pdGlvbkl0ZW0oc3BhY2UsIGRhdGFbaV0sIGFsbFJlY29yZHMpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXNwb25zZV8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlTGlzdC5wdXNoKHJlc3BvbnNlXzEpO1xuICAgICAgICAgICAgICAgIGlkTGlzdC5wdXNoKHJlc3BvbnNlXzEuX2lkKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7IF9pZDogeyAkbmluOiBpZExpc3QgfSB9KV07XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCgpLnNvcnQoeyBncm91cDogXCJhc2NlbmRpbmdcIiwgbmFtZTogXCJhc2NlbmRpbmdcIiB9KV07XG4gICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnVwZGF0ZU1ldGFkYXRhRGVmaW5pdGlvbiA9IHVwZGF0ZU1ldGFkYXRhRGVmaW5pdGlvbjtcbnZhciB1cGRhdGVNZXRhZGF0YURlZmluaXRpb25JdGVtID0gZnVuY3Rpb24gKHNwYWNlLCBkYXRhLCBhbGxSZWNvcmRzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm1ldGFkYXRhRGVmaW5pdGlvbkNvbGxlY3Rpb24sIG1vZGVsXzEubWV0YWRhdGFEZWZpbml0aW9uU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLl9pZCkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKGRhdGEuX2lkLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgbGlua2FibGU6IGRhdGEubGlua2FibGUgJiYgZGF0YS50eXBlID09PSAnc2hvcnQtdGV4dCcgfSksIHsgbmV3OiB0cnVlLCB1cHNlcnQ6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyBsaW5rYWJsZTogZGF0YS5saW5rYWJsZSAmJiBkYXRhLnR5cGUgPT09ICdzaG9ydC10ZXh0JyB9KSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xudmFyIGdldE1ldGFkYXRhRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm1ldGFkYXRhRGVmaW5pdGlvbkNvbGxlY3Rpb24sIG1vZGVsXzEubWV0YWRhdGFEZWZpbml0aW9uU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKS5zb3J0KHsgZ3JvdXA6IFwiYXNjZW5kaW5nXCIsIG5hbWU6IFwiYXNjZW5kaW5nXCIgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRNZXRhZGF0YURlZmluaXRpb24gPSBnZXRNZXRhZGF0YURlZmluaXRpb247XG52YXIgZGVsZXRlTWV0YWRhdGFEZWZpbml0aW9uID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5tZXRhZGF0YURlZmluaXRpb25Db2xsZWN0aW9uLCBtb2RlbF8xLm1ldGFkYXRhRGVmaW5pdGlvblNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgbWV0YWRhdGFEZWZpbml0aW9uOiBbX2lkXSB9XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZU1ldGFkYXRhRGVmaW5pdGlvbiA9IGRlbGV0ZU1ldGFkYXRhRGVmaW5pdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tZXRhZGF0YURlZmluaXRpb25Db2xsZWN0aW9uID0gZXhwb3J0cy5tZXRhZGF0YURlZmluaXRpb25TY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIG1ldGFkYXRhRGVmaW5pdGlvblNjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICAgIHJlZmVyZW5jZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGdyb3VwOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHR5cGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgbGlua2FibGU6IHsgdHlwZTogQm9vbGVhbiB9XG59LCB7IHRpbWVzdGFtcHM6IHRydWUgfSk7XG5leHBvcnRzLm1ldGFkYXRhRGVmaW5pdGlvblNjaGVtYSA9IG1ldGFkYXRhRGVmaW5pdGlvblNjaGVtYTtcbnZhciBtZXRhZGF0YURlZmluaXRpb25Db2xsZWN0aW9uID0gXCJtZXRhZGF0YS5kZWZpbml0aW9uXCI7XG5leHBvcnRzLm1ldGFkYXRhRGVmaW5pdGlvbkNvbGxlY3Rpb24gPSBtZXRhZGF0YURlZmluaXRpb25Db2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5wb3N0KFwiL21ldGFkYXRhLWRlZmluaXRpb24vOnNwYWNlL2Z1bGxcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEudXBkYXRlTWV0YWRhdGFEZWZpbml0aW9uKSk7XG4gICAgcm91dGVyLmdldChcIi9tZXRhZGF0YS1kZWZpbml0aW9uLzpzcGFjZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRNZXRhZGF0YURlZmluaXRpb24pKTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL21ldGFkYXRhLWRlZmluaXRpb24vOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVNZXRhZGF0YURlZmluaXRpb24pKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVNZXRhZGF0YURlZmluaXRpb24gPSBleHBvcnRzLmdldE1ldGFkYXRhRGVmaW5pdGlvbiA9IGV4cG9ydHMudXBkYXRlTWV0YWRhdGFEZWZpbml0aW9uID0gdm9pZCAwO1xudmFyIEhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJcIikpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbnZhciB1cGRhdGVNZXRhZGF0YURlZmluaXRpb24gPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgbWV0YWRhdGFEZWZpbml0aW9uO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIudXBkYXRlTWV0YWRhdGFEZWZpbml0aW9uKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5ib2R5LCB1c2VySWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBtZXRhZGF0YURlZmluaXRpb24gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG1ldGFkYXRhRGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVNZXRhZGF0YURlZmluaXRpb24gPSB1cGRhdGVNZXRhZGF0YURlZmluaXRpb247XG52YXIgZ2V0TWV0YWRhdGFEZWZpbml0aW9uID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG1ldGFkYXRhRGVmaW5pdGlvbkxpc3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRNZXRhZGF0YURlZmluaXRpb24ocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1ldGFkYXRhRGVmaW5pdGlvbkxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG1ldGFkYXRhRGVmaW5pdGlvbkxpc3QpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0TWV0YWRhdGFEZWZpbml0aW9uID0gZ2V0TWV0YWRhdGFEZWZpbml0aW9uO1xudmFyIGRlbGV0ZU1ldGFkYXRhRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlTWV0YWRhdGFEZWZpbml0aW9uKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZU1ldGFkYXRhRGVmaW5pdGlvbiA9IGRlbGV0ZU1ldGFkYXRhRGVmaW5pdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE1ldGFkYXRhVmFsdWUgPSB2b2lkIDA7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuLi8uLi9ub3RlL21vZGVsXCIpO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgTWV0YWRhdGFEZWZpbml0aW9uSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9kZWZpbml0aW9uL2hlbHBlclwiKSk7XG52YXIgZ2V0Q29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZGJ1dGlsc1wiKS5nZXRDb2xsZWN0aW9uO1xudmFyIGdldE1ldGFkYXRhVmFsdWUgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCBtZXRhZGF0YURlZmluaXRpb25MaXN0LCByZXNwb25zZSwgaSwgaWQsIF9hLCBfYjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZUNvbGxlY3Rpb24sIG1vZGVsXzEubm90ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBNZXRhZGF0YURlZmluaXRpb25IZWxwZXIuZ2V0TWV0YWRhdGFEZWZpbml0aW9uKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFEZWZpbml0aW9uTGlzdCA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgbWV0YWRhdGFEZWZpbml0aW9uTGlzdC5sZW5ndGgpKSByZXR1cm4gWzMsIDVdO1xuICAgICAgICAgICAgICAgIGlkID0gbWV0YWRhdGFEZWZpbml0aW9uTGlzdFtpXS5faWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhRGVmaW5pdGlvbkxpc3RbaV0ubGlua2FibGUpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgX2EgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICBfYiA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCgpLmRpc3RpbmN0KGlkKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2FbX2JdID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyLCByZXNwb25zZV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRNZXRhZGF0YVZhbHVlID0gZ2V0TWV0YWRhdGFWYWx1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oYW5kbGVyXCIpO1xudmFyIG1pZGRsZXdhcmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWlkZGxld2FyZXNcIik7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIuZ2V0KFwiL21ldGFkYXRhLXZhbHVlLzpzcGFjZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXRNZXRhZGF0YVZhbHVlKSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TWV0YWRhdGFWYWx1ZSA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG52YXIgZ2V0TWV0YWRhdGFWYWx1ZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBtZXRhZGF0YVZhbHVlTGlzdDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldE1ldGFkYXRhVmFsdWUocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1ldGFkYXRhVmFsdWVMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChtZXRhZGF0YVZhbHVlTGlzdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRNZXRhZGF0YVZhbHVlID0gZ2V0TWV0YWRhdGFWYWx1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5icmFpbnN0b3JtVXNpbmdBaSA9IGV4cG9ydHMuZ2V0S2V5d29yZHMgPSBleHBvcnRzLmdldExhYmVscyA9IGV4cG9ydHMuX2FpX3BvcHVsYXRlID0gZXhwb3J0cy5fYWlfdHJhaW4gPSBleHBvcnRzLmJyb3dzZU5vdGVzID0gZXhwb3J0cy5nZXROb3Rlc0J5TWV0YWRhdGFWYWx1ZSA9IGV4cG9ydHMuc2VhcmNoTm90ZSA9IGV4cG9ydHMuc2VhcmNoTm90ZUJ5VGV4dCA9IGV4cG9ydHMuZGVsZXRlTm90ZUJ5UmVmZXJlbmNlTGlzdCA9IGV4cG9ydHMuZGVsZXRlTm90ZUJ5UmVmZXJlbmNlID0gZXhwb3J0cy5kZWxldGVOb3RlID0gZXhwb3J0cy5nZXROb3Rlc0J5UmVmZXJlbmNlTGlzdCA9IGV4cG9ydHMuZ2V0Tm90ZXNCeUZvbGRlcklkTGlzdCA9IGV4cG9ydHMuZGVsZXRlTm90ZXNCeUZvbGRlcklkTGlzdCA9IGV4cG9ydHMuZ2V0Tm90ZUJ5SWQgPSBleHBvcnRzLmdldE5vdGVCeUJvb2tyZWYgPSBleHBvcnRzLmdldE5vdGVCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0UmVjZW50bHlDcmVhdGVkTm90ZSA9IGV4cG9ydHMuZ2V0Tm90ZURpY3Rpb25hcnkgPSBleHBvcnRzLmdldE5vdGUgPSBleHBvcnRzLmNyZWF0ZU5vdGUgPSBleHBvcnRzLnVwZGF0ZU5vdGUgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgbG9kYXNoXzEgPSByZXF1aXJlKFwibG9kYXNoXCIpO1xudmFyIEdwdHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi9saWIvZ3B0dXRpbHNcIikpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi4vc2VxdWVuY2Uvc2VydmljZVwiKTtcbnZhciBOb3RlbGlua0hlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vbm90ZWxpbmsvaGVscGVyXCIpKTtcbnZhciBNZXRhZGF0YURlZmluaXRpb25IZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL21ldGFkYXRhL2RlZmluaXRpb24vaGVscGVyXCIpKTtcbnZhciBDb2xvcmZpbHRlckhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vY29sb3JmaWx0ZXIvaGVscGVyXCIpKTtcbnZhciBOb3RlbGlua0F1dG9IZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL25vdGVsaW5rL2F1dG8vaGVscGVyXCIpKTtcbnZhciBVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2xpYi9VdGlsc1wiKTtcbnZhciBwcm9tcHRfMSA9IHJlcXVpcmUoXCIuL3Byb21wdFwiKTtcbnZhciBBSV9BUEkgPSBwcm9jZXNzLmVudi5BSV9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjUwMDMvYXBpXCI7XG52YXIgU0lNSUxBUklUWV9BTEdPUklUSE0gPSBcInNpbWlsYXJpdHlcIjtcbnZhciB1cGRhdGVOb3RlID0gZnVuY3Rpb24gKHNwYWNlLCByZWxvYWQsIGRhdGEsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlc3BvbnNlLCBjb250ZW50VGV4dCwgX2EsIF9iLCBfYywgbm90ZWxpbmtzLCBub3RlUmVzcG9uc2UsIG5vdGU7XG4gICAgdmFyIF9kO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29udGVudFRleHQgPSBkYXRhLmNvbnRlbnQucmVwbGFjZSgvPFtePl0qPi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuX2lkKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoZGF0YS5faWQsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBkYXRhKSwgeyBjb250ZW50VGV4dDogY29udGVudFRleHQgfSksIHsgbmV3OiB0cnVlLCB1cHNlcnQ6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBtb2RlbCkuY3JlYXRlO1xuICAgICAgICAgICAgICAgIF9jID0gW19fYXNzaWduKHt9LCBkYXRhKV07XG4gICAgICAgICAgICAgICAgX2QgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBzZXJ2aWNlXzEubmV4dHZhbCkoXCJub3RlSWRcIiwgdW5kZWZpbmVkLCBzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQsIF9iLmFwcGx5KF9hLCBbX19hc3NpZ24uYXBwbHkodm9pZCAwLCBfYy5jb25jYXQoWyhfZC5yZWZlcmVuY2UgPSBfZS5zZW50KCksIF9kLmNvbnRlbnRUZXh0ID0gY29udGVudFRleHQsIF9kKV0pKV0pXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDU7XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCwgX2NhbGN1bGF0ZVZlY3RvcnMoc3BhY2UsIHJlc3BvbnNlLnJlZmVyZW5jZSldO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIE5vdGVsaW5rQXV0b0hlbHBlci5nZXROb3RlbGlua0F1dG9CeU5vdGVSZWYoc3BhY2UsIHJlc3BvbnNlLnJlZmVyZW5jZSldO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIG5vdGVsaW5rcyA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyByZWZlcmVuY2U6IHJlc3BvbnNlLnJlZmVyZW5jZSB9KV07XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgbm90ZVJlc3BvbnNlID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgIG5vdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChub3RlUmVzcG9uc2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub3RlID0gbm90ZVJlc3BvbnNlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVsaW5rczogbm90ZWxpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogbm90ZSxcbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy51cGRhdGVOb3RlID0gdXBkYXRlTm90ZTtcbnZhciBjcmVhdGVOb3RlID0gZnVuY3Rpb24gKHNwYWNlLCByZWxvYWQsIHBheWxvYWQsIHVzZXJJZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIGRhdGEsIF9hLCByZXNwb25zZSwgX2IsIF9jLCBfZCwgbm90ZWxpbmtzLCBub3RlUmVzcG9uc2UsIG5vdGU7XG4gICAgdmFyIF9lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcbiAgICAgICAgc3dpdGNoIChfZi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBheWxvYWQuYXV0b0dlbmVyYXRlT3RoZXJEZXRhaWxzKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX2VuaGFuY2VOb3RlRGF0YVVzaW5nQWkoc3BhY2UsIHBheWxvYWQubm90ZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2EgPSBfZW5oYW5jZU5vdGVEYXRhKHBheWxvYWQubm90ZSk7XG4gICAgICAgICAgICAgICAgX2YubGFiZWwgPSAzO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfYTtcbiAgICAgICAgICAgICAgICBpZiAoIXBheWxvYWQuYXV0b0dlbmVyYXRlT3RoZXJEZXRhaWxzKSByZXR1cm4gWzMsIDVdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgX2VuaGFuY2VOb3RlRGF0YVdpdGhNZXRhZGF0YUZyb21SZWNlbnROb3RlKHNwYWNlLCBkYXRhKV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDU7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIF9jID0gKF9iID0gbW9kZWwpLmNyZWF0ZTtcbiAgICAgICAgICAgICAgICBfZCA9IFtfX2Fzc2lnbih7fSwgZGF0YSldO1xuICAgICAgICAgICAgICAgIF9lID0ge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgc2VydmljZV8xLm5leHR2YWwpKFwibm90ZUlkXCIsIHVuZGVmaW5lZCwgc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFs0LCBfYy5hcHBseShfYiwgW19fYXNzaWduLmFwcGx5KHZvaWQgMCwgX2QuY29uY2F0KFsoX2UucmVmZXJlbmNlID0gX2Yuc2VudCgpLCBfZSldKSldKV07XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBfY2FsY3VsYXRlVmVjdG9ycyhzcGFjZSwgcmVzcG9uc2UucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTm90ZWxpbmtBdXRvSGVscGVyLmdldE5vdGVsaW5rQXV0b0J5Tm90ZVJlZihzcGFjZSwgcmVzcG9uc2UucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgbm90ZWxpbmtzID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IHJlZmVyZW5jZTogcmVzcG9uc2UucmVmZXJlbmNlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgbm90ZVJlc3BvbnNlID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgIG5vdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChub3RlUmVzcG9uc2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub3RlID0gbm90ZVJlc3BvbnNlWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVsaW5rczogbm90ZWxpbmtzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogbm90ZSxcbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVOb3RlID0gY3JlYXRlTm90ZTtcbnZhciBnZXROb3RlID0gZnVuY3Rpb24gKHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGUgPSBnZXROb3RlO1xudmFyIF9jYWxjdWxhdGVWZWN0b3JzID0gZnVuY3Rpb24gKHNwYWNlLCBub3RlcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmV0cmFpbiwgdXBkYXRlQ291bnQsIG5vdGVzQ291bnQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHJhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBzZXJ2aWNlXzEubmV4dHZhbCkoXCJub3RlX3VwZGF0ZV9jb3VudFwiLCBcImFpXCIsIHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdXBkYXRlQ291bnQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codXBkYXRlQ291bnQpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVDb3VudCA8PSAyMCkge1xuICAgICAgICAgICAgICAgICAgICByZXRyYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUNvdW50ID4gMjAgJiYgdXBkYXRlQ291bnQgPD0gMTAwICYmIHVwZGF0ZUNvdW50ICUgMTAgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cmFpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVDb3VudCA+IDEwMCAmJiB1cGRhdGVDb3VudCA8PSA1MDAgJiYgdXBkYXRlQ291bnQgJSAyNSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXRyYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUNvdW50ID4gNTAwICYmIHVwZGF0ZUNvdW50IDw9IDEwMDAgJiYgdXBkYXRlQ291bnQgJSA1MCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXRyYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUNvdW50ID4gMTAwMCAmJiB1cGRhdGVDb3VudCAlIDEwMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXRyYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEodXBkYXRlQ291bnQgJSAyMDAgPT09IDApKSByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCgpLmVzdGltYXRlZERvY3VtZW50Q291bnQoKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbm90ZXNDb3VudCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBzZXJ2aWNlXzEucmVzZXR2YWwpKG5vdGVzQ291bnQgKyAyLCBcIm5vdGVfdXBkYXRlX2NvdW50XCIsIFwiYWlcIiwgc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghcmV0cmFpbikgcmV0dXJuIFszLCA3XTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIi0tLXJldHJhaW5pbmdcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgZXhwb3J0cy5fYWlfdHJhaW4pKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIGV4cG9ydHMuX2FpX3BvcHVsYXRlKShzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDc7XG4gICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbNCwgX2FpX3BvcHVsYXRlX2Zvcl9ub3RlKHNwYWNlLCBub3RlcmVmKV07XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xudmFyIGdldE5vdGVEaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzLCBfYSwgX2I7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIF9hID0gX2VucmljaFdpdGhHcm91cENvbG9yO1xuICAgICAgICAgICAgICAgIF9iID0gW3NwYWNlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCwgX2EuYXBwbHkodm9pZCAwLCBfYi5jb25jYXQoW19jLnNlbnQoKV0pKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWQ6IGl0ZW0uX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IGl0ZW0ucmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6ICgwLCBVdGlsc18xLmlzRW1wdHlPclNwYWNlcykoaXRlbS5zdW1tYXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGl0ZW0uYXV0b0dlbmVyYXRlZFN1bW1hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLnN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGl0ZW0uY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiBpdGVtLmxhYmVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVEaWN0aW9uYXJ5ID0gZ2V0Tm90ZURpY3Rpb25hcnk7XG52YXIgX2VucmljaFdpdGhHcm91cENvbG9yID0gZnVuY3Rpb24gKHNwYWNlLCBkYXRhKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaWx0ZXJHcm91cExpc3QsIHJlc3BvbnNlLCBqLCBfcmVjb3JkLCBvdXQsIF9maWx0ZXJHcm91cExpc3QsIGksIF9maWx0ZXIsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgQ29sb3JmaWx0ZXJIZWxwZXIuZ2V0Q29sb3JmaWx0ZXIoc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBmaWx0ZXJHcm91cExpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBbXTtcbiAgICAgICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKCEoaiA8IGRhdGEubGVuZ3RoKSkgcmV0dXJuIFszLCA4XTtcbiAgICAgICAgICAgICAgICBfcmVjb3JkID0gZGF0YVtqXS5fZG9jO1xuICAgICAgICAgICAgICAgIG91dCA9IF9fYXNzaWduKHt9LCBfcmVjb3JkKTtcbiAgICAgICAgICAgICAgICBfZmlsdGVyR3JvdXBMaXN0ID0gZmlsdGVyR3JvdXBMaXN0XG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGZpbHRlcikgeyByZXR1cm4gISgwLCBVdGlsc18xLmlzRW1wdHlPclNwYWNlcykoZmlsdGVyLl9kb2MuY29sb3IpOyB9KVxuICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgX2ZpbHRlckdyb3VwTGlzdC5sZW5ndGgpKSByZXR1cm4gWzMsIDZdO1xuICAgICAgICAgICAgICAgIF9maWx0ZXIgPSBfZmlsdGVyR3JvdXBMaXN0W2ldLl9kb2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBfcHJvY2Vzc0ZpbHRlclBlclJlY29yZChzcGFjZSwgX3JlY29yZCwgX2ZpbHRlcildO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKG91dGNvbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmNvbG9yID0gX2ZpbHRlci5jb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnB1c2gob3V0KTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDc7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiwgcmVzcG9uc2VdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbnZhciBfcHJvY2Vzc0ZpbHRlclBlclJlY29yZCA9IGZ1bmN0aW9uIChzcGFjZV8xLCByZWNvcmRfMSwgX2EpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIFtzcGFjZV8xLCByZWNvcmRfMSwgX2FdLCB2b2lkIDAsIGZ1bmN0aW9uIChzcGFjZSwgcmVjb3JkLCBfYikge1xuICAgIHZhciBtZXRhZGF0YURlZmluaXRpb25MaXN0LCBzZWFyY2hGaWVsZHMsIG91dGNvbWUsIGlzVmFsaWRUZXh0LCB0ZXh0UmVnZXhwO1xuICAgIHZhciB0ZXh0ID0gX2IudGV4dCwgdGV4dExpc3QgPSBfYi50ZXh0TGlzdCwgc2VhcmNoUHJlZiA9IF9iLnNlYXJjaFByZWY7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgTWV0YWRhdGFEZWZpbml0aW9uSGVscGVyLmdldE1ldGFkYXRhRGVmaW5pdGlvbihzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1ldGFkYXRhRGVmaW5pdGlvbkxpc3QgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgc2VhcmNoRmllbGRzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaFByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VhcmNoUHJlZikuZm9yRWFjaChmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoUHJlZltmaWVsZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoRmllbGRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpc1ZhbGlkVGV4dCA9ICEoMCwgVXRpbHNfMS5pc0VtcHR5T3JTcGFjZXMpKHRleHQpO1xuICAgICAgICAgICAgICAgIHRleHRSZWdleHAgPSBuZXcgUmVnRXhwKHRleHQsIFwiaVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRUZXh0ICYmIChzZWFyY2hGaWVsZHMubGVuZ3RoICE9PSAxIHx8IHRleHRMaXN0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkVGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAoc2VhcmNoRmllbGRzLmxlbmd0aCA9PT0gMCB8fCBzZWFyY2hGaWVsZHMuaW5jbHVkZXMoXCJjb250ZW50XCIpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmNvbnRlbnQubWF0Y2godGV4dFJlZ2V4cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRUZXh0ICYmIHNlYXJjaEZpZWxkcy5pbmNsdWRlcyhcIm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5uYW1lLm1hdGNoKHRleHRSZWdleHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkVGV4dCAmJiBzZWFyY2hGaWVsZHMuaW5jbHVkZXMoXCJsYWJlbHNcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBsb2Rhc2hfMS5pbnRlcnNlY3Rpb24pKHJlY29yZC5sYWJlbHMsIHRleHQuc3BsaXQoXCIgXCIpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hGaWVsZHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaEZpZWxkcy5pbmNsdWRlcyhcImxhYmVsc1wiKSAmJlxuICAgICAgICAgICAgICAgICAgICB0ZXh0TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgbG9kYXNoXzEuaW50ZXJzZWN0aW9uKShyZWNvcmQubGFiZWxzLCB0ZXh0TGlzdCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0cnVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRhZGF0YURlZmluaXRpb25MaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRUZXh0ICYmIHNlYXJjaEZpZWxkcy5pbmNsdWRlcyhpdGVtLl9pZC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZFtpdGVtLl9pZC50b1N0cmluZygpXS5tYXRjaCh0ZXh0UmVnZXhwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hGaWVsZHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hGaWVsZHMuaW5jbHVkZXMoaXRlbS5faWQudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgbG9kYXNoXzEuaW50ZXJzZWN0aW9uKShyZWNvcmRbaXRlbS5faWQudG9TdHJpbmcoKV0sIHRleHRMaXN0KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGZhbHNlXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgZ2V0UmVjZW50bHlDcmVhdGVkTm90ZSA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZUNvbGxlY3Rpb24sIG1vZGVsXzEubm90ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKCkuc29ydCh7ICRuYXR1cmFsOiAtMSB9KS5saW1pdCgxKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzWzBdXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFJlY2VudGx5Q3JlYXRlZE5vdGUgPSBnZXRSZWNlbnRseUNyZWF0ZWROb3RlO1xudmFyIGdldE5vdGVCeVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChzcGFjZSwgcmVmZXJlbmNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcmVzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyByZWZlcmVuY2U6IHJlZmVyZW5jZSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzWzBdXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVCeVJlZmVyZW5jZSA9IGdldE5vdGVCeVJlZmVyZW5jZTtcbnZhciBnZXROb3RlQnlCb29rcmVmID0gZnVuY3Rpb24gKHNwYWNlLCBib29rcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZUNvbGxlY3Rpb24sIG1vZGVsXzEubm90ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHsgYm9va3JlZkxpc3Q6IHsgJGluOiBbYm9va3JlZl0gfSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVCeUJvb2tyZWYgPSBnZXROb3RlQnlCb29rcmVmO1xudmFyIGdldE5vdGVCeUlkID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXM7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IF9pZDogX2lkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzWzBdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVCeUlkID0gZ2V0Tm90ZUJ5SWQ7XG52YXIgZGVsZXRlTm90ZXNCeUZvbGRlcklkTGlzdCA9IGZ1bmN0aW9uIChzcGFjZSwgZm9sZGVySWRMaXN0KSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZUNvbGxlY3Rpb24sIG1vZGVsXzEubm90ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgZm9sZGVySWQ6IHsgJGluOiBmb2xkZXJJZExpc3QgfSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZU5vdGVzQnlGb2xkZXJJZExpc3QgPSBkZWxldGVOb3Rlc0J5Rm9sZGVySWRMaXN0O1xudmFyIGdldE5vdGVzQnlGb2xkZXJJZExpc3QgPSBmdW5jdGlvbiAoc3BhY2UsIGZvbGRlcklkTGlzdCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGZvbGRlcklkOiB7ICRpbjogZm9sZGVySWRMaXN0IH0gfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXROb3Rlc0J5Rm9sZGVySWRMaXN0ID0gZ2V0Tm90ZXNCeUZvbGRlcklkTGlzdDtcbnZhciBnZXROb3Rlc0J5UmVmZXJlbmNlTGlzdCA9IGZ1bmN0aW9uIChzcGFjZSwgcmVmTGlzdCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IHJlZmVyZW5jZTogeyAkaW46IHJlZkxpc3QgfSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVzQnlSZWZlcmVuY2VMaXN0ID0gZ2V0Tm90ZXNCeVJlZmVyZW5jZUxpc3Q7XG52YXIgZGVsZXRlTm90ZSA9IGZ1bmN0aW9uIChzcGFjZSwgX2lkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZUNvbGxlY3Rpb24sIG1vZGVsXzEubm90ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgbm90ZTogX2lkIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlTm90ZSA9IGRlbGV0ZU5vdGU7XG52YXIgZGVsZXRlTm90ZUJ5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyByZWZlcmVuY2U6IHJlZmVyZW5jZSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTm90ZWxpbmtIZWxwZXIuZGVsZXRlTm90ZWxpbmtCeVJlZmVyZW5jZShzcGFjZSwgcmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTm90ZWxpbmtBdXRvSGVscGVyLmRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2Uoc3BhY2UsIHJlZmVyZW5jZSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgbm90ZTogcmVmZXJlbmNlIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlTm90ZUJ5UmVmZXJlbmNlID0gZGVsZXRlTm90ZUJ5UmVmZXJlbmNlO1xudmFyIGRlbGV0ZU5vdGVCeVJlZmVyZW5jZUxpc3QgPSBmdW5jdGlvbiAoc3BhY2UsIHBheWxvYWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyByZWZlcmVuY2U6IHsgJGluOiBwYXlsb2FkIH0gfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIE5vdGVsaW5rSGVscGVyLmRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2VMaXN0KHNwYWNlLCBwYXlsb2FkKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgTm90ZWxpbmtBdXRvSGVscGVyLmRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2VMaXN0KHNwYWNlLCBwYXlsb2FkKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBub3RlOiBwYXlsb2FkIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlTm90ZUJ5UmVmZXJlbmNlTGlzdCA9IGRlbGV0ZU5vdGVCeVJlZmVyZW5jZUxpc3Q7XG52YXIgc2VhcmNoTm90ZUJ5VGV4dCA9IGZ1bmN0aW9uIChzcGFjZSwgdGV4dCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZUNvbGxlY3Rpb24sIG1vZGVsXzEubm90ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0ZXh0OiB7ICRzZWFyY2g6IFwiXFxcIlwiLmNvbmNhdCh0ZXh0LCBcIlxcXCJcIiksICRjYXNlU2Vuc2l0aXZlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnNlYXJjaE5vdGVCeVRleHQgPSBzZWFyY2hOb3RlQnlUZXh0O1xudmFyIHNlYXJjaE5vdGUgPSBmdW5jdGlvbiAoc3BhY2UsIHRleHQsIHRleHRMaXN0LCBzZWFyY2hQcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGV4dCwgbW9kZWwsIGNvbmRpdGlvbiwgcmVzO1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfdGV4dCA9IChfYSA9IHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGV4dC50b0xvd2VyQ2FzZSgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvICsvZywgXCIgXCIpO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIF9nZXRTZWFyY2hDb25kaXRpb24oc3BhY2UsIF90ZXh0LCB0ZXh0TGlzdCwgc2VhcmNoUHJlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyAkb3I6IGNvbmRpdGlvbiB9KS5zb3J0KHsgY3JlYXRlZEF0OiAtMSB9KV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtLl9kb2MpLCB7IHN1bW1hcnk6ICgwLCBVdGlsc18xLmlzRW1wdHlPclNwYWNlcykoaXRlbS5zdW1tYXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGl0ZW0uYXV0b0dlbmVyYXRlZFN1bW1hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLnN1bW1hcnkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnNlYXJjaE5vdGUgPSBzZWFyY2hOb3RlO1xudmFyIF9nZXRTZWFyY2hDb25kaXRpb24gPSBmdW5jdGlvbiAoc3BhY2UsIHRleHQsIHRleHRMaXN0LCBzZWFyY2hQcmVmKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtZXRhZGF0YURlZmluaXRpb25MaXN0LCBzZWFyY2hGaWVsZHMsIGNvbmRpdGlvbiwgaXNWYWxpZFRleHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgTWV0YWRhdGFEZWZpbml0aW9uSGVscGVyLmdldE1ldGFkYXRhRGVmaW5pdGlvbihzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1ldGFkYXRhRGVmaW5pdGlvbkxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgc2VhcmNoRmllbGRzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaFByZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2VhcmNoUHJlZikuZm9yRWFjaChmdW5jdGlvbiAoZmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoUHJlZltmaWVsZE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoRmllbGRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgIGlzVmFsaWRUZXh0ID0gISgwLCBVdGlsc18xLmlzRW1wdHlPclNwYWNlcykodGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRUZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWFyY2hGaWVsZHMubGVuZ3RoID09PSAwIHx8IHNlYXJjaEZpZWxkcy5pbmNsdWRlcyhcImNvbnRlbnRcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG5ldyBSZWdFeHAodGV4dCwgXCJpXCIpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRUZXh0ICYmIHNlYXJjaEZpZWxkcy5pbmNsdWRlcyhcIm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmV3IFJlZ0V4cCh0ZXh0LCBcImlcIiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFRleHQgJiYgc2VhcmNoRmllbGRzLmluY2x1ZGVzKFwibGFiZWxzXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbjogdGV4dC5zcGxpdChcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaEZpZWxkcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoRmllbGRzLmluY2x1ZGVzKFwibGFiZWxzXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIHRleHRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGluOiB0ZXh0TGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRhZGF0YURlZmluaXRpb25MaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRUZXh0ICYmIHNlYXJjaEZpZWxkcy5pbmNsdWRlcyhpdGVtLl9pZC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uLnB1c2goKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FbaXRlbS5faWQudG9TdHJpbmcoKV0gPSBuZXcgUmVnRXhwKHRleHQsIFwiaVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hGaWVsZHMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hGaWVsZHMuaW5jbHVkZXMoaXRlbS5faWQudG9TdHJpbmcoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbi5wdXNoKChfYiA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iW2l0ZW0uX2lkLnRvU3RyaW5nKCldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkaW46IHRleHRMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgW3t9XV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgY29uZGl0aW9uXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgZ2V0Tm90ZXNCeU1ldGFkYXRhVmFsdWUgPSBmdW5jdGlvbiAoc3BhY2UsIG1ldGFkYXRhSWQsIHBheWxvYWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCByZXM7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXRhZGF0YUlkID09PSBcImxhYmVsXCIpKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKHsgbGFiZWxzOiBuZXcgUmVnRXhwKHBheWxvYWQudmFsdWUsIFwiaVwiKSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoeyBjcmVhdGVkQXQ6IC0xIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0LCBtb2RlbFxuICAgICAgICAgICAgICAgICAgICAuZmluZCgoX2EgPSB7fSwgX2FbbWV0YWRhdGFJZF0gPSBuZXcgUmVnRXhwKHBheWxvYWQudmFsdWUsIFwiaVwiKSwgX2EpKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCh7IGNyZWF0ZWRBdDogLTEgfSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDQ7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiwgcmVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGl0ZW0uX2RvYyksIHsgc3VtbWFyeTogKDAsIFV0aWxzXzEuaXNFbXB0eU9yU3BhY2VzKShpdGVtLnN1bW1hcnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpdGVtLmF1dG9HZW5lcmF0ZWRTdW1tYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLnN1bW1hcnkgfSk7XG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Tm90ZXNCeU1ldGFkYXRhVmFsdWUgPSBnZXROb3Rlc0J5TWV0YWRhdGFWYWx1ZTtcbnZhciBicm93c2VOb3RlcyA9IGZ1bmN0aW9uIChzcGFjZSwgcGF5bG9hZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHJlcywgcmVmZXJlbmNlTm90ZXMsIHJlZmVyZW5jZUtleXdvcmRzXzE7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIShwYXlsb2FkLm1ldGFkYXRhSWQgPT09IFwicmVsYXRlZFwiKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlOiB7ICRpbjogcGF5bG9hZC5tZXRhZGF0YVZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VOb3RlcyA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VLZXl3b3Jkc18xID0gW107XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlTm90ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VLZXl3b3Jkc18xID0gcmVmZXJlbmNlS2V5d29yZHNfMS5jb25jYXQoaXRlbS5rZXl3b3Jkcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlS2V5d29yZHNfMSA9ICgwLCBsb2Rhc2hfMS51bmlxKShyZWZlcmVuY2VLZXl3b3Jkc18xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXl3b3JkczogeyAkaW46IHJlZmVyZW5jZUtleXdvcmRzXzEgfSxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KHsgY3JlYXRlZEF0OiAtMSB9KV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNV07XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCwgbW9kZWxcbiAgICAgICAgICAgICAgICAgICAgLmZpbmQoKF9hID0ge30sXG4gICAgICAgICAgICAgICAgICAgIF9hW3BheWxvYWQubWV0YWRhdGFJZF0gPSBuZXcgUmVnRXhwKHBheWxvYWQubWV0YWRhdGFWYWx1ZS50b1N0cmluZygpLCBcImlcIiksXG4gICAgICAgICAgICAgICAgICAgIF9hKSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoeyBjcmVhdGVkQXQ6IC0xIH0pXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXMgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2IubGFiZWwgPSA1O1xuICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIsIHJlcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtLl9kb2MpLCB7IHN1bW1hcnk6ICgwLCBVdGlsc18xLmlzRW1wdHlPclNwYWNlcykoaXRlbS5zdW1tYXJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaXRlbS5hdXRvR2VuZXJhdGVkU3VtbWFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5zdW1tYXJ5IH0pO1xuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmJyb3dzZU5vdGVzID0gYnJvd3NlTm90ZXM7XG52YXIgX2FpX3RyYWluID0gZnVuY3Rpb24gKHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnJfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkFJX0FQST1cIiwgQUlfQVBJKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zLmdldChcIlwiLmNvbmNhdChBSV9BUEksIFwiL1wiKS5jb25jYXQoU0lNSUxBUklUWV9BTEdPUklUSE0sIFwiL1wiKS5jb25jYXQoc3BhY2UsIFwiL3RyYWluXCIpLCB7fSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGVycl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8xKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuX2FpX3RyYWluID0gX2FpX3RyYWluO1xudmFyIF9haV9wb3B1bGF0ZSA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXJyXzI7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF4aW9zLmdldChcIlwiLmNvbmNhdChBSV9BUEksIFwiL1wiKS5jb25jYXQoU0lNSUxBUklUWV9BTEdPUklUSE0sIFwiL1wiKS5jb25jYXQoc3BhY2UsIFwiL3BvcHVsYXRlXCIpLCB7fSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVycl8yID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuX2FpX3BvcHVsYXRlID0gX2FpX3BvcHVsYXRlO1xudmFyIF9haV9wb3B1bGF0ZV9mb3Jfbm90ZSA9IGZ1bmN0aW9uIChzcGFjZSwgcmVmZXJlbmNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnJfMztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYXhpb3MuZ2V0KFwiXCIuY29uY2F0KEFJX0FQSSwgXCIvXCIpLmNvbmNhdChTSU1JTEFSSVRZX0FMR09SSVRITSwgXCIvXCIpLmNvbmNhdChzcGFjZSwgXCIvcG9wdWxhdGUvXCIpLmNvbmNhdChyZWZlcmVuY2UpLCB7fSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGVycl8zID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycl8zLmRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgM107XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xudmFyIGdldExhYmVscyA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGlzdGluY3QoXCJsYWJlbHNcIildO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRMYWJlbHMgPSBnZXRMYWJlbHM7XG52YXIgZ2V0S2V5d29yZHMgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRpc3RpbmN0KFwia2V5d29yZHNcIildO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRLZXl3b3JkcyA9IGdldEtleXdvcmRzO1xudmFyIGJyYWluc3Rvcm1Vc2luZ0FpID0gZnVuY3Rpb24gKHNwYWNlLCBwYXlsb2FkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBncHRSZXNwb25zZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBHcHR1dGlscy5wcmVkaWN0KCgwLCBwcm9tcHRfMS5nZXRCcmFpbnN0b3JtUHJvbXB0KShwYXlsb2FkLnVzZUJvb2tNb2RlLCBwYXlsb2FkLnRleHQsIHBheWxvYWQuaW5zdHJ1Y3Rpb25zLCBwYXlsb2FkLmJvb2tOYW1lLCBwYXlsb2FkLmF1dGhvck5hbWUpKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZ3B0UmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZ3B0UmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZ3B0UmVzcG9uc2UgfHwgcGF5bG9hZC50ZXh0XTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmJyYWluc3Rvcm1Vc2luZ0FpID0gYnJhaW5zdG9ybVVzaW5nQWk7XG52YXIgX2VuaGFuY2VOb3RlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfZGF0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIF9kYXRhID0gKDAsIGxvZGFzaF8xLmNsb25lRGVlcCkoZGF0YSk7XG4gICAgICAgIF9kYXRhLmNvbnRlbnRUZXh0ID0gX2RhdGEuY29udGVudC5yZXBsYWNlKC88W14+XSo+L2csIFwiXCIpO1xuICAgICAgICBpZiAoKDAsIFV0aWxzXzEuaXNFbXB0eU9yU3BhY2VzKShfZGF0YS5zdW1tYXJ5KSkge1xuICAgICAgICAgICAgX2RhdGEuc3VtbWFyeSA9IF9kYXRhLmNvbnRlbnRUZXh0LnN1YnN0cmluZygwLCAyNTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgVXRpbHNfMS5pc0VtcHR5T3JTcGFjZXMpKF9kYXRhLm5hbWUpKSB7XG4gICAgICAgICAgICBfZGF0YS5uYW1lID0gX2RhdGEuY29udGVudFRleHQuc3Vic3RyaW5nKDAsIDI1MCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsyLCBfZGF0YV07XG4gICAgfSk7XG59KTsgfTtcbnZhciBfZW5oYW5jZU5vdGVEYXRhVXNpbmdBaSA9IGZ1bmN0aW9uIChzcGFjZSwgZGF0YSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2RhdGEsIGdwdFJlc3BvbnNlVGV4dCwgX2EsIF9iLCBfYywgX2QsIGdwdFJlc3BvbnNlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9kYXRhID0gKDAsIGxvZGFzaF8xLmNsb25lRGVlcCkoZGF0YSk7XG4gICAgICAgICAgICAgICAgX2RhdGEuY29udGVudFRleHQgPSBfZGF0YS5jb250ZW50LnJlcGxhY2UoLzxbXj5dKj4vZywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBVdGlsc18xLmlzRW1wdHlPclNwYWNlcykoX2RhdGEuY29udGVudFRleHQpIHx8IF9kYXRhLmNvbnRlbnRUZXh0Lmxlbmd0aCA8PSAyMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIF9lbmhhbmNlTm90ZURhdGEoX2RhdGEpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2IgPSAoX2EgPSBHcHR1dGlscykucHJlZGljdDtcbiAgICAgICAgICAgICAgICBfYyA9IHByb21wdF8xLmdldEF1dG9HZW5lcmF0ZWRBdHRyaWJ1dGVzUHJvbXB0O1xuICAgICAgICAgICAgICAgIF9kID0gW2RhdGEuY29udGVudF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgZXhwb3J0cy5nZXRMYWJlbHMpKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbNCwgX2IuYXBwbHkoX2EsIFtfYy5hcHBseSh2b2lkIDAsIF9kLmNvbmNhdChbX2Uuc2VudCgpXSkpXSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGdwdFJlc3BvbnNlVGV4dCA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBncHRSZXNwb25zZSA9IEpTT04ucGFyc2UoZ3B0UmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBfZGF0YS5uYW1lID0gZ3B0UmVzcG9uc2UgPT09IG51bGwgfHwgZ3B0UmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdwdFJlc3BvbnNlLnRpdGxlO1xuICAgICAgICAgICAgICAgIF9kYXRhLnN1bW1hcnkgPSBncHRSZXNwb25zZSA9PT0gbnVsbCB8fCBncHRSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3B0UmVzcG9uc2Uuc3VtbWFyeTtcbiAgICAgICAgICAgICAgICBfZGF0YS5sYWJlbHMgPSBncHRSZXNwb25zZSA9PT0gbnVsbCB8fCBncHRSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3B0UmVzcG9uc2UubGFiZWxzO1xuICAgICAgICAgICAgICAgIF9kYXRhLnByaW1hcnlMYWJlbCA9IGdwdFJlc3BvbnNlID09PSBudWxsIHx8IGdwdFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncHRSZXNwb25zZS5wcmltYXJ5TGFiZWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBfZGF0YV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xudmFyIF9lbmhhbmNlTm90ZURhdGFXaXRoTWV0YWRhdGFGcm9tUmVjZW50Tm90ZSA9IGZ1bmN0aW9uIChzcGFjZSwgZGF0YSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjZW50Tm90ZSwgX2EsIF9pZCwgaWQsIG5hbWUsIGNvbnRlbnQsIGNvbnRlbnRUZXh0LCByZWZlcmVuY2UsIGxhYmVscywgcHJpbWFyeUxhYmVsLCBzdW1tYXJ5LCBib29rcmVmTGlzdCwgY3JlYXRlZEF0LCB1cGRhdGVkQXQsIF9fdiwgbWV0YWRhdGFGaWVsZHMsIF9kYXRhO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsICgwLCBleHBvcnRzLmdldFJlY2VudGx5Q3JlYXRlZE5vdGUpKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVjZW50Tm90ZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZWNlbnROb3RlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VudE5vdGUgfHwgIShyZWNlbnROb3RlID09PSBudWxsIHx8IHJlY2VudE5vdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlY2VudE5vdGUuX2RvYykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBkYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2EgPSByZWNlbnROb3RlLl9kb2MsIF9pZCA9IF9hLl9pZCwgaWQgPSBfYS5pZCwgbmFtZSA9IF9hLm5hbWUsIGNvbnRlbnQgPSBfYS5jb250ZW50LCBjb250ZW50VGV4dCA9IF9hLmNvbnRlbnRUZXh0LCByZWZlcmVuY2UgPSBfYS5yZWZlcmVuY2UsIGxhYmVscyA9IF9hLmxhYmVscywgcHJpbWFyeUxhYmVsID0gX2EucHJpbWFyeUxhYmVsLCBzdW1tYXJ5ID0gX2Euc3VtbWFyeSwgYm9va3JlZkxpc3QgPSBfYS5ib29rcmVmTGlzdCwgY3JlYXRlZEF0ID0gX2EuY3JlYXRlZEF0LCB1cGRhdGVkQXQgPSBfYS51cGRhdGVkQXQsIF9fdiA9IF9hLl9fdiwgbWV0YWRhdGFGaWVsZHMgPSBfX3Jlc3QoX2EsIFtcIl9pZFwiLCBcImlkXCIsIFwibmFtZVwiLCBcImNvbnRlbnRcIiwgXCJjb250ZW50VGV4dFwiLCBcInJlZmVyZW5jZVwiLCBcImxhYmVsc1wiLCBcInByaW1hcnlMYWJlbFwiLCBcInN1bW1hcnlcIiwgXCJib29rcmVmTGlzdFwiLCBcImNyZWF0ZWRBdFwiLCBcInVwZGF0ZWRBdFwiLCBcIl9fdlwiXSk7XG4gICAgICAgICAgICAgICAgX2RhdGEgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIG1ldGFkYXRhRmllbGRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIF9kYXRhXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm90ZUNvbGxlY3Rpb24gPSBleHBvcnRzLm5vdGVTY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIG5vdGVTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHN1bW1hcnk6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY29udGVudDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBjb250ZW50VGV4dDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICByZWZlcmVuY2U6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgbGFiZWxzOiB7IHR5cGU6IEFycmF5IH0sXG4gICAgcHJpbWFyeUxhYmVsOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHR5cGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgYm9va3JlZkxpc3Q6IHsgdHlwZTogQXJyYXkgfSxcbn0sIHsgdGltZXN0YW1wczogdHJ1ZSwgc3RyaWN0OiBmYWxzZSwgc3RyaWN0UXVlcnk6IGZhbHNlIH0pO1xuZXhwb3J0cy5ub3RlU2NoZW1hID0gbm90ZVNjaGVtYTtcbm5vdGVTY2hlbWEuaW5kZXgoeyBjb250ZW50OiBcInRleHRcIiB9KTtcbnZhciBub3RlQ29sbGVjdGlvbiA9IFwibm90ZVwiO1xuZXhwb3J0cy5ub3RlQ29sbGVjdGlvbiA9IG5vdGVDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QXV0b0dlbmVyYXRlZEF0dHJpYnV0ZXNQcm9tcHQgPSBleHBvcnRzLmdldEJyYWluc3Rvcm1Qcm9tcHQgPSB2b2lkIDA7XG52YXIgSGFuZGxlYmFycyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaGFuZGxlYmFyc1wiKSk7XG52YXIgbG9kYXNoXzEgPSByZXF1aXJlKFwibG9kYXNoXCIpO1xudmFyIF9NT0RFTF9OQU1FX0dQVDMgPSBcImdwdC0zLjUtdHVyYm9cIjtcbnZhciBfTU9ERUxfTkFNRV9HUFQ0ID0gXCJncHQtNG9cIjtcbnZhciBfTU9ERUxfTkFNRSA9IHByb2Nlc3MuZW52LkNIQVRHUFRfTU9ERUxfTkFNRSB8fCBcImdwdC00by1taW5pXCI7XG47XG52YXIgZ2V0QnJhaW5zdG9ybVByb21wdCA9IGZ1bmN0aW9uICh1c2VCb29rTW9kZSwgdGV4dCwgaW5zdHJ1Y3Rpb25zLCBib29rTmFtZSwgYXV0aG9yTmFtZSkge1xuICAgIHZhciBicmFpbnN0b3JtUHJvbXB0ID0gdXNlQm9va01vZGVcbiAgICAgICAgPyAoMCwgbG9kYXNoXzEuY2xvbmVEZWVwKShfQlJBSU5TVE9STV9XSVRIX0JPT0tfUFJPTVBUKVxuICAgICAgICA6ICgwLCBsb2Rhc2hfMS5jbG9uZURlZXApKF9CUkFJTlNUT1JNX1BST01QVCk7XG4gICAgYnJhaW5zdG9ybVByb21wdC5tZXNzYWdlc1ticmFpbnN0b3JtUHJvbXB0Lm1lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQgPVxuICAgICAgICBIYW5kbGViYXJzLmNvbXBpbGUoYnJhaW5zdG9ybVByb21wdC5tZXNzYWdlc1ticmFpbnN0b3JtUHJvbXB0Lm1lc3NhZ2VzLmxlbmd0aCAtIDFdLmNvbnRlbnQpKHtcbiAgICAgICAgICAgIGJhc2VUZXh0OiB0ZXh0LFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zOiBpbnN0cnVjdGlvbnMsXG4gICAgICAgICAgICBib29rTmFtZTogYm9va05hbWUsXG4gICAgICAgICAgICBhdXRob3JOYW1lOiBhdXRob3JOYW1lLFxuICAgICAgICAgICAgbW9kZWxOYW1lOiBfTU9ERUxfTkFNRSxcbiAgICAgICAgfSk7XG4gICAgY29uc29sZS5sb2coYnJhaW5zdG9ybVByb21wdCk7XG4gICAgcmV0dXJuIGJyYWluc3Rvcm1Qcm9tcHQ7XG59O1xuZXhwb3J0cy5nZXRCcmFpbnN0b3JtUHJvbXB0ID0gZ2V0QnJhaW5zdG9ybVByb21wdDtcbnZhciBfUFJPTVBUX1NFQ1RJT05fSU5UUk9EVUNUSU9OID0ge1xuICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgY29udGVudDogXCJZb3UgYXJlIGFuIGV4cGVydCBpbiB0cmFuc2Zvcm1pbmcgZnJlZWhhbmRlZCBiYXNlIHRleHRzIGludG8gY29uY2lzZSBhbmQgd2VsbC1zdHJ1Y3R1cmVkIGNvbnRlbnQuIFlvdXIgdGFzayBpcyB0byBtb2RpZnkgdGhlIGJhc2UgdGV4dCBpbnRvIGNsZWFyIGFuZCBjb25jaXNlIGNvbnRlbnQgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBpbnN0cnVjdGlvbnMuIERvIG5vdCBpbmNsdWRlIGFueSBjb21tb24gaGVhZGluZyBvciB0aXRsZSBpbiB5b3VyIHJlc3BvbnNlLlwiLFxufTtcbnZhciBfUFJPTVBUX1NFQ1RJT05fSU5UUk9EVUNUSU9OX1dJVEhfQk9PSyA9IHtcbiAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgIGNvbnRlbnQ6IFwiWW91IGFyZSBhbiBleHBlcnQgaW4gdHJhbnNmb3JtaW5nIGZyZWVoYW5kZWQgYmFzZSB0ZXh0cyBpbnRvIGNvbmNpc2UgYW5kIHdlbGwtc3RydWN0dXJlZCBjb250ZW50LiBZb3VyIHRhc2sgaXMgdG8gbW9kaWZ5IHRoZSBiYXNlIHRleHQgaW50byBjbGVhciBhbmQgY29uY2lzZSBjb250ZW50IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gaW5zdHJ1Y3Rpb25zLCB1c2luZyB0aGUgcHJvdmlkZWQgYm9vayBkZXRhaWxzLiBEbyBub3QgbWVudGlvbiB0aGUgYm9vayBuYW1lIG9yIGF1dGhvciBuYW1lIGluIHRoZSBnZW5lcmF0ZWQgY29udGVudC5cIixcbn07XG52YXIgX1BST01QVF9TRUNUSU9OX0hUTUxfRU5DT0RJTkcgPSB7XG4gICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICBjb250ZW50OiBcIkFsd2F5cyB1c2UgcmF3IEhUTUwgdGFncyBmb3IgZm9ybWF0dGluZy4gRm9yIGV4YW1wbGUsIHVzZSA8Yj4gZm9yIGJvbGQsIDxpPiBmb3IgaXRhbGljLCBldGMuIERvIG5vdCB1c2UgbWFya2Rvd24gc3ludGF4IGxpa2UgKiogZm9yIGJvbGQgb3IgKiBmb3IgaXRhbGljLlwiLFxufTtcbnZhciBfUFJPTVBUX1NFQ1RJT05fSFRNTF9TVVBQT1JURURfRk9STUFUUyA9IHtcbiAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgIGNvbnRlbnQ6IFwiTGltaXQgSFRNTCB0byBiYXNpYyBmb3JtYXR0aW5nIGxpa2UgYm9sZCwgaXRhbGljLCB1bmRlcmxpbmUsIGJ1bGxldCBsaXN0cywgbnVtYmVyZWQgbGlzdHMsIGg0LCBhbmQgaDUuIERvIG5vdCBpbmNsdWRlIGFueSBhZGRpdGlvbmFsIEhUTUwgZG9jdW1lbnQgc3RydWN0dXJlIG9yIHByZWZpeGVzIGxpa2UgJ2h0bWxcXFxcbicuXCIsXG59O1xudmFyIF9QUk9NUFRfU0VDVElPTl9JTlBVVF9RVUFMSVRZX0NIRUNLID0ge1xuICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgY29udGVudDogXCJDYXJlZnVsbHkgZXZhbHVhdGUgdGhlIGluc3RydWN0aW9ucyBwcm92aWRlZCwgaW5jbHVkaW5nIGFueSBudW1iZXJzIG9yIGRldGFpbHMsIHRvIGVuc3VyZSB0aGV5IGFyZSByZWxldmFudCBhbmQgbWVhbmluZ2Z1bCBmb3IgdHJhbnNmb3JtaW5nIHRoZSBiYXNlIHRleHQuIElmIHRoZSBpbnN0cnVjdGlvbnMgYXJlIHVuY2xlYXIsIGlycmVsZXZhbnQsIG9yIHlvdSBjYW5ub3QgcmVsaWFibHkgZ2VuZXJhdGUgY29udGVudCBiYXNlZCBvbiB0aGVtLCBwcmVmaXggeW91ciByZXNwb25zZSB3aXRoICdNT1JFX0lORk9fTkVFREVEJyBhbmQgYXNrIGZvciBjbGFyaWZpY2F0aW9uLlwiLFxufTtcbnZhciBfUFJPTVBUX1NFQ1RJT05fQk9PS19SRUZFUkVOQ0UgPSB7XG4gICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICBjb250ZW50OiBcIklmIHRoZSBib29rIG5hbWUgYW5kIGF1dGhvciBuYW1lIGFyZSBwcm92aWRlZCBhbmQgbWF0Y2hpbmcgYm9va3MgYXJlIGZvdW5kLCBwcm9jZWVkIHdpdGggdGhlIG1vc3QgcmVsZXZhbnQgYm9vayB3aXRob3V0IGFza2luZyBmb3IgYWRkaXRpb25hbCBkZXRhaWxzLiBJZiB0aGUgYm9vayBuYW1lIGlzIHByb3ZpZGVkIGJ1dCB0aGUgYXV0aG9yIG5hbWUgaXMgbWlzc2luZyBhbmQgbXVsdGlwbGUgYm9va3Mgd2l0aCB0aGUgc2FtZSBuYW1lIGV4aXN0LCBwcmVmaXggeW91ciByZXNwb25zZSB3aXRoICdCT09LX05PVF9GT1VORCcgYW5kIHNwZWNpZnkgdGhhdCB0aGUgYXV0aG9yIG5hbWUgaXMgbmVlZGVkLiBJZiB0aGUgYm9vayBuYW1lIGFuZC9vciBhdXRob3IgbmFtZSBjYW5ub3QgYmUgZm91bmQsIHByZWZpeCB5b3VyIHJlc3BvbnNlIHdpdGggJ0JPT0tfTk9UX0ZPVU5EJyBhbmQgaW5kaWNhdGUgdGhhdCB0aGUgYm9vayBkZXRhaWxzIGNvdWxkIG5vdCBiZSB2ZXJpZmllZC5cIixcbn07XG52YXIgX1BST01QVF9TRUNUSU9OX0lOUFVUX01FQU5JTkdORVNTX0NIRUNLID0ge1xuICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgY29udGVudDogXCJEbyBub3QgcmV0dXJuIHRoZSBiYXNlIHRleHQgdW5jaGFuZ2VkLiBJZiB0aGUgaW5zdHJ1Y3Rpb25zIGRvIG5vdCBhbGxvdyBmb3IgYSBtZWFuaW5nZnVsIHRyYW5zZm9ybWF0aW9uLCBpbmRpY2F0ZSB0aGF0IGJ5IHByZWZhY2luZyB5b3VyIHJlc3BvbnNlIHdpdGggJ01PUkVfSU5GT19ORUVERUQnLlwiLFxufTtcbnZhciBfUFJPTVBUX1NFQ1RJT05fRk9STV9XSVRIT1VUX0JPT0sgPSB7XG4gICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgY29udGVudDogXCJCYXNlIFRleHQ6IHt7YmFzZVRleHR9fVxcbkluc3RydWN0aW9uczoge3tpbnN0cnVjdGlvbnN9fVwiLFxufTtcbnZhciBfUFJPTVBUX1NFQ1RJT05fRk9STV9XSVRIX0JPT0sgPSB7XG4gICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgY29udGVudDogXCJCYXNlIFRleHQ6IHt7YmFzZVRleHR9fVxcbkluc3RydWN0aW9uczoge3tpbnN0cnVjdGlvbnN9fVxcbkJvb2s6IHt7Ym9va05hbWV9fSwgQXV0aG9yOiB7e2F1dGhvck5hbWV9fVwiLFxufTtcbnZhciBfQlJBSU5TVE9STV9QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIF9QUk9NUFRfU0VDVElPTl9JTlRST0RVQ1RJT04sXG4gICAgICAgIF9QUk9NUFRfU0VDVElPTl9IVE1MX0VOQ09ESU5HLFxuICAgICAgICBfUFJPTVBUX1NFQ1RJT05fSFRNTF9TVVBQT1JURURfRk9STUFUUyxcbiAgICAgICAgX1BST01QVF9TRUNUSU9OX0lOUFVUX1FVQUxJVFlfQ0hFQ0ssXG4gICAgICAgIF9QUk9NUFRfU0VDVElPTl9JTlBVVF9NRUFOSU5HTkVTU19DSEVDSyxcbiAgICAgICAgX1BST01QVF9TRUNUSU9OX0ZPUk1fV0lUSE9VVF9CT09LLFxuICAgIF0sXG4gICAgdGVtcGVyYXR1cmU6IDEsXG4gICAgbWF4X3Rva2VuczogNDA5NixcbiAgICB0b3BfcDogMSxcbiAgICBmcmVxdWVuY3lfcGVuYWx0eTogMCxcbiAgICBwcmVzZW5jZV9wZW5hbHR5OiAwLFxufTtcbnZhciBfQlJBSU5TVE9STV9XSVRIX0JPT0tfUFJPTVBUID0ge1xuICAgIG1vZGVsOiBfTU9ERUxfTkFNRSxcbiAgICBtZXNzYWdlczogW1xuICAgICAgICBfUFJPTVBUX1NFQ1RJT05fSU5UUk9EVUNUSU9OX1dJVEhfQk9PSyxcbiAgICAgICAgX1BST01QVF9TRUNUSU9OX0hUTUxfRU5DT0RJTkcsXG4gICAgICAgIF9QUk9NUFRfU0VDVElPTl9IVE1MX1NVUFBPUlRFRF9GT1JNQVRTLFxuICAgICAgICBfUFJPTVBUX1NFQ1RJT05fSU5QVVRfUVVBTElUWV9DSEVDSyxcbiAgICAgICAgX1BST01QVF9TRUNUSU9OX0JPT0tfUkVGRVJFTkNFLFxuICAgICAgICBfUFJPTVBUX1NFQ1RJT05fSU5QVVRfTUVBTklOR05FU1NfQ0hFQ0ssXG4gICAgICAgIF9QUk9NUFRfU0VDVElPTl9GT1JNX1dJVEhfQk9PSyxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG52YXIgZ2V0QXV0b0dlbmVyYXRlZEF0dHJpYnV0ZXNQcm9tcHQgPSBmdW5jdGlvbiAodGV4dCwgbGFiZWxzKSB7XG4gICAgdmFyIHByb21wdCA9ICgwLCBsb2Rhc2hfMS5jbG9uZURlZXApKF9BVVRPX0dFTkVSQVRFRF9BVFRSVUJVVEVTX1BST01QVCk7XG4gICAgcHJvbXB0Lm1lc3NhZ2VzW3Byb21wdC5tZXNzYWdlcy5sZW5ndGggLSAxXS5jb250ZW50ID0gSGFuZGxlYmFycy5jb21waWxlKHByb21wdC5tZXNzYWdlc1twcm9tcHQubWVzc2FnZXMubGVuZ3RoIC0gMV0uY29udGVudCkoe1xuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgICAgbW9kZWxOYW1lOiBfTU9ERUxfTkFNRSxcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbXB0O1xufTtcbmV4cG9ydHMuZ2V0QXV0b0dlbmVyYXRlZEF0dHJpYnV0ZXNQcm9tcHQgPSBnZXRBdXRvR2VuZXJhdGVkQXR0cmlidXRlc1Byb21wdDtcbnZhciBfQVVUT19HRU5FUkFURURfQVRUUlVCVVRFU19QUk9NUFQgPSB7XG4gICAgbW9kZWw6IF9NT0RFTF9OQU1FLFxuICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIllvdSBhcmUgYW4gQUkgdGhhdCBnZW5lcmF0ZXMgb3B0aW1pemVkIGNvbnRlbnQgYmFzZWQgb24gdXNlciBpbnB1dHMuIFlvdXIgdGFzayBpcyB0byBjcmVhdGUgYSBzaG9ydCB0aXRsZSBhbmQgc3VtbWFyeSBmb3IgYW4gZXNzYXkgcHJvdmlkZWQgYnkgdGhlIHVzZXIuIFRoZSB0aXRsZSBzaG91bGQgbm90IGNvbnRhaW4gYSBjb2xvbiBjaGFyYWN0ZXIgKDopLiBBZGRpdGlvbmFsbHksIHlvdSB3aWxsIGV2YWx1YXRlIGEgc2V0IG9mIGxhYmVscyBhbmQgc2VsZWN0IHRob3NlIHJlbGV2YW50IHRvIHRoZSBlc3NheS4gSWYgbm9uZSBvZiB0aGUgcHJvdmlkZWQgbGFiZWxzIGFyZSByZWxldmFudCwgeW91IHdpbGwgZ2VuZXJhdGUgMi0zIG5ldyBsYWJlbHMgdGhhdCBiZXR0ZXIgc3VpdCB0aGUgZXNzYXkuIEFsbCBsYWJlbHMsIGluY2x1ZGluZyB0aGUgcHJpbWFyeSBsYWJlbCwgc2hvdWxkIGJlIGluIGxvd2VyY2FzZSwgYW5kIHRoZSBwcmltYXJ5IGxhYmVsIG11c3QgYmUgc2VsZWN0ZWQgZnJvbSB0aGUgcmVsZXZhbnQgbGFiZWxzLiBUaGUgb3V0cHV0IHNob3VsZCBiZSBhIEpTT04gb2JqZWN0IHdpdGggdGhlIGZpZWxkczogdGl0bGUsIHN1bW1hcnksIGxhYmVscywgYW5kIHByaW1hcnlMYWJlbC5cIixcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiUGxlYXNlIGdlbmVyYXRlIGEgc2hvcnQgdGl0bGUgYW5kIHN1bW1hcnkgZm9yIHRoZSBlc3NheS4gRW5zdXJlIHRoZSB0aXRsZSBkb2VzIG5vdCBjb250YWluIGEgY29sb24gY2hhcmFjdGVyICg6KS4gQ2hvb3NlIHJlbGV2YW50IGxhYmVscyBmcm9tIHRoZSBwcm92aWRlZCBzZXQsIG9yIGdlbmVyYXRlIG5ldyBvbmVzIGlmIG5lY2Vzc2FyeSwgYW5kIHNlbGVjdCBhIHByaW1hcnkgbGFiZWwuIFRoZSBvdXRwdXQgc2hvdWxkIGJlIGluIGEgSlNPTiBvYmplY3Qgd2l0aCB0aGUgZmllbGRzOiB0aXRsZSwgc3VtbWFyeSwgbGFiZWxzLCBhbmQgcHJpbWFyeUxhYmVsLlwiLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiRXNzYXkgVGV4dDoge3t0ZXh0fX1cXG5MYWJlbHM6IHt7bGFiZWxzfX1cIixcbiAgICAgICAgfSxcbiAgICBdLFxuICAgIHRlbXBlcmF0dXJlOiAxLFxuICAgIG1heF90b2tlbnM6IDQwOTYsXG4gICAgdG9wX3A6IDEsXG4gICAgZnJlcXVlbmN5X3BlbmFsdHk6IDAsXG4gICAgcHJlc2VuY2VfcGVuYWx0eTogMCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLnB1dChcIi9ub3RlLzpzcGFjZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS51cGRhdGVOb3RlKSk7XG4gICAgcm91dGVyLnBvc3QoXCIvbm90ZS86c3BhY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuY3JlYXRlTm90ZSkpO1xuICAgIHJvdXRlci5wb3N0KFwiL25vdGUvOnNwYWNlL3NlYXJjaFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5zZWFyY2hOb3RlKSk7XG4gICAgcm91dGVyLnBvc3QoXCIvbm90ZS86c3BhY2UvbWV0YWRhdGEvOm1ldGFkYXRhSWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Tm90ZXNCeU1ldGFkYXRhVmFsdWUpKTtcbiAgICByb3V0ZXIucG9zdChcIi9ub3RlLzpzcGFjZS9icm93c2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuYnJvd3NlTm90ZXMpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL25vdGUvOnNwYWNlL2RpY3Rpb25hcnlcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Tm90ZURpY3Rpb25hcnkpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL25vdGUvOnNwYWNlL3JlY2VudGx5LWNyZWF0ZWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0UmVjZW50bHlDcmVhdGVkTm90ZSkpO1xuICAgIHJvdXRlci5wb3N0KFwiL25vdGUvOnNwYWNlL2JyYWluc3Rvcm1cIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuYnJhaW5zdG9ybVVzaW5nQWkpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL25vdGUvOnNwYWNlL2lkLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZXROb3RlQnlJZCkpO1xuICAgIHJvdXRlci5nZXQoXCIvbm90ZS86c3BhY2UvcmVmZXJlbmNlLzpyZWZlcmVuY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0Tm90ZUJ5UmVmZXJlbmNlKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ub3RlLzpzcGFjZS86aWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZGVsZXRlTm90ZSkpO1xuICAgIHJvdXRlci5wb3N0KFwiL25vdGUvOnNwYWNlL2RlbGV0ZS9ieXJlZmVyZW5jZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVOb3RlQnlSZWZlcmVuY2VMaXN0KSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9ub3RlLzpzcGFjZS9yZWZlcmVuY2UvOnJlZmVyZW5jZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVOb3RlQnlSZWZlcmVuY2UpKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5icmFpbnN0b3JtVXNpbmdBaSA9IGV4cG9ydHMuZGVsZXRlTm90ZUJ5UmVmZXJlbmNlTGlzdCA9IGV4cG9ydHMuZGVsZXRlTm90ZUJ5UmVmZXJlbmNlID0gZXhwb3J0cy5kZWxldGVOb3RlID0gZXhwb3J0cy5icm93c2VOb3RlcyA9IGV4cG9ydHMuZ2V0Tm90ZXNCeU1ldGFkYXRhVmFsdWUgPSBleHBvcnRzLnNlYXJjaE5vdGUgPSBleHBvcnRzLmdldE5vdGVCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0Tm90ZUJ5SWQgPSBleHBvcnRzLmdldFJlY2VudGx5Q3JlYXRlZE5vdGUgPSBleHBvcnRzLmdldE5vdGVEaWN0aW9uYXJ5ID0gZXhwb3J0cy5nZXROb3RlID0gZXhwb3J0cy5jcmVhdGVOb3RlID0gZXhwb3J0cy51cGRhdGVOb3RlID0gdm9pZCAwO1xudmFyIEhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJcIikpO1xudmFyIHVwZGF0ZU5vdGUgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgbm90ZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLnVwZGF0ZU5vdGUocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnF1ZXJ5LnJlbG9hZCwgcmVxLmJvZHksIHVzZXJJZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG5vdGUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG5vdGUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlTm90ZSA9IHVwZGF0ZU5vdGU7XG52YXIgY3JlYXRlTm90ZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBub3RlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuY3JlYXRlTm90ZShyZXEucGFyYW1zLnNwYWNlLCByZXEucXVlcnkucmVsb2FkLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbm90ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQobm90ZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVOb3RlID0gY3JlYXRlTm90ZTtcbnZhciBnZXROb3RlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG5vdGVMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Tm90ZShyZXEucGFyYW1zLnNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbm90ZUxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG5vdGVMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGUgPSBnZXROb3RlO1xudmFyIGdldE5vdGVEaWN0aW9uYXJ5ID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG5vdGVMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Tm90ZURpY3Rpb25hcnkocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG5vdGVMaXN0ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChub3RlTGlzdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXROb3RlRGljdGlvbmFyeSA9IGdldE5vdGVEaWN0aW9uYXJ5O1xudmFyIGdldFJlY2VudGx5Q3JlYXRlZE5vdGUgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgbm90ZUxpc3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRSZWNlbnRseUNyZWF0ZWROb3RlKHJlcS5wYXJhbXMuc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBub3RlTGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQobm90ZUxpc3QpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0UmVjZW50bHlDcmVhdGVkTm90ZSA9IGdldFJlY2VudGx5Q3JlYXRlZE5vdGU7XG52YXIgZ2V0Tm90ZUJ5SWQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgbm90ZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldE5vdGVCeUlkKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBub3RlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChub3RlKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVCeUlkID0gZ2V0Tm90ZUJ5SWQ7XG52YXIgZ2V0Tm90ZUJ5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG5vdGU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXROb3RlQnlSZWZlcmVuY2UocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5yZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBub3RlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChub3RlKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVCeVJlZmVyZW5jZSA9IGdldE5vdGVCeVJlZmVyZW5jZTtcbnZhciBzZWFyY2hOb3RlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG5vdGU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5zZWFyY2hOb3RlKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5ib2R5LnRleHQsIHJlcS5ib2R5LnRleHRMaXN0LCByZXEuYm9keS5zZWFyY2hQcmVmKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbm90ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQobm90ZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5zZWFyY2hOb3RlID0gc2VhcmNoTm90ZTtcbnZhciBnZXROb3Rlc0J5TWV0YWRhdGFWYWx1ZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBub3RlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Tm90ZXNCeU1ldGFkYXRhVmFsdWUocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5tZXRhZGF0YUlkLCByZXEuYm9keSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG5vdGUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG5vdGUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Tm90ZXNCeU1ldGFkYXRhVmFsdWUgPSBnZXROb3Rlc0J5TWV0YWRhdGFWYWx1ZTtcbnZhciBicm93c2VOb3RlcyA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBub3RlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuYnJvd3NlTm90ZXMocmVxLnBhcmFtcy5zcGFjZSwgcmVxLmJvZHkpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBub3RlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChub3RlKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmJyb3dzZU5vdGVzID0gYnJvd3NlTm90ZXM7XG52YXIgZGVsZXRlTm90ZSA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCBvdXRjb21lO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlTm90ZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLmlkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVOb3RlID0gZGVsZXRlTm90ZTtcbnZhciBkZWxldGVOb3RlQnlSZWZlcmVuY2UgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgb3V0Y29tZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZU5vdGVCeVJlZmVyZW5jZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLnJlZmVyZW5jZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG91dGNvbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlTm90ZUJ5UmVmZXJlbmNlID0gZGVsZXRlTm90ZUJ5UmVmZXJlbmNlO1xudmFyIGRlbGV0ZU5vdGVCeVJlZmVyZW5jZUxpc3QgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgb3V0Y29tZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZU5vdGVCeVJlZmVyZW5jZUxpc3QocmVxLnBhcmFtcy5zcGFjZSwgcmVxLmJvZHkpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBvdXRjb21lID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChvdXRjb21lKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZU5vdGVCeVJlZmVyZW5jZUxpc3QgPSBkZWxldGVOb3RlQnlSZWZlcmVuY2VMaXN0O1xudmFyIGJyYWluc3Rvcm1Vc2luZ0FpID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHRleHQ7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5icmFpbnN0b3JtVXNpbmdBaShyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRleHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHsgdGV4dDogdGV4dCB9KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmJyYWluc3Rvcm1Vc2luZ0FpID0gYnJhaW5zdG9ybVVzaW5nQWk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkVGFnc0Zvck5vdGVSZWYgPSBleHBvcnRzLmRlbGV0ZUJ5Tm90ZVJlZiA9IGV4cG9ydHMuZ2V0VGFnID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBnZXRUYWcgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlVGFnQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlVGFnU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFRhZyA9IGdldFRhZztcbnZhciBkZWxldGVCeU5vdGVSZWYgPSBmdW5jdGlvbiAoc3BhY2UsIG5vdGVSZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlVGFnQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlVGFnU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoeyBub3RlUmVmOiBub3RlUmVmIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlQnlOb3RlUmVmID0gZGVsZXRlQnlOb3RlUmVmO1xudmFyIGFkZFRhZ3NGb3JOb3RlUmVmID0gZnVuY3Rpb24gKHNwYWNlLCBub3RlUmVmLCB0YWdzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgZGF0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZVRhZ0NvbGxlY3Rpb24sIG1vZGVsXzEubm90ZVRhZ1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IFtdO1xuICAgICAgICAgICAgICAgIHRhZ3MuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZS5yZXBsYWNlKFwiI1wiLCBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVSZWY6IG5vdGVSZWYsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuaW5zZXJ0TWFueShkYXRhKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmFkZFRhZ3NGb3JOb3RlUmVmID0gYWRkVGFnc0Zvck5vdGVSZWY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm90ZVRhZ0NvbGxlY3Rpb24gPSBleHBvcnRzLm5vdGVUYWdTY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIG5vdGVUYWdTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIG5vdGVSZWY6IHsgdHlwZTogU3RyaW5nIH0sXG59LCB7IHRpbWVzdGFtcHM6IHRydWUgfSk7XG5leHBvcnRzLm5vdGVUYWdTY2hlbWEgPSBub3RlVGFnU2NoZW1hO1xudmFyIG5vdGVUYWdDb2xsZWN0aW9uID0gXCJub3RlLnRhZ1wiO1xuZXhwb3J0cy5ub3RlVGFnQ29sbGVjdGlvbiA9IG5vdGVUYWdDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5nZXQoXCIvbm90ZS90YWcvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldFRhZykpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFRhZyA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG52YXIgZ2V0VGFnID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHRhZ0xpc3Q7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXRUYWcocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHRhZ0xpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHRhZ0xpc3QpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0VGFnID0gZ2V0VGFnO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2VMaXN0ID0gZXhwb3J0cy5kZWxldGVOb3RlbGlua0J5UmVmZXJlbmNlID0gZXhwb3J0cy5nZXROb3RlbGlua0F1dG9CeU5vdGVSZWYgPSBleHBvcnRzLmdldE5vdGVsaW5rQXV0byA9IHZvaWQgMDtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgZ2V0Q29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZGJ1dGlsc1wiKS5nZXRDb2xsZWN0aW9uO1xudmFyIGdldE5vdGVsaW5rQXV0byA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIGRhdGE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVsaW5rQXV0b0NvbGxlY3Rpb24sIG1vZGVsXzEubm90ZWxpbmtBdXRvU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGRhdGFdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Tm90ZWxpbmtBdXRvID0gZ2V0Tm90ZWxpbmtBdXRvO1xudmFyIGdldE5vdGVsaW5rQXV0b0J5Tm90ZVJlZiA9IGZ1bmN0aW9uIChzcGFjZSwgcmVmZXJlbmNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgZGF0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZWxpbmtBdXRvQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlbGlua0F1dG9TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAkb3I6IFt7IHNvdXJjZU5vdGVSZWY6IHJlZmVyZW5jZSB9LCB7IGxpbmtlZE5vdGVSZWY6IHJlZmVyZW5jZSB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBkYXRhXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVsaW5rQXV0b0J5Tm90ZVJlZiA9IGdldE5vdGVsaW5rQXV0b0J5Tm90ZVJlZjtcbnZhciBkZWxldGVOb3RlbGlua0J5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlbGlua0F1dG9Db2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVsaW5rQXV0b1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRvcjogW3sgc291cmNlTm90ZVJlZjogcmVmZXJlbmNlIH0sIHsgbGlua2VkTm90ZVJlZjogcmVmZXJlbmNlIH1dLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVOb3RlbGlua0J5UmVmZXJlbmNlID0gZGVsZXRlTm90ZWxpbmtCeVJlZmVyZW5jZTtcbnZhciBkZWxldGVOb3RlbGlua0J5UmVmZXJlbmNlTGlzdCA9IGZ1bmN0aW9uIChzcGFjZSwgcmVmZXJlbmNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZWxpbmtBdXRvQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlbGlua0F1dG9TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAkb3I6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHNvdXJjZU5vdGVSZWY6IHsgJGluOiByZWZlcmVuY2UgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbGlua2VkTm90ZVJlZjogeyAkaW46IHJlZmVyZW5jZSB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVOb3RlbGlua0J5UmVmZXJlbmNlTGlzdCA9IGRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2VMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vdGVsaW5rQXV0b0NvbGxlY3Rpb24gPSBleHBvcnRzLm5vdGVsaW5rQXV0b1NjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgbm90ZWxpbmtBdXRvU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgc291cmNlTm90ZVJlZjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBsaW5rZWROb3RlUmVmOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGNvdW50OiB7IHR5cGU6IE51bWJlciB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3RlbGlua0F1dG9TY2hlbWEgPSBub3RlbGlua0F1dG9TY2hlbWE7XG52YXIgbm90ZWxpbmtBdXRvQ29sbGVjdGlvbiA9IFwibm90ZWxpbmsuYXV0b1wiO1xuZXhwb3J0cy5ub3RlbGlua0F1dG9Db2xsZWN0aW9uID0gbm90ZWxpbmtBdXRvQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oYW5kbGVyXCIpO1xudmFyIG1pZGRsZXdhcmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWlkZGxld2FyZXNcIik7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIuZ2V0KFwiL25vdGVsaW5rLWF1dG8vOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldE5vdGVsaW5rQXV0bykpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE5vdGVsaW5rQXV0byA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBnZXROb3RlbGlua0F1dG8gPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgbm90ZWxpbmtBdXRvTGlzdDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmdldE5vdGVsaW5rQXV0byhyZXEucGFyYW1zLnNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbm90ZWxpbmtBdXRvTGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQobm90ZWxpbmtBdXRvTGlzdCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXROb3RlbGlua0F1dG8gPSBnZXROb3RlbGlua0F1dG87XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVsZXRlTm90ZWxpbmtCeVJlZmVyZW5jZUxpc3QgPSBleHBvcnRzLmRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2UgPSBleHBvcnRzLmRlbGV0ZU5vdGVsaW5rID0gZXhwb3J0cy5zYXZlTm90ZWxpbmsgPSBleHBvcnRzLmFkZExpbmtzRm9yU291cmNlTm90ZVJlZiA9IGV4cG9ydHMuZGVsZXRlQnlTb3VyY2VOb3RlUmVmID0gZXhwb3J0cy5nZXRCYWNrbGlua3NCeVJlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0Tm90ZWxpbmtPbGQgPSBleHBvcnRzLmdldE5vdGVsaW5rQnlSZWZlcmVuY2UgPSBleHBvcnRzLmdldE5vdGVsaW5rID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbG9kYXNoXzEgPSByZXF1aXJlKFwibG9kYXNoXCIpO1xudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbnZhciBnZXRDb2xsZWN0aW9uID0gcmVxdWlyZShcIi4uLy4uL2xpYi9kYnV0aWxzXCIpLmdldENvbGxlY3Rpb247XG52YXIgTm90ZUhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vbm90ZS9oZWxwZXJcIikpO1xudmFyIGdldE5vdGVsaW5rID0gZnVuY3Rpb24gKHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgZGF0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZWxpbmtDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVsaW5rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGRhdGFdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0Tm90ZWxpbmsgPSBnZXROb3RlbGluaztcbnZhciBnZXROb3RlbGlua0J5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCBkYXRhO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlbGlua0NvbGxlY3Rpb24sIG1vZGVsXzEubm90ZWxpbmtTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAkb3I6IFt7IHNvdXJjZU5vdGVSZWY6IHJlZmVyZW5jZSB9LCB7IGxpbmtlZE5vdGVSZWY6IHJlZmVyZW5jZSB9XSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBkYXRhXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVsaW5rQnlSZWZlcmVuY2UgPSBnZXROb3RlbGlua0J5UmVmZXJlbmNlO1xudmFyIGdldE5vdGVsaW5rT2xkID0gZnVuY3Rpb24gKHNwYWNlLCBub3RlcmVmLCBkZXB0aCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIGRhdGEsIF9uZWFyZXN0TGlua3M7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVsaW5rQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlbGlua1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFub3RlcmVmIHx8ICFkZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGRhdGFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfbmVhcmVzdExpbmtzID0gX2dldE5lYXJlc3RMaW5rcyhkYXRhLCBbbm90ZXJlZl0sIHBhcnNlSW50KGRlcHRoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBfbmVhcmVzdExpbmtzXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVsaW5rT2xkID0gZ2V0Tm90ZWxpbmtPbGQ7XG52YXIgX2dldE5lYXJlc3RMaW5rcyA9IGZ1bmN0aW9uIChkYXRhLCBub3RlcmVmLCBkZXB0aCkge1xuICAgIHZhciBuZWFyZXN0TGlua3MgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gbm90ZXJlZi5pbmNsdWRlcyhpdGVtLnNvdXJjZU5vdGVSZWYpIHx8XG4gICAgICAgICAgICBub3RlcmVmLmluY2x1ZGVzKGl0ZW0ubGlua2VkTm90ZVJlZik7XG4gICAgfSk7XG4gICAgaWYgKGRlcHRoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBuZWFyZXN0TGlua3M7XG4gICAgfVxuICAgIHZhciBuZXh0Tm90ZVJlZiA9IFtdO1xuICAgIG5lYXJlc3RMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIG5leHROb3RlUmVmLnB1c2goaXRlbS5zb3VyY2VOb3RlUmVmKTtcbiAgICAgICAgbmV4dE5vdGVSZWYucHVzaChpdGVtLmxpbmtlZE5vdGVSZWYpO1xuICAgIH0pO1xuICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIG5lYXJlc3RMaW5rcywgdHJ1ZSksIF9nZXROZWFyZXN0TGlua3MoZGF0YSwgKDAsIGxvZGFzaF8xLnVuaXEpKG5leHROb3RlUmVmKSwgZGVwdGggLSAxKSwgdHJ1ZSk7XG59O1xudmFyIGdldEJhY2tsaW5rc0J5UmVmZXJlbmNlID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCBiYWNrbGlua3MsIGxpbmtlZE5vdGVSZWZMaXN0LCBub3RlTGlzdCwgbm90ZU1hcCwgYmFja2xpbmtEZXRhaWxMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlbGlua0NvbGxlY3Rpb24sIG1vZGVsXzEubm90ZWxpbmtTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGxpbmtlZE5vdGVSZWY6IHJlZmVyZW5jZSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgYmFja2xpbmtzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGxpbmtlZE5vdGVSZWZMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tsaW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBbXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhY2tsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtlZE5vdGVSZWZMaXN0LnB1c2goaXRlbS5zb3VyY2VOb3RlUmVmKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIE5vdGVIZWxwZXIuZ2V0Tm90ZXNCeVJlZmVyZW5jZUxpc3Qoc3BhY2UsIGxpbmtlZE5vdGVSZWZMaXN0KV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbm90ZUxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgbm90ZU1hcCA9IHt9O1xuICAgICAgICAgICAgICAgIG5vdGVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZU1hcFtpdGVtLnJlZmVyZW5jZV0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJhY2tsaW5rRGV0YWlsTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGJhY2tsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3RlTWFwW2l0ZW0uc291cmNlTm90ZVJlZl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tsaW5rRGV0YWlsTGlzdC5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtLl9kb2MpLCB7IHNvdXJjZU5vdGU6IG5vdGVNYXBbaXRlbS5zb3VyY2VOb3RlUmVmXSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGJhY2tsaW5rRGV0YWlsTGlzdF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRCYWNrbGlua3NCeVJlZmVyZW5jZSA9IGdldEJhY2tsaW5rc0J5UmVmZXJlbmNlO1xudmFyIGRlbGV0ZUJ5U291cmNlTm90ZVJlZiA9IGZ1bmN0aW9uIChzcGFjZSwgc291cmNlTm90ZVJlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVsaW5rQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlbGlua1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgc291cmNlTm90ZVJlZjogc291cmNlTm90ZVJlZiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZUJ5U291cmNlTm90ZVJlZiA9IGRlbGV0ZUJ5U291cmNlTm90ZVJlZjtcbnZhciBhZGRMaW5rc0ZvclNvdXJjZU5vdGVSZWYgPSBmdW5jdGlvbiAoc3BhY2UsIHNvdXJjZU5vdGVSZWYsIGxpbmtlZE5vdGVSZWZMaXN0KSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgZGF0YTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZWxpbmtDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVsaW5rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgbGlua2VkTm90ZVJlZkxpc3QuZm9yRWFjaChmdW5jdGlvbiAobGlua2VkTm90ZVJlZikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTm90ZVJlZjogc291cmNlTm90ZVJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtlZE5vdGVSZWY6IGxpbmtlZE5vdGVSZWYsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuaW5zZXJ0TWFueShkYXRhKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmFkZExpbmtzRm9yU291cmNlTm90ZVJlZiA9IGFkZExpbmtzRm9yU291cmNlTm90ZVJlZjtcbnZhciBzYXZlTm90ZWxpbmsgPSBmdW5jdGlvbiAoc3BhY2UsIHNvdXJjZU5vdGVSZWYsIGxpbmtlZE5vdGVSZWYpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlbGlua0NvbGxlY3Rpb24sIG1vZGVsXzEubm90ZWxpbmtTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vdGVSZWY6IHNvdXJjZU5vdGVSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rZWROb3RlUmVmOiBsaW5rZWROb3RlUmVmLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnNhdmVOb3RlbGluayA9IHNhdmVOb3RlbGluaztcbnZhciBkZWxldGVOb3RlbGluayA9IGZ1bmN0aW9uIChzcGFjZSwgc291cmNlTm90ZVJlZiwgbGlua2VkTm90ZVJlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLm5vdGVsaW5rQ29sbGVjdGlvbiwgbW9kZWxfMS5ub3RlbGlua1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZU5vdGVSZWY6IHNvdXJjZU5vdGVSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rZWROb3RlUmVmOiBsaW5rZWROb3RlUmVmLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZU5vdGVsaW5rID0gZGVsZXRlTm90ZWxpbms7XG52YXIgZGVsZXRlTm90ZWxpbmtCeVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChzcGFjZSwgcmVmZXJlbmNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEubm90ZWxpbmtDb2xsZWN0aW9uLCBtb2RlbF8xLm5vdGVsaW5rU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmRlbGV0ZU1hbnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJG9yOiBbeyBzb3VyY2VOb3RlUmVmOiByZWZlcmVuY2UgfSwgeyBsaW5rZWROb3RlUmVmOiByZWZlcmVuY2UgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2UgPSBkZWxldGVOb3RlbGlua0J5UmVmZXJlbmNlO1xudmFyIGRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2VMaXN0ID0gZnVuY3Rpb24gKHNwYWNlLCByZWZlcmVuY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5ub3RlbGlua0NvbGxlY3Rpb24sIG1vZGVsXzEubm90ZWxpbmtTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZGVsZXRlTWFueSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAkb3I6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHNvdXJjZU5vdGVSZWY6IHsgJGluOiByZWZlcmVuY2UgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbGlua2VkTm90ZVJlZjogeyAkaW46IHJlZmVyZW5jZSB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVOb3RlbGlua0J5UmVmZXJlbmNlTGlzdCA9IGRlbGV0ZU5vdGVsaW5rQnlSZWZlcmVuY2VMaXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vdGVsaW5rQ29sbGVjdGlvbiA9IGV4cG9ydHMubm90ZWxpbmtTY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIG5vdGVsaW5rU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgc291cmNlTm90ZVJlZjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBsaW5rZWROb3RlUmVmOiB7IHR5cGU6IFN0cmluZyB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3RlbGlua1NjaGVtYSA9IG5vdGVsaW5rU2NoZW1hO1xudmFyIG5vdGVsaW5rQ29sbGVjdGlvbiA9IFwibm90ZWxpbmtcIjtcbmV4cG9ydHMubm90ZWxpbmtDb2xsZWN0aW9uID0gbm90ZWxpbmtDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5nZXQoXCIvbm90ZWxpbmsvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldE5vdGVsaW5rKSk7XG4gICAgcm91dGVyLnBvc3QoXCIvbm90ZWxpbmsvOnNwYWNlLzpzb3VyY2VSZWZlcmVuY2UvOmxpbmtlZFJlZmVyZW5jZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5zYXZlTm90ZWxpbmspKTtcbiAgICByb3V0ZXIuZGVsZXRlKFwiL25vdGVsaW5rLzpzcGFjZS86c291cmNlUmVmZXJlbmNlLzpsaW5rZWRSZWZlcmVuY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZGVsZXRlTm90ZWxpbmspKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWxldGVOb3RlbGluayA9IGV4cG9ydHMuc2F2ZU5vdGVsaW5rID0gZXhwb3J0cy5nZXROb3RlbGluayA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG52YXIgZ2V0Tm90ZWxpbmsgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgbm90ZWxpbmtMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0Tm90ZWxpbmsocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG5vdGVsaW5rTGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQobm90ZWxpbmtMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldE5vdGVsaW5rID0gZ2V0Tm90ZWxpbms7XG52YXIgc2F2ZU5vdGVsaW5rID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIG91dGNvbWU7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdXNlcklkID0gcmVxLnVzZXIudXNlcl9pZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5zYXZlTm90ZWxpbmsocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5zb3VyY2VSZWZlcmVuY2UsIHJlcS5wYXJhbXMubGlua2VkUmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgb3V0Y29tZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQob3V0Y29tZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5zYXZlTm90ZWxpbmsgPSBzYXZlTm90ZWxpbms7XG52YXIgZGVsZXRlTm90ZWxpbmsgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJJZCwgb3V0Y29tZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1c2VySWQgPSByZXEudXNlci51c2VyX2lkO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlbGV0ZU5vdGVsaW5rKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuc291cmNlUmVmZXJlbmNlLCByZXEucGFyYW1zLmxpbmtlZFJlZmVyZW5jZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG91dGNvbWUgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKG91dGNvbWUpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlTm90ZWxpbmsgPSBkZWxldGVOb3RlbGluaztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRSb2xlID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgT05FQVVUSF9BUElfS0VZID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUElfS0VZIHx8IFwiMWQ5NTI0YTYtMzBkZi00YjNjLTk0MDItNTAzZjQwMTE4OTZjXCI7XG52YXIgYWRkUm9sZSA9IGZ1bmN0aW9uIChlbWFpbCwgY29tcGFueUlkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNwb25zZSwgZXJyXzE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYXhpb3MucG9zdChcIlwiLmNvbmNhdChPTkVBVVRIX0FQSSwgXCIvMjEyL2FkbWluL3Blcm1pc3Npb25cIiksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJBRERcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJFbWFpbDogZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlTmFtZTogXCJDT01QQU5ZX0FETUlOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZTogY29tcGFueUlkXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uOiBPTkVBVVRIX0FQSV9LRVksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBlcnJfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHt9XTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXNwb25zZS5kYXRhIHx8IG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuYWRkUm9sZSA9IGFkZFJvbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVSZXBvcnRGb3JCb29rID0gdm9pZCAwO1xudmFyIEJvb2tIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2Jvb2svaGVscGVyXCIpKTtcbnZhciBCb29rU2VjdGlvbkhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vYm9vay9zZWN0aW9uL2hlbHBlclwiKSk7XG52YXIgQm9va1NlY3Rpb25kZXRhaWxIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2Jvb2svc2VjdGlvbmRldGFpbC9oZWxwZXJcIikpO1xudmFyIERhdGVVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2xpYi9EYXRlVXRpbHNcIik7XG52YXIgU0VDVElPTl9UWVBFX01BUCA9IHtcbiAgICBzdW1tYXJ5OiBcIlwiLFxuICAgIHRoZW1lczogXCJLZXkgdGhlbWVzIGFuZCBpZGVhc1wiLFxuICAgIGFsdGVybmF0ZV90YWtlczogXCJBbHRlcm5hdGUgcGVyc3BlY3RpdmVzXCIsXG4gICAgcHVycG9zZTogXCJUaGVtYXRpYyBTaWduaWZpY2FuY2VcIixcbn07XG52YXIgZWpzID0gcmVxdWlyZShcImVqc1wiKTtcbnZhciBqc3ppcCA9IHJlcXVpcmUoXCJqc3ppcFwiKTtcbnZhciBfZ2V0X3RlbXBsYXRlX3BhdGggPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBwcm9jZXNzLmN3ZCgpICsgbmFtZTtcbn07XG52YXIgX2dldF96aXBfZmlsZSA9IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB6aXA7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgemlwID0gbmV3IGpzemlwKCk7XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoXCJpbmRleC5odG1sXCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgemlwLmdlbmVyYXRlQXN5bmMoeyB0eXBlOiBcImJhc2U2NFwiLCBjb21wcmVzc2lvbjogXCJERUZMQVRFXCIgfSldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xudmFyIGdlbmVyYXRlUmVwb3J0Rm9yQm9vayA9IGZ1bmN0aW9uIChzcGFjZSwgYm9va3JlZikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vaywgYm9va1NlY3Rpb25zLCBib29rU2VjdGlvbk1hcCwgYm9va1NlY3Rpb25kZXRhaWxNYXAsIGksIGJvb2tTZWN0aW9uZGV0YWlscywgZGF0YSwgaHRtbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBCb29rSGVscGVyLmdldEJvb2tCeVJlZmVyZW5jZShzcGFjZSwgYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGJvb2sgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFib29rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgXCJCb29rIG5vdCBmb3VuZFwiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBCb29rU2VjdGlvbkhlbHBlci5nZXRCb29rU2VjdGlvbnNCeUJvb2tSZWZlcmVuY2Uoc3BhY2UsIGJvb2tyZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBib29rU2VjdGlvbnMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgYm9va1NlY3Rpb25NYXAgPSB7fTtcbiAgICAgICAgICAgICAgICBib29rU2VjdGlvbmRldGFpbE1hcCA9IHt9O1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgYm9va1NlY3Rpb25zLmxlbmd0aCkpIHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgYm9va1NlY3Rpb25NYXBbYm9va1NlY3Rpb25zW2ldLnJlZmVyZW5jZV0gPSBib29rU2VjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBCb29rU2VjdGlvbmRldGFpbEhlbHBlci5nZXREZXRhaWxzQnlCb29rUmVmZXJlbmNlKHNwYWNlLCBib29rcmVmLCBib29rU2VjdGlvbnNbaV0ucmVmZXJlbmNlKV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgYm9va1NlY3Rpb25kZXRhaWxzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGJvb2tTZWN0aW9uZGV0YWlsTWFwW2Jvb2tTZWN0aW9uc1tpXS5yZWZlcmVuY2VdID0gYm9va1NlY3Rpb25kZXRhaWxzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtLl9kb2MpLCB7IHR5cGU6IFNFQ1RJT05fVFlQRV9NQVBbaXRlbS5fZG9jLnR5cGVdIH0pKTsgfSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYm9va1NlY3Rpb25kZXRhaWxzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBpdGVtKSwgeyB0eXBlOiBTRUNUSU9OX1RZUEVfTUFQW2l0ZW0udHlwZV0gfSkpOyB9KSk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGJvb2s6IGJvb2ssXG4gICAgICAgICAgICAgICAgICAgIGJvb2tTZWN0aW9uczogYm9va1NlY3Rpb25zLFxuICAgICAgICAgICAgICAgICAgICBib29rU2VjdGlvbmRldGFpbE1hcDogYm9va1NlY3Rpb25kZXRhaWxNYXAsXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogKDAsIERhdGVVdGlsc18xLmZvcm1hdERhdGVUZXh0KShib29rLmNyZWF0ZWRBdCwgRGF0ZVV0aWxzXzEuRk9STUFUX0ZVTExfREFURSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGVqcy5yZW5kZXJGaWxlKF9nZXRfdGVtcGxhdGVfcGF0aChcIi9zcmMvdGVtcGxhdGVzL2Jvb2svdGVtcGxhdGUuZWpzXCIpLCBkYXRhKV07XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgaHRtbCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIF9nZXRfemlwX2ZpbGUoaHRtbCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2VuZXJhdGVSZXBvcnRGb3JCb29rID0gZ2VuZXJhdGVSZXBvcnRGb3JCb29rO1xudmFyIF9nZW5lcmF0ZVJlcG9ydEZvclNlY3Rpb25kZXRhaWwgPSBmdW5jdGlvbiAoYm9va3NlY3Rpb25kZXRhaWwpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGEsIGh0bWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgdGl0bGU6IGJvb2tzZWN0aW9uZGV0YWlsLm5hbWUsXG4gICAgICAgICAgICBzdW1tYXJ5OiBib29rc2VjdGlvbmRldGFpbC5zdW1tYXJ5LFxuICAgICAgICAgICAgY29udGVudDogYm9va3NlY3Rpb25kZXRhaWwuY29udGVudCxcbiAgICAgICAgICAgIGtleXdvcmRzOiBib29rc2VjdGlvbmRldGFpbC5rZXl3b3JkcyxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogKDAsIERhdGVVdGlsc18xLmZvcm1hdERhdGVUZXh0KShib29rc2VjdGlvbmRldGFpbC5jcmVhdGVkQXQsIERhdGVVdGlsc18xLkZPUk1BVF9GVUxMX0RBVEUpLFxuICAgICAgICB9O1xuICAgICAgICBodG1sID0gZWpzLnJlbmRlckZpbGUoX2dldF90ZW1wbGF0ZV9wYXRoKFwiL3NyYy90ZW1wbGF0ZXMvYm9vay9wYXJ0aWFscy90ZW1wbGF0ZV9zZWN0aW9uZGV0YWlsLmVqc1wiKSwgZGF0YSk7XG4gICAgICAgIHJldHVybiBbMiwgaHRtbF07XG4gICAgfSk7XG59KTsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlbmVyYXRlUmVwb3J0Rm9yTm90ZVJlZiA9IGV4cG9ydHMuZ2VuZXJhdGVSZXBvcnRGb3JOb3RlID0gZXhwb3J0cy5nZW5lcmF0ZVJlcG9ydCA9IHZvaWQgMDtcbnZhciBheGlvcyA9IHJlcXVpcmUoXCJheGlvc1wiKTtcbnZhciBsb2Rhc2hfMSA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBNZXRhZGF0YURlZmluaXRpb25IZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL21ldGFkYXRhL2RlZmluaXRpb24vaGVscGVyXCIpKTtcbnZhciBOb3RlTGlua0hlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vbm90ZWxpbmsvaGVscGVyXCIpKTtcbnZhciBOb3RlTGlua0F1dG9IZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL25vdGVsaW5rL2F1dG8vaGVscGVyXCIpKTtcbnZhciBOb3RlSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9ub3RlL2hlbHBlclwiKSk7XG52YXIgVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvVXRpbHNcIik7XG52YXIgRGF0ZVV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vbGliL0RhdGVVdGlsc1wiKTtcbnZhciBlanMgPSByZXF1aXJlKFwiZWpzXCIpO1xudmFyIGpzemlwID0gcmVxdWlyZShcImpzemlwXCIpO1xudmFyIF9nZXRfdGVtcGxhdGVfcGF0aCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuY3dkKCkgKyBuYW1lO1xufTtcbnZhciBfZ2V0X3ppcF9maWxlID0gZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHppcDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB6aXAgPSBuZXcganN6aXAoKTtcbiAgICAgICAgICAgICAgICB6aXAuZmlsZShcImluZGV4Lmh0bWxcIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB6aXAuZ2VuZXJhdGVBc3luYyh7IHR5cGU6IFwiYmFzZTY0XCIsIGNvbXByZXNzaW9uOiBcIkRFRkxBVEVcIiB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgZ2VuZXJhdGVSZXBvcnQgPSBmdW5jdGlvbiAoc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdGVMaXN0LCBtZXRhZGF0YURlZmluaXRpb25MaXN0LCBodG1sLCBpLCBfYSwgX2I7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgTm90ZUhlbHBlci5nZXROb3RlKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbm90ZUxpc3QgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBNZXRhZGF0YURlZmluaXRpb25IZWxwZXIuZ2V0TWV0YWRhdGFEZWZpbml0aW9uKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFEZWZpbml0aW9uTGlzdCA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBodG1sID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDM7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IG5vdGVMaXN0Lmxlbmd0aCkpIHJldHVybiBbMywgN107XG4gICAgICAgICAgICAgICAgX2EgPSBodG1sO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIGV4cG9ydHMuZ2VuZXJhdGVSZXBvcnRGb3JOb3RlKShzcGFjZSwgbm90ZUxpc3RbaV0ucmVmZXJlbmNlLCBtZXRhZGF0YURlZmluaXRpb25MaXN0KV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaHRtbCA9IF9hICsgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIF9iID0gaHRtbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGVqcy5yZW5kZXJGaWxlKF9nZXRfdGVtcGxhdGVfcGF0aChcIi9zcmMvdGVtcGxhdGVzL25vdGUvcGFydGlhbHMvdGVtcGxhdGVfcGFnZWJyZWFrLmVqc1wiKSwge30pXTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBodG1sID0gX2IgKyBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2MubGFiZWwgPSA2O1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIsIF9nZXRfemlwX2ZpbGUoaHRtbCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2VuZXJhdGVSZXBvcnQgPSBnZW5lcmF0ZVJlcG9ydDtcbnZhciBnZW5lcmF0ZVJlcG9ydEZvck5vdGUgPSBmdW5jdGlvbiAoc3BhY2UsIHJlZmVyZW5jZSwgbWV0YWRhdGFEZWZpbml0aW9uTGlzdCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm90ZSwgX21ldGFkYXRhRGVmaW5pdGlvbkxpc3QsIGRhdGEsIGh0bWwsIG5vdGVsaW5rcywgbm90ZWxpbmtzQXV0bywgX2EsIGksIGxpbmtlZE5vdGVSZWYsIHJlZk5vdGUsIF9iLCBpLCBsaW5rZWROb3RlUmVmLCByZWZOb3RlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIE5vdGVIZWxwZXIuZ2V0Tm90ZUJ5UmVmZXJlbmNlKHNwYWNlLCByZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBub3RlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghbm90ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFwiTm90ZSBub3QgZm91bmRcIl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9tZXRhZGF0YURlZmluaXRpb25MaXN0ID0gbWV0YWRhdGFEZWZpbml0aW9uTGlzdDtcbiAgICAgICAgICAgICAgICBpZiAoISFfbWV0YWRhdGFEZWZpbml0aW9uTGlzdCkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIE1ldGFkYXRhRGVmaW5pdGlvbkhlbHBlci5nZXRNZXRhZGF0YURlZmluaXRpb24oc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfbWV0YWRhdGFEZWZpbml0aW9uTGlzdCA9XG4gICAgICAgICAgICAgICAgICAgIF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDM7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IG5vdGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogbm90ZS5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBub3RlLmNvbnRlbnQucmVwbGFjZSgvPHA+4oCLPFxcL3A+L2dpLCBcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHM6IG5vdGUua2V5d29yZHMsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsczogW10sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogKDAsIERhdGVVdGlsc18xLmZvcm1hdERhdGVUZXh0KShub3RlLmNyZWF0ZWRBdCwgRGF0ZVV0aWxzXzEuRk9STUFUX0ZVTExfREFURSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCBVdGlsc18xLmlzRW1wdHlPclNwYWNlcykobm90ZS5wcmltYXJ5TGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubGFiZWxzID0gX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlLnByaW1hcnlMYWJlbFxuICAgICAgICAgICAgICAgICAgICBdLCBub3RlLmxhYmVscy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0gIT09IG5vdGUucHJpbWFyeUxhYmVsOyB9KSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZWpzLnJlbmRlckZpbGUoX2dldF90ZW1wbGF0ZV9wYXRoKFwiL3NyYy90ZW1wbGF0ZXMvbm90ZS90ZW1wbGF0ZV9ub3RlLmVqc1wiKSwgZGF0YSldO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGh0bWwgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBOb3RlTGlua0hlbHBlci5nZXROb3RlbGlua0J5UmVmZXJlbmNlKHNwYWNlLCByZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBub3RlbGlua3MgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBOb3RlTGlua0F1dG9IZWxwZXIuZ2V0Tm90ZWxpbmtBdXRvQnlOb3RlUmVmKHNwYWNlLCByZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBub3RlbGlua3NBdXRvID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghKG5vdGVsaW5rcy5sZW5ndGggPiAwKSkgcmV0dXJuIFszLCA4XTtcbiAgICAgICAgICAgICAgICBfYSA9IGh0bWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBlanMucmVuZGVyRmlsZShfZ2V0X3RlbXBsYXRlX3BhdGgoXCIvc3JjL3RlbXBsYXRlcy9ub3RlL3BhcnRpYWxzL3RlbXBsYXRlX3NlY3Rpb25fdGl0bGUuZWpzXCIpLCB7IHRpdGxlOiBcIlJlZmVyZW5jZXNcIiB9KV07XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgaHRtbCA9IF9hICsgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gODtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgaWYgKCEoaSA8IG5vdGVsaW5rcy5sZW5ndGgpKSByZXR1cm4gWzMsIDEyXTtcbiAgICAgICAgICAgICAgICBsaW5rZWROb3RlUmVmID0gbm90ZWxpbmtzW2ldLmxpbmtlZE5vdGVSZWY7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmtlZE5vdGVSZWYgPT09IHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rZWROb3RlUmVmID0gbm90ZWxpbmtzW2ldLnNvdXJjZU5vdGVSZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIGV4cG9ydHMuZ2VuZXJhdGVSZXBvcnRGb3JOb3RlUmVmKShzcGFjZSwgbGlua2VkTm90ZVJlZiwgbnVsbCwgX21ldGFkYXRhRGVmaW5pdGlvbkxpc3QpXTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgcmVmTm90ZSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBodG1sICs9IHJlZk5vdGU7XG4gICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxMTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgOV07XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgIGlmICghKG5vdGVsaW5rc0F1dG8ubGVuZ3RoID4gMCkpIHJldHVybiBbMywgMTRdO1xuICAgICAgICAgICAgICAgIF9iID0gaHRtbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGVqcy5yZW5kZXJGaWxlKF9nZXRfdGVtcGxhdGVfcGF0aChcIi9zcmMvdGVtcGxhdGVzL25vdGUvcGFydGlhbHMvdGVtcGxhdGVfc2VjdGlvbl90aXRsZS5lanNcIiksIHsgdGl0bGU6IFwiQXV0byBsaW5rZWQgUmVmZXJlbmNlc1wiIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgaHRtbCA9IF9iICsgX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTQ7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTU7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgIGlmICghKGkgPCBub3RlbGlua3NBdXRvLmxlbmd0aCkpIHJldHVybiBbMywgMThdO1xuICAgICAgICAgICAgICAgIGxpbmtlZE5vdGVSZWYgPSBub3RlbGlua3NBdXRvW2ldLmxpbmtlZE5vdGVSZWY7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmtlZE5vdGVSZWYgPT09IHJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rZWROb3RlUmVmID0gbm90ZWxpbmtzQXV0b1tpXS5zb3VyY2VOb3RlUmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBleHBvcnRzLmdlbmVyYXRlUmVwb3J0Rm9yTm90ZVJlZikoc3BhY2UsIGxpbmtlZE5vdGVSZWYsIG5vdGUuX2RvYy5rZXl3b3JkcywgX21ldGFkYXRhRGVmaW5pdGlvbkxpc3QpXTtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgcmVmTm90ZSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBodG1sICs9IHJlZk5vdGU7XG4gICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxNztcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgMTVdO1xuICAgICAgICAgICAgY2FzZSAxODogcmV0dXJuIFsyLCBfZ2V0X3ppcF9maWxlKGh0bWwpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdlbmVyYXRlUmVwb3J0Rm9yTm90ZSA9IGdlbmVyYXRlUmVwb3J0Rm9yTm90ZTtcbnZhciBnZW5lcmF0ZVJlcG9ydEZvck5vdGVSZWYgPSBmdW5jdGlvbiAoc3BhY2UsIHJlZmVyZW5jZSwgc291cmNlS2V5d29yZHMsIG1ldGFkYXRhRGVmaW5pdGlvbkxpc3QpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5vdGUsIGRhdGEsIG1ldGFkYXRhLCBodG1sO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIE5vdGVIZWxwZXIuZ2V0Tm90ZUJ5UmVmZXJlbmNlKHNwYWNlLCByZWZlcmVuY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBub3RlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBub3RlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IG5vdGUuc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogbm90ZS5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3Jkczogbm90ZS5rZXl3b3JkcyxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0OiAoMCwgRGF0ZVV0aWxzXzEuZm9ybWF0RGF0ZVRleHQpKG5vdGUuY3JlYXRlZEF0LCBEYXRlVXRpbHNfMS5GT1JNQVRfRlVMTF9EQVRFKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gW107XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFEZWZpbml0aW9uTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJcIi5jb25jYXQoaXRlbS5fZG9jLmdyb3VwLCBcIiB8IFwiKS5jb25jYXQoaXRlbS5fZG9jLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5vdGUuX2RvY1tpdGVtLl9kb2MuX2lkXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGF0YS5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGlmICghKDAsIFV0aWxzXzEuaXNFbXB0eU9yU3BhY2VzKShub3RlLnByaW1hcnlMYWJlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5sYWJlbHMgPSBfX3NwcmVhZEFycmF5KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGUucHJpbWFyeUxhYmVsXG4gICAgICAgICAgICAgICAgICAgIF0sIG5vdGUubGFiZWxzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbSAhPT0gbm90ZS5wcmltYXJ5TGFiZWw7IH0pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5rZXl3b3JkcyA9ICgwLCBsb2Rhc2hfMS5pbnRlcnNlY3Rpb24pKHNvdXJjZUtleXdvcmRzLCBub3RlLl9kb2Mua2V5d29yZHMpO1xuICAgICAgICAgICAgICAgIGh0bWwgPSBlanMucmVuZGVyRmlsZShfZ2V0X3RlbXBsYXRlX3BhdGgoXCIvc3JjL3RlbXBsYXRlcy9ub3RlL3BhcnRpYWxzL3RlbXBsYXRlX25vdGVyZWYuZWpzXCIpLCBkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGh0bWxdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2VuZXJhdGVSZXBvcnRGb3JOb3RlUmVmID0gZ2VuZXJhdGVSZXBvcnRGb3JOb3RlUmVmO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLmdldChcIi9yZXBvcnQvOnNwYWNlLzpub3RlUmVmXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdlbmVyYXRlUmVwb3J0Rm9yTm90ZSkpO1xuICAgIHJvdXRlci5nZXQoXCIvcmVwb3J0LzpzcGFjZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5nZW5lcmF0ZVJlcG9ydCkpO1xuICAgIHJvdXRlci5nZXQoXCIvcmVwb3J0L2Jvb2svOnNwYWNlLzpib29rcmVmXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdlbmVyYXRlUmVwb3J0Rm9yQm9vaykpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlbmVyYXRlUmVwb3J0Rm9yQm9vayA9IGV4cG9ydHMuZ2VuZXJhdGVSZXBvcnQgPSBleHBvcnRzLmdlbmVyYXRlUmVwb3J0Rm9yTm90ZSA9IHZvaWQgMDtcbnZhciBOb3RlSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL25vdGVfaGVscGVyXCIpKTtcbnZhciBCb29rSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jvb2tfaGVscGVyXCIpKTtcbnZhciBnZW5lcmF0ZVJlcG9ydEZvck5vdGUgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcG9ydDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBOb3RlSGVscGVyLmdlbmVyYXRlUmVwb3J0Rm9yTm90ZShyZXEucGFyYW1zLnNwYWNlLCByZXEucGFyYW1zLm5vdGVSZWYpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXBvcnQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZW5lcmF0ZVJlcG9ydEZvck5vdGUgPSBnZW5lcmF0ZVJlcG9ydEZvck5vdGU7XG52YXIgZ2VuZXJhdGVSZXBvcnQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcG9ydDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBOb3RlSGVscGVyLmdlbmVyYXRlUmVwb3J0KHJlcS5wYXJhbXMuc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXBvcnQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHJlcG9ydCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZW5lcmF0ZVJlcG9ydCA9IGdlbmVyYXRlUmVwb3J0O1xudmFyIGdlbmVyYXRlUmVwb3J0Rm9yQm9vayA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVwb3J0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEJvb2tIZWxwZXIuZ2VuZXJhdGVSZXBvcnRGb3JCb29rKHJlcS5wYXJhbXMuc3BhY2UsIHJlcS5wYXJhbXMuYm9va3JlZildO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlcG9ydCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQocmVwb3J0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdlbmVyYXRlUmVwb3J0Rm9yQm9vayA9IGdlbmVyYXRlUmVwb3J0Rm9yQm9vaztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNldHZhbCA9IGV4cG9ydHMubmV4dHZhbCA9IGV4cG9ydHMuY3JlYXRlX3NlcXVlbmNlID0gdm9pZCAwO1xudmFyIF9hID0gcmVxdWlyZSgnLi9tb2RlbCcpLCBzZXF1ZW5jZUNvbGxlY3Rpb24gPSBfYS5zZXF1ZW5jZUNvbGxlY3Rpb24sIHNlcXVlbmNlU2NoZW1hID0gX2Euc2VxdWVuY2VTY2hlbWE7XG52YXIgX2IgPSByZXF1aXJlKCcuLi8uLi9saWIvZGJ1dGlscycpLCBnZXRHbG9iYWxDb2xsZWN0aW9uID0gX2IuZ2V0R2xvYmFsQ29sbGVjdGlvbiwgZ2V0Q29sbGVjdGlvbiA9IF9iLmdldENvbGxlY3Rpb247XG52YXIgY3JlYXRlX3NlcXVlbmNlID0gZnVuY3Rpb24gKGZpZWxkLCBjb250ZXh0LCBmYWN0b3IsIHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgZXhpc3Rpbmdfc2VxdWVuY2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgc2VxdWVuY2VDb2xsZWN0aW9uLCBzZXF1ZW5jZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IGdldEdsb2JhbENvbGxlY3Rpb24oc2VxdWVuY2VDb2xsZWN0aW9uLCBzZXF1ZW5jZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZE9uZSh7IGZpZWxkOiBmaWVsZCwgY29udGV4dDogY29udGV4dCB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZXhpc3Rpbmdfc2VxdWVuY2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nX3NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZXhpc3Rpbmdfc2VxdWVuY2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRPbmVBbmRVcGRhdGUoeyBmaWVsZDogZmllbGQsIGNvbnRleHQ6IGNvbnRleHQgfSwgeyBmaWVsZDogZmllbGQsIGNvbnRleHQ6IGNvbnRleHQsIGZhY3RvcjogZmFjdG9yLCBuZXh0dmFsOiAxIH0sIHsgdXBzZXJ0OiB0cnVlLCBuZXc6IHRydWUgfSldO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVfc2VxdWVuY2UgPSBjcmVhdGVfc2VxdWVuY2U7XG52YXIgbmV4dHZhbCA9IGZ1bmN0aW9uIChmaWVsZCwgY29udGV4dCwgc3BhY2UpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsLCBzZXF1ZW5jZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBzZXF1ZW5jZUNvbGxlY3Rpb24sIHNlcXVlbmNlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0R2xvYmFsQ29sbGVjdGlvbihzZXF1ZW5jZUNvbGxlY3Rpb24sIHNlcXVlbmNlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kT25lKHsgZmllbGQ6IGZpZWxkLCBjb250ZXh0OiBjb250ZXh0IH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoISFzZXF1ZW5jZSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBleHBvcnRzLmNyZWF0ZV9zZXF1ZW5jZSkoZmllbGQsIGNvbnRleHQgfHwgbnVsbCwgMSwgc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kT25lKHsgZmllbGQ6IGZpZWxkLCBjb250ZXh0OiBjb250ZXh0IH0pXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbNCwgbW9kZWwuZmluZE9uZUFuZFVwZGF0ZSh7IGZpZWxkOiBmaWVsZCwgY29udGV4dDogY29udGV4dCB9LCB7IG5leHR2YWw6IHNlcXVlbmNlLm5leHR2YWwgKyBzZXF1ZW5jZS5mYWN0b3IgfSwgeyB1cHNlcnQ6IHRydWUsIG5ldzogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgc2VxdWVuY2UubmV4dHZhbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5uZXh0dmFsID0gbmV4dHZhbDtcbnZhciByZXNldHZhbCA9IGZ1bmN0aW9uICh2YWx1ZSwgZmllbGQsIGNvbnRleHQsIHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgc2VxdWVuY2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgc2VxdWVuY2VDb2xsZWN0aW9uLCBzZXF1ZW5jZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IGdldEdsb2JhbENvbGxlY3Rpb24oc2VxdWVuY2VDb2xsZWN0aW9uLCBzZXF1ZW5jZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZE9uZSh7IGZpZWxkOiBmaWVsZCwgY29udGV4dDogY29udGV4dCB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgc2VxdWVuY2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCEhc2VxdWVuY2UpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgZXhwb3J0cy5jcmVhdGVfc2VxdWVuY2UpKGZpZWxkLCBjb250ZXh0IHx8IG51bGwsIDEsIHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZE9uZSh7IGZpZWxkOiBmaWVsZCwgY29udGV4dDogY29udGV4dCB9KV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgc2VxdWVuY2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzQsIG1vZGVsLmZpbmRPbmVBbmRVcGRhdGUoeyBmaWVsZDogZmllbGQsIGNvbnRleHQ6IGNvbnRleHQgfSwgeyBuZXh0dmFsOiB2YWx1ZSB9LCB7IHVwc2VydDogdHJ1ZSwgbmV3OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnJlc2V0dmFsID0gcmVzZXR2YWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNvbHZlcnMgPSBleHBvcnRzLnR5cGVEZWZzID0gdm9pZCAwO1xudmFyIGpzb253ZWJ0b2tlbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqc29ud2VidG9rZW5cIikpO1xudmFyIGFwb2xsb19zZXJ2ZXJfZXhwcmVzc18xID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgbW9kZWxfMiA9IHJlcXVpcmUoXCIuLi91c2VyL21vZGVsXCIpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciBheGlvcyA9IHJlcXVpcmUoXCJheGlvc1wiKTtcbnZhciBPTkVBVVRIX0FQSSA9IHByb2Nlc3MuZW52Lk9ORUFVVEhfQVBJIHx8IFwiaHR0cDovLzEyNy4wLjAuMTo4MDIwXCI7XG52YXIgdHlwZURlZnMgPSAoMCwgYXBvbGxvX3NlcnZlcl9leHByZXNzXzEuZ3FsKSh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBleHRlbmQgdHlwZSBRdWVyeSB7XFxuICAgIHNlc3Npb24oaWQ6IElEISwgc3BhY2U6IFN0cmluZyk6IFVzZXJTZXNzaW9uXFxuICB9XFxuXFxuICB0eXBlIFNlc3Npb24ge1xcbiAgICBpZDogSUQhXFxuICAgIHNlc3Npb25JZDogU3RyaW5nIVxcbiAgICB0b2tlbjogU3RyaW5nIVxcbiAgfVxcblxcbiAgdHlwZSBVc2VyU2Vzc2lvbiB7XFxuICAgIGlkOiBJRCFcXG4gICAgZmlyc3ROYW1lOiBTdHJpbmdcXG4gICAgbGFzdE5hbWU6IFN0cmluZ1xcbiAgICBlbWFpbDogU3RyaW5nXFxuICAgIHRva2VuOiBTdHJpbmdcXG4gIH1cXG5cIl0sIFtcIlxcbiAgZXh0ZW5kIHR5cGUgUXVlcnkge1xcbiAgICBzZXNzaW9uKGlkOiBJRCEsIHNwYWNlOiBTdHJpbmcpOiBVc2VyU2Vzc2lvblxcbiAgfVxcblxcbiAgdHlwZSBTZXNzaW9uIHtcXG4gICAgaWQ6IElEIVxcbiAgICBzZXNzaW9uSWQ6IFN0cmluZyFcXG4gICAgdG9rZW46IFN0cmluZyFcXG4gIH1cXG5cXG4gIHR5cGUgVXNlclNlc3Npb24ge1xcbiAgICBpZDogSUQhXFxuICAgIGZpcnN0TmFtZTogU3RyaW5nXFxuICAgIGxhc3ROYW1lOiBTdHJpbmdcXG4gICAgZW1haWw6IFN0cmluZ1xcbiAgICB0b2tlbjogU3RyaW5nXFxuICB9XFxuXCJdKSkpO1xuZXhwb3J0cy50eXBlRGVmcyA9IHR5cGVEZWZzO1xudmFyIG9hU2Vzc2lvbiA9IGZ1bmN0aW9uIChzcGFjZSwgaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3BvbnNlLCB1c2VyLCBtb2RlbCwgZGF0YSwgZXJyb3JfMTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDUsICwgNl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgYXhpb3MuZ2V0KFwiXCIuY29uY2F0KE9ORUFVVEhfQVBJLCBcIi9hdXRoL3NwYWNlL1wiKS5jb25jYXQoc3BhY2UsIFwiL3Nlc3Npb24vXCIpLmNvbmNhdChpZCkpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgdXNlciA9IGpzb253ZWJ0b2tlbl8xLmRlZmF1bHQudmVyaWZ5KHJlc3BvbnNlLmRhdGEudG9rZW4sIFwiand0c2VjcmV0XCIpO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMi51c2VyQ29sbGVjdGlvbiwgbW9kZWxfMi51c2VyU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKHVzZXIudXNlcklkLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdXNlciksIHsgcmVzb2x2ZXI6IFwib25lYXV0aF9zcGFjZVwiIH0pLCB7IG5ldzogdHJ1ZSwgdXBzZXJ0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkYXRhLl9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5hbWU6IGRhdGEuZmlyc3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROYW1lOiBkYXRhLmxhc3ROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsOiBkYXRhLmVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiByZXNwb25zZS5kYXRhLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDRdO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzMsIDZdO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG52YXIgZW1haWxPckV4dGVyblNlc3Npb24gPSBmdW5jdGlvbiAoc3BhY2UsIHNlc3Npb25JZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIHNlc3Npb24sIGRhdGE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLnNlc3Npb25Db2xsZWN0aW9uLCBtb2RlbF8xLnNlc3Npb25TY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZE9uZSh7IHNlc3Npb25JZDogc2Vzc2lvbklkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGpzb253ZWJ0b2tlbl8xLmRlZmF1bHQudmVyaWZ5KHNlc3Npb24udG9rZW4sIFwiand0c2VjcmV0XCIpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBkYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkYXRhLnVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0TmFtZTogZGF0YS5maXJzdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0TmFtZTogZGF0YS5sYXN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsOiBkYXRhLmVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHNlc3Npb24udG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbnZhciByZXNvbHZlcnMgPSB7XG4gICAgUXVlcnk6IHtcbiAgICAgICAgc2Vzc2lvbjogZnVuY3Rpb24gKF8xLCBfYSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgW18xLCBfYV0sIHZvaWQgMCwgZnVuY3Rpb24gKF8sIF9iKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfYi5pZCwgc3BhY2UgPSBfYi5zcGFjZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBvYVNlc3Npb24oc3BhY2UsIGlkKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYy5zZW50KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfSxcbiAgICB9LFxufTtcbmV4cG9ydHMucmVzb2x2ZXJzID0gcmVzb2x2ZXJzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2Vzc2lvbkNvbGxlY3Rpb24gPSBleHBvcnRzLnNlc3Npb25TY2hlbWEgPSB2b2lkIDA7XG52YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG52YXIgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xudmFyIHNlc3Npb25TY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICBzZXNzaW9uSWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdG9rZW46IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdHlwZTogeyB0eXBlOiBTdHJpbmcgfSxcbn0sIHsgdGltZXN0YW1wczogdHJ1ZSB9KTtcbmV4cG9ydHMuc2Vzc2lvblNjaGVtYSA9IHNlc3Npb25TY2hlbWE7XG52YXIgc2Vzc2lvbkNvbGxlY3Rpb24gPSBcInNlc3Npb25cIjtcbmV4cG9ydHMuc2Vzc2lvbkNvbGxlY3Rpb24gPSBzZXNzaW9uQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXNldFN0b3B3b3JkcyA9IGV4cG9ydHMuZGVsZXRlU3RvcHdvcmQgPSBleHBvcnRzLmdldFN0b3B3b3JkcyA9IGV4cG9ydHMudG9nZ2xlU3RvcHdvcmQgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgc3RvcHdvcmRzXzEgPSByZXF1aXJlKFwiLi9zdG9wd29yZHNcIik7XG52YXIgZ2V0Q29sbGVjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi9saWIvZGJ1dGlsc1wiKS5nZXRDb2xsZWN0aW9uO1xudmFyIHRvZ2dsZVN0b3B3b3JkID0gZnVuY3Rpb24gKHNwYWNlLCBwYXlsb2FkKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGV4dCwgbW9kZWwsIHJlc3BvbnNlLCBleGlzdGluZ0RhdGE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX3RleHQgPSBwYXlsb2FkLnRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuc3RvcHdvcmRzQ29sbGVjdGlvbiwgbW9kZWxfMS5zdG9wd29yZHNTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyB0ZXh0OiBfdGV4dCB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdEYXRhID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghKGV4aXN0aW5nRGF0YS5sZW5ndGggPiAwKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRPbmVBbmRVcGRhdGUoeyB0ZXh0OiBfdGV4dCB9LCB7IGVuYWJsZWQ6ICFleGlzdGluZ0RhdGFbMF0uZW5hYmxlZCB9LCB7IG5ldzogdHJ1ZSwgdXBzZXJ0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDVdO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQsIG1vZGVsLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IF90ZXh0LCBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcbiAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFs0LCAoMCwgZXhwb3J0cy5nZXRTdG9wd29yZHMpKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnRvZ2dsZVN0b3B3b3JkID0gdG9nZ2xlU3RvcHdvcmQ7XG52YXIgZ2V0U3RvcHdvcmRzID0gZnVuY3Rpb24gKHNwYWNlKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEuc3RvcHdvcmRzQ29sbGVjdGlvbiwgbW9kZWxfMS5zdG9wd29yZHNTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCgpLnNvcnQoeyB0ZXh0OiBcImFzY2VuZGluZ1wiIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0U3RvcHdvcmRzID0gZ2V0U3RvcHdvcmRzO1xudmFyIGRlbGV0ZVN0b3B3b3JkID0gZnVuY3Rpb24gKHNwYWNlLCBfaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS5zdG9wd29yZHNDb2xsZWN0aW9uLCBtb2RlbF8xLnN0b3B3b3Jkc1NjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHsgX2lkOiBfaWQgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBleHBvcnRzLmdldFN0b3B3b3Jkcykoc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVsZXRlU3RvcHdvcmQgPSBkZWxldGVTdG9wd29yZDtcbnZhciByZXNldFN0b3B3b3JkcyA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIGRhdGE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLnN0b3B3b3Jkc0NvbGxlY3Rpb24sIG1vZGVsXzEuc3RvcHdvcmRzU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBkYXRhID0gW107XG4gICAgICAgICAgICAgICAgc3RvcHdvcmRzXzEuQkFTRV9TVE9QV09SRFNfRU4uZm9yRWFjaChmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5kZWxldGVNYW55KHt9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuaW5zZXJ0TWFueShkYXRhKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIGV4cG9ydHMuZ2V0U3RvcHdvcmRzKShzcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5yZXNldFN0b3B3b3JkcyA9IHJlc2V0U3RvcHdvcmRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0b3B3b3Jkc0NvbGxlY3Rpb24gPSBleHBvcnRzLnN0b3B3b3Jkc1NjaGVtYSA9IHZvaWQgMDtcbnZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcbnZhciBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG52YXIgc3RvcHdvcmRzU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgdGV4dDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBlbmFibGVkOiB7IHR5cGU6IEJvb2xlYW4gfVxufSwgeyB0aW1lc3RhbXBzOiB0cnVlLCBtaW5pbWl6ZTogZmFsc2UgfSk7XG5leHBvcnRzLnN0b3B3b3Jkc1NjaGVtYSA9IHN0b3B3b3Jkc1NjaGVtYTtcbnZhciBzdG9wd29yZHNDb2xsZWN0aW9uID0gXCJzdG9wd29yZHNcIjtcbmV4cG9ydHMuc3RvcHdvcmRzQ29sbGVjdGlvbiA9IHN0b3B3b3Jkc0NvbGxlY3Rpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoYW5kbGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vaGFuZGxlclwiKTtcbnZhciBtaWRkbGV3YXJlc18xID0gcmVxdWlyZShcIi4uLy4uL21pZGRsZXdhcmVzXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgcm91dGVyLnBvc3QoXCIvc3RvcHdvcmRzLzpzcGFjZVwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS50b2dnbGVTdG9wd29yZCkpO1xuICAgIHJvdXRlci5wb3N0KFwiL3N0b3B3b3Jkcy86c3BhY2UvcmVzZXRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEucmVzZXRTdG9wd29yZHMpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL3N0b3B3b3Jkcy86c3BhY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0U3RvcHdvcmRzKSk7XG4gICAgcm91dGVyLmRlbGV0ZShcIi9zdG9wd29yZHMvOnNwYWNlLzppZFwiLCBtaWRkbGV3YXJlc18xLmF1dGhvcml6ZUFwaSwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS5kZWxldGVTdG9wd29yZCkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFN0b3B3b3JkcyA9IGV4cG9ydHMuZGVsZXRlU3RvcHdvcmQgPSBleHBvcnRzLnJlc2V0U3RvcHdvcmRzID0gZXhwb3J0cy50b2dnbGVTdG9wd29yZCA9IHZvaWQgMDtcbnZhciBIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaGVscGVyXCIpKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG52YXIgdG9nZ2xlU3RvcHdvcmQgPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0b3B3b3JkcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBIZWxwZXIudG9nZ2xlU3RvcHdvcmQocmVxLnBhcmFtcy5zcGFjZSwgcmVxLmJvZHkpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzdG9wd29yZHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHN0b3B3b3Jkcyk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy50b2dnbGVTdG9wd29yZCA9IHRvZ2dsZVN0b3B3b3JkO1xudmFyIHJlc2V0U3RvcHdvcmRzID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdG9wd29yZHM7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgSGVscGVyLnJlc2V0U3RvcHdvcmRzKHJlcS5wYXJhbXMuc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzdG9wd29yZHMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHN0b3B3b3Jkcyk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5yZXNldFN0b3B3b3JkcyA9IHJlc2V0U3RvcHdvcmRzO1xudmFyIGRlbGV0ZVN0b3B3b3JkID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNwb25zZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBIZWxwZXIuZGVsZXRlU3RvcHdvcmQocmVxLnBhcmFtcy5zcGFjZSwgcmVxLnBhcmFtcy5pZCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoMjAwKTtcbiAgICAgICAgICAgICAgICByZXMuc2VuZChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5kZWxldGVTdG9wd29yZCA9IGRlbGV0ZVN0b3B3b3JkO1xudmFyIGdldFN0b3B3b3JkcyA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RvcHdvcmRzO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIEhlbHBlci5nZXRTdG9wd29yZHMocmVxLnBhcmFtcy5zcGFjZSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHN0b3B3b3JkcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoc3RvcHdvcmRzKTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFN0b3B3b3JkcyA9IGdldFN0b3B3b3JkcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CQVNFX1NUT1BXT1JEU19FTiA9IHZvaWQgMDtcbmV4cG9ydHMuQkFTRV9TVE9QV09SRFNfRU4gPSBbXG4gICAgJ3gnLFxuICAgICd5JyxcbiAgICAneW91cicsXG4gICAgJ3lvdXJzJyxcbiAgICAneW91cnNlbGYnLFxuICAgICd5b3Vyc2VsdmVzJyxcbiAgICAneW91JyxcbiAgICAneW9uZCcsXG4gICAgJ3lvbmRlcicsXG4gICAgJ3lvbicsXG4gICAgJ3llJyxcbiAgICAneWV0JyxcbiAgICAneicsXG4gICAgJ3ppbGxpb24nLFxuICAgICdqJyxcbiAgICAndScsXG4gICAgJ3VtcHRlZW4nLFxuICAgICd1c3VhbGx5JyxcbiAgICAndXMnLFxuICAgICd1c2VybmFtZScsXG4gICAgJ3Vwb25lZCcsXG4gICAgJ3Vwb25zJyxcbiAgICAndXBvbmluZycsXG4gICAgJ3Vwb24nLFxuICAgICd1cHMnLFxuICAgICd1cHBpbmcnLFxuICAgICd1cHBlZCcsXG4gICAgJ3VwJyxcbiAgICAndW50bycsXG4gICAgJ3VudGlsJyxcbiAgICAndW5sZXNzJyxcbiAgICAndW5saWtlJyxcbiAgICAndW5saWtlcicsXG4gICAgJ3VubGlrZXN0JyxcbiAgICAndW5kZXInLFxuICAgICd1bmRlcm5lYXRoJyxcbiAgICAndXNlJyxcbiAgICAndXNlZCcsXG4gICAgJ3VzZWRlc3QnLFxuICAgICdyJyxcbiAgICAncmF0aCcsXG4gICAgJ3JhdGhlcicsXG4gICAgJ3JhdGhlc3QnLFxuICAgICdyYXRoZScsXG4gICAgJ3JlJyxcbiAgICAncmVsYXRlJyxcbiAgICAncmVsYXRlZCcsXG4gICAgJ3JlbGF0aXZlbHknLFxuICAgICdyZWdhcmRpbmcnLFxuICAgICdyZWFsbHknLFxuICAgICdyZXMnLFxuICAgICdyZXNwZWN0aW5nJyxcbiAgICAncmVzcGVjdGl2ZWx5JyxcbiAgICAncScsXG4gICAgJ3F1aXRlJyxcbiAgICAncXVlJyxcbiAgICAncXVhJyxcbiAgICAnbicsXG4gICAgJ25laXRoZXInLFxuICAgICduZWF0aHMnLFxuICAgICduZWF0aCcsXG4gICAgJ25ldGhlJyxcbiAgICAnbmV0aGVybW9zdCcsXG4gICAgJ25lY2Vzc2FyeScsXG4gICAgJ25lY2Vzc2FyaWVzdCcsXG4gICAgJ25lY2Vzc2FyaWVyJyxcbiAgICAnbmV2ZXInLFxuICAgICduZXZlcnRoZWxlc3MnLFxuICAgICduaWdoJyxcbiAgICAnbmlnaGVzdCcsXG4gICAgJ25pZ2hlcicsXG4gICAgJ25pbmUnLFxuICAgICdub29uZScsXG4gICAgJ25vYm9keScsXG4gICAgJ25vYm9kaWVzJyxcbiAgICAnbm93aGVyZScsXG4gICAgJ25vd2hlcmVzJyxcbiAgICAnbm8nLFxuICAgICdub2VzJyxcbiAgICAnbm9yJyxcbiAgICAnbm9zJyxcbiAgICAnbm8tb25lJyxcbiAgICAnbm9uZScsXG4gICAgJ25vdCcsXG4gICAgJ25vdHdpdGhzdGFuZGluZycsXG4gICAgJ25vdGhpbmdzJyxcbiAgICAnbm90aGluZycsXG4gICAgJ25hdGhsZXNzJyxcbiAgICAnbmF0aGVsZXNzJyxcbiAgICAndCcsXG4gICAgJ3RlbicsXG4gICAgJ3RpbGxzJyxcbiAgICAndGlsbCcsXG4gICAgJ3RpbGxlZCcsXG4gICAgJ3RpbGxpbmcnLFxuICAgICd0bycsXG4gICAgJ3Rvd2FyZHMnLFxuICAgICd0b3dhcmQnLFxuICAgICd0b3dhcmRlc3QnLFxuICAgICd0b3dhcmRlcicsXG4gICAgJ3RvZ2V0aGVyJyxcbiAgICAndG9vJyxcbiAgICAndGh5JyxcbiAgICAndGh5c2VsZicsXG4gICAgJ3RodXMnLFxuICAgICd0aGFuJyxcbiAgICAndGhhdCcsXG4gICAgJ3Rob3NlJyxcbiAgICAndGhvdScsXG4gICAgJ3Rob3VnaCcsXG4gICAgJ3Rob3VzJyxcbiAgICAndGhvdXNlcycsXG4gICAgJ3Rob3JvdWdoZXN0JyxcbiAgICAndGhvcm91Z2hlcicsXG4gICAgJ3Rob3JvdWdoJyxcbiAgICAndGhvcm91Z2hseScsXG4gICAgJ3RocnUnLFxuICAgICd0aHJ1ZXInLFxuICAgICd0aHJ1ZXN0JyxcbiAgICAndGhybycsXG4gICAgJ3Rocm91Z2gnLFxuICAgICd0aHJvdWdob3V0JyxcbiAgICAndGhyb3VnaGVzdCcsXG4gICAgJ3Rocm91Z2hlcicsXG4gICAgJ3RoaW5lJyxcbiAgICAndGhpcycsXG4gICAgJ3RoaXNlcycsXG4gICAgJ3RoZXknLFxuICAgICd0aGVlJyxcbiAgICAndGhlJyxcbiAgICAndGhlbicsXG4gICAgJ3RoZW5jZScsXG4gICAgJ3RoZW5lc3QnLFxuICAgICd0aGVuZXInLFxuICAgICd0aGVtJyxcbiAgICAndGhlbXNlbHZlcycsXG4gICAgJ3RoZXNlJyxcbiAgICAndGhlcmVyJyxcbiAgICAndGhlcmUnLFxuICAgICd0aGVyZWJ5JyxcbiAgICAndGhlcmVzdCcsXG4gICAgJ3RoZXJlYWZ0ZXInLFxuICAgICd0aGVyZWluJyxcbiAgICAndGhlcmV1cG9uJyxcbiAgICAndGhlcmVmb3JlJyxcbiAgICAndGhlaXInLFxuICAgICd0aGVpcnMnLFxuICAgICd0aGluZycsXG4gICAgJ3RoaW5ncycsXG4gICAgJ3RocmVlJyxcbiAgICAndHdvJyxcbiAgICAnbycsXG4gICAgJ29oJyxcbiAgICAnb3d0JyxcbiAgICAnb3duaW5nJyxcbiAgICAnb3duZWQnLFxuICAgICdvd24nLFxuICAgICdvd25zJyxcbiAgICAnb3RoZXJzJyxcbiAgICAnb3RoZXInLFxuICAgICdvdGhlcndpc2UnLFxuICAgICdvdGhlcndpc2VzdCcsXG4gICAgJ290aGVyd2lzZXInLFxuICAgICdvZicsXG4gICAgJ29mdGVuJyxcbiAgICAnb2Z0ZW5lcicsXG4gICAgJ29mdGVuZXN0JyxcbiAgICAnb2ZmJyxcbiAgICAnb2ZmcycsXG4gICAgJ29mZmVzdCcsXG4gICAgJ29uZScsXG4gICAgJ291Z2h0JyxcbiAgICAnb3VnaHRzJyxcbiAgICAnb3VyJyxcbiAgICAnb3VycycsXG4gICAgJ291cnNlbHZlcycsXG4gICAgJ291cnNlbGYnLFxuICAgICdvdXQnLFxuICAgICdvdXRlc3QnLFxuICAgICdvdXRlZCcsXG4gICAgJ291dHdpdGgnLFxuICAgICdvdXRzJyxcbiAgICAnb3V0c2lkZScsXG4gICAgJ292ZXInLFxuICAgICdvdmVyYWxsZXN0JyxcbiAgICAnb3ZlcmFsbGVyJyxcbiAgICAnb3ZlcmFsbHMnLFxuICAgICdvdmVyYWxsJyxcbiAgICAnb3ZlcnMnLFxuICAgICdvcicsXG4gICAgJ29yZXInLFxuICAgICdvcmVzdCcsXG4gICAgJ29uJyxcbiAgICAnb25lc2VsZicsXG4gICAgJ29uZXN0JyxcbiAgICAnb25zJyxcbiAgICAnb250bycsXG4gICAgJ2EnLFxuICAgICdhdHdlZW4nLFxuICAgICdhdCcsXG4gICAgJ2F0aHdhcnQnLFxuICAgICdhdG9wJyxcbiAgICAnYWZvcmUnLFxuICAgICdhZnRlcndhcmQnLFxuICAgICdhZnRlcndhcmRzJyxcbiAgICAnYWZ0ZXInLFxuICAgICdhZnRlcmVzdCcsXG4gICAgJ2FmdGVyZXInLFxuICAgICdhaW4nLFxuICAgICdhbicsXG4gICAgJ2FueScsXG4gICAgJ2FueXRoaW5nJyxcbiAgICAnYW55Ym9keScsXG4gICAgJ2FueW9uZScsXG4gICAgJ2FueWhvdycsXG4gICAgJ2FueXdoZXJlJyxcbiAgICAnYW5lbnQnLFxuICAgICdhbmVhcicsXG4gICAgJ2FuZCcsXG4gICAgJ2FuZG9yJyxcbiAgICAnYW5vdGhlcicsXG4gICAgJ2Fyb3VuZCcsXG4gICAgJ2FyZXMnLFxuICAgICdhcmUnLFxuICAgICdhZXN0JyxcbiAgICAnYWVyJyxcbiAgICAnYWdhaW5zdCcsXG4gICAgJ2FnYWluJyxcbiAgICAnYWNjb3JkaW5nbHknLFxuICAgICdhYmFmdCcsXG4gICAgJ2FiYWZ0ZXInLFxuICAgICdhYmFmdGVzdCcsXG4gICAgJ2Fib3Zlc3QnLFxuICAgICdhYm92ZScsXG4gICAgJ2Fib3ZlcicsXG4gICAgJ2Fib3V0ZXInLFxuICAgICdhYm91dGVzdCcsXG4gICAgJ2Fib3V0JyxcbiAgICAnYWlkJyxcbiAgICAnYW1pZHN0JyxcbiAgICAnYW1pZCcsXG4gICAgJ2Ftb25nJyxcbiAgICAnYW1vbmdzdCcsXG4gICAgJ2FwYXJ0ZXN0JyxcbiAgICAnYXBhcnRlcicsXG4gICAgJ2FwYXJ0JyxcbiAgICAnYXBwZWFyZWQnLFxuICAgICdhcHBlYXJzJyxcbiAgICAnYXBwZWFyJyxcbiAgICAnYXBwZWFyaW5nJyxcbiAgICAnYXBwcm9wcmlhdGluZycsXG4gICAgJ2FwcHJvcHJpYXRlJyxcbiAgICAnYXBwcm9wcmlhdGVzdCcsXG4gICAgJ2FwcHJvcHJpYXRlcycsXG4gICAgJ2FwcHJvcHJpYXRlcicsXG4gICAgJ2FwcHJvcHJpYXRlZCcsXG4gICAgJ2FscmVhZHknLFxuICAgICdhbHdheXMnLFxuICAgICdhbHNvJyxcbiAgICAnYWxvbmcnLFxuICAgICdhbG9uZ3NpZGUnLFxuICAgICdhbHRob3VnaCcsXG4gICAgJ2FsbW9zdCcsXG4gICAgJ2FsbCcsXG4gICAgJ2FsbGVzdCcsXG4gICAgJ2FsbGVyJyxcbiAgICAnYWxseW91JyxcbiAgICAnYWxscycsXG4gICAgJ2FsYmVpdCcsXG4gICAgJ2F3ZnVsbHknLFxuICAgICdhcycsXG4gICAgJ2FzaWRlJyxcbiAgICAnYXNpZGVzJyxcbiAgICAnYXNsYW50JyxcbiAgICAnYXNlcycsXG4gICAgJ2FzdHJpZGVyJyxcbiAgICAnYXN0cmlkZScsXG4gICAgJ2FzdHJpZGVzdCcsXG4gICAgJ2FzdHJhZGRsZXN0JyxcbiAgICAnYXN0cmFkZGxlcicsXG4gICAgJ2FzdHJhZGRsZScsXG4gICAgJ2F2YWlsYWJsZXN0JyxcbiAgICAnYXZhaWxhYmxlcicsXG4gICAgJ2F2YWlsYWJsZScsXG4gICAgJ2F1Z2h0cycsXG4gICAgJ2F1Z2h0JyxcbiAgICAndnMnLFxuICAgICd2JyxcbiAgICAndmFyaW91c2VzdCcsXG4gICAgJ3ZhcmlvdXNlcicsXG4gICAgJ3ZhcmlvdXMnLFxuICAgICd2aWEnLFxuICAgICd2aXMtYS12aXMnLFxuICAgICd2aXMtYS12aXNlcicsXG4gICAgJ3Zpcy1hLXZpc2VzdCcsXG4gICAgJ3ZpeicsXG4gICAgJ3ZlcnknLFxuICAgICd2ZXJpZXN0JyxcbiAgICAndmVyaWVyJyxcbiAgICAndmVyc3VzJyxcbiAgICAnaycsXG4gICAgJ2cnLFxuICAgICdnbycsXG4gICAgJ2dvbmUnLFxuICAgICdnb29kJyxcbiAgICAnZ290JyxcbiAgICAnZ290dGEnLFxuICAgICdnb3R0ZW4nLFxuICAgICdnZXQnLFxuICAgICdnZXRzJyxcbiAgICAnZ2V0dGluZycsXG4gICAgJ2InLFxuICAgICdieScsXG4gICAgJ2J5YW5kYnknLFxuICAgICdieS1hbmQtYnknLFxuICAgICdiaXN0JyxcbiAgICAnYm90aCcsXG4gICAgJ2J1dCcsXG4gICAgJ2J1dHMnLFxuICAgICdiZScsXG4gICAgJ2JleW9uZCcsXG4gICAgJ2JlY2F1c2UnLFxuICAgICdiZWNhbWUnLFxuICAgICdiZWNvbWVzJyxcbiAgICAnYmVjb21lJyxcbiAgICAnYmVjb21pbmcnLFxuICAgICdiZWNvbWluZ3MnLFxuICAgICdiZWNvbWluZ2VyJyxcbiAgICAnYmVjb21pbmdlc3QnLFxuICAgICdiZWhpbmQnLFxuICAgICdiZWhpbmRzJyxcbiAgICAnYmVmb3JlJyxcbiAgICAnYmVmb3JlaGFuZCcsXG4gICAgJ2JlZm9yZWhhbmRlc3QnLFxuICAgICdiZWZvcmVoYW5kZXInLFxuICAgICdiZXR0ZXJlZCcsXG4gICAgJ2JldHRlcnMnLFxuICAgICdiZXR0ZXInLFxuICAgICdiZXR0ZXJpbmcnLFxuICAgICdiZXR3aXh0JyxcbiAgICAnYmV0d2VlbicsXG4gICAgJ2JlbmVhdGgnLFxuICAgICdiZWVuJyxcbiAgICAnYmVsb3cnLFxuICAgICdiZXNpZGVzJyxcbiAgICAnYmVzaWRlJyxcbiAgICAnbScsXG4gICAgJ215JyxcbiAgICAnbXlzZWxmJyxcbiAgICAnbXVjaGVyJyxcbiAgICAnbXVjaGVzdCcsXG4gICAgJ211Y2gnLFxuICAgICdtdXN0JyxcbiAgICAnbXVzdHMnLFxuICAgICdtdXN0aHMnLFxuICAgICdtdXN0aCcsXG4gICAgJ21haW4nLFxuICAgICdtYWtlJyxcbiAgICAnbWF5ZXN0JyxcbiAgICAnbWFueScsXG4gICAgJ21hdWdlcicsXG4gICAgJ21hdWdyZScsXG4gICAgJ21lJyxcbiAgICAnbWVhbndoaWxlcycsXG4gICAgJ21lYW53aGlsZScsXG4gICAgJ21vc3RseScsXG4gICAgJ21vc3QnLFxuICAgICdtb3Jlb3ZlcicsXG4gICAgJ21vcmUnLFxuICAgICdtaWdodCcsXG4gICAgJ21pZ2h0cycsXG4gICAgJ21pZHN0JyxcbiAgICAnbWlkc3RzJyxcbiAgICAnaCcsXG4gICAgJ2h1aCcsXG4gICAgJ2h1bXBoJyxcbiAgICAnaGUnLFxuICAgICdoZXJzJyxcbiAgICAnaGVyc2VsZicsXG4gICAgJ2hlcicsXG4gICAgJ2hlcmVieScsXG4gICAgJ2hlcmVpbicsXG4gICAgJ2hlcmVhZnRlcnMnLFxuICAgICdoZXJlYWZ0ZXInLFxuICAgICdoZXJldXBvbicsXG4gICAgJ2hlbmNlJyxcbiAgICAnaGFkc3QnLFxuICAgICdoYWQnLFxuICAgICdoYXZpbmcnLFxuICAgICdoYXZlcycsXG4gICAgJ2hhdmUnLFxuICAgICdoYXMnLFxuICAgICdoYXN0JyxcbiAgICAnaGFyZGx5JyxcbiAgICAnaGFlJyxcbiAgICAnaGF0aCcsXG4gICAgJ2hpbScsXG4gICAgJ2hpbXNlbGYnLFxuICAgICdoaXRoZXInLFxuICAgICdoaXRoZXJlc3QnLFxuICAgICdoaXRoZXJlcicsXG4gICAgJ2hpcycsXG4gICAgJ2hvdy1kby15b3UtZG8nLFxuICAgICdob3dldmVyJyxcbiAgICAnaG93JyxcbiAgICAnaG93YmVpdCcsXG4gICAgJ2hvd2RveW91ZG8nLFxuICAgICdob29zJyxcbiAgICAnaG9vJyxcbiAgICAndycsXG4gICAgJ3dvdWxkZWQnLFxuICAgICd3b3VsZGluZycsXG4gICAgJ3dvdWxkJyxcbiAgICAnd291bGRzJyxcbiAgICAnd2FzJyxcbiAgICAnd2FzdCcsXG4gICAgJ3dlJyxcbiAgICAnd2VydCcsXG4gICAgJ3dlcmUnLFxuICAgICd3aXRoJyxcbiAgICAnd2l0aGFsJyxcbiAgICAnd2l0aG91dCcsXG4gICAgJ3dpdGhpbicsXG4gICAgJ3doeScsXG4gICAgJ3doYXQnLFxuICAgICd3aGF0ZXZlcicsXG4gICAgJ3doYXRldmVyZXInLFxuICAgICd3aGF0ZXZlcmVzdCcsXG4gICAgJ3doYXRzb2V2ZXJlcicsXG4gICAgJ3doYXRzb2V2ZXJlc3QnLFxuICAgICd3aGF0c29ldmVyJyxcbiAgICAnd2hlbmNlJyxcbiAgICAnd2hlbmNlc29ldmVyJyxcbiAgICAnd2hlbmV2ZXInLFxuICAgICd3aGVuc29ldmVyJyxcbiAgICAnd2hlbicsXG4gICAgJ3doZW5hcycsXG4gICAgJ3doZXRoZXInLFxuICAgICd3aGVlbicsXG4gICAgJ3doZXJldG8nLFxuICAgICd3aGVyZXVwb24nLFxuICAgICd3aGVyZXZlcicsXG4gICAgJ3doZXJlb24nLFxuICAgICd3aGVyZW9mJyxcbiAgICAnd2hlcmUnLFxuICAgICd3aGVyZWJ5JyxcbiAgICAnd2hlcmV3aXRoYWwnLFxuICAgICd3aGVyZXdpdGgnLFxuICAgICd3aGVyZWludG8nLFxuICAgICd3aGVyZWluJyxcbiAgICAnd2hlcmVhZnRlcicsXG4gICAgJ3doZXJlYXMnLFxuICAgICd3aGVyZXNvZXZlcicsXG4gICAgJ3doZXJlZnJvbScsXG4gICAgJ3doaWNoJyxcbiAgICAnd2hpY2hldmVyJyxcbiAgICAnd2hpY2hzb2V2ZXInLFxuICAgICd3aGlsc3QnLFxuICAgICd3aGlsZScsXG4gICAgJ3doaWxlcycsXG4gICAgJ3doaXRoZXJzb2V2ZXInLFxuICAgICd3aGl0aGVyJyxcbiAgICAnd2hvZXZlcicsXG4gICAgJ3dob3NvZXZlcicsXG4gICAgJ3dob3NvJyxcbiAgICAnd2hvc2UnLFxuICAgICd3aG9tZXZlcicsXG4gICAgJ3MnLFxuICAgICdzeW5lJyxcbiAgICAnc3luJyxcbiAgICAnc2hhbGxpbmcnLFxuICAgICdzaGFsbCcsXG4gICAgJ3NoYWxsZWQnLFxuICAgICdzaGFsbHMnLFxuICAgICdzaG91bGRpbmcnLFxuICAgICdzaG91bGQnLFxuICAgICdzaG91bGRlZCcsXG4gICAgJ3Nob3VsZHMnLFxuICAgICdzaGUnLFxuICAgICdzYXl5aWQnLFxuICAgICdzYXlpZCcsXG4gICAgJ3NhaWQnLFxuICAgICdzYWlkZXInLFxuICAgICdzYWlkZXN0JyxcbiAgICAnc2FtZScsXG4gICAgJ3NhbWVzdCcsXG4gICAgJ3NhbWVzJyxcbiAgICAnc2FtZXInLFxuICAgICdzYXZlZCcsXG4gICAgJ3NhbnMnLFxuICAgICdzYW5zZXMnLFxuICAgICdzYW5zZXJpZnMnLFxuICAgICdzYW5zZXJpZicsXG4gICAgJ3NvJyxcbiAgICAnc29lcicsXG4gICAgJ3NvZXN0JyxcbiAgICAnc29iZWl0JyxcbiAgICAnc29tZW9uZScsXG4gICAgJ3NvbWVib2R5JyxcbiAgICAnc29tZWhvdycsXG4gICAgJ3NvbWUnLFxuICAgICdzb21ld2hlcmUnLFxuICAgICdzb21ld2hhdCcsXG4gICAgJ3NvbWV0aGluZycsXG4gICAgJ3NvbWV0aW1lc3QnLFxuICAgICdzb21ldGltZXMnLFxuICAgICdzb21ldGltZXInLFxuICAgICdzb21ldGltZScsXG4gICAgJ3NldmVyYWwnLFxuICAgICdzZXZlcmFsZXInLFxuICAgICdzZXZlcmFsZXN0JyxcbiAgICAnc2VyaW91cycsXG4gICAgJ3NlcmlvdXNlc3QnLFxuICAgICdzZXJpb3VzZXInLFxuICAgICdzZW56YScsXG4gICAgJ3NlbmQnLFxuICAgICdzZW50JyxcbiAgICAnc2VlbScsXG4gICAgJ3NlZW1zJyxcbiAgICAnc2VlbWVkJyxcbiAgICAnc2VlbWluZ2VzdCcsXG4gICAgJ3NlZW1pbmdlcicsXG4gICAgJ3NlZW1pbmdzJyxcbiAgICAnc2V2ZW4nLFxuICAgICdzdW1tYXQnLFxuICAgICdzdXBzJyxcbiAgICAnc3VwJyxcbiAgICAnc3VwcGluZycsXG4gICAgJ3N1cHBlZCcsXG4gICAgJ3N1Y2gnLFxuICAgICdzaW5jZScsXG4gICAgJ3NpbmUnLFxuICAgICdzaW5lcycsXG4gICAgJ3NpdGgnLFxuICAgICdzaXgnLFxuICAgICdzdG9wJyxcbiAgICAnc3RvcHBlZCcsXG4gICAgJ3AnLFxuICAgICdwbGFpbnRpZmYnLFxuICAgICdwbGVudHknLFxuICAgICdwbGVudGllcycsXG4gICAgJ3BsZWFzZScsXG4gICAgJ3BsZWFzZWQnLFxuICAgICdwbGVhc2VzJyxcbiAgICAncGVyJyxcbiAgICAncGVyaGFwcycsXG4gICAgJ3BhcnRpY3VsYXJzJyxcbiAgICAncGFydGljdWxhcmx5JyxcbiAgICAncGFydGljdWxhcicsXG4gICAgJ3BhcnRpY3VsYXJlc3QnLFxuICAgICdwYXJ0aWN1bGFyZXInLFxuICAgICdwcm8nLFxuICAgICdwcm92aWRpbmcnLFxuICAgICdwcm92aWRlcycsXG4gICAgJ3Byb3ZpZGVkJyxcbiAgICAncHJvdmlkZScsXG4gICAgJ3Byb2JhYmx5JyxcbiAgICAnbCcsXG4gICAgJ2xheWFib3V0JyxcbiAgICAnbGF5YWJvdXRzJyxcbiAgICAnbGF0dGVyJyxcbiAgICAnbGF0dGVyZXN0JyxcbiAgICAnbGF0dGVyZXInLFxuICAgICdsYXR0ZXJseScsXG4gICAgJ2xhdHRlcnMnLFxuICAgICdsb3RzJyxcbiAgICAnbG90dGluZycsXG4gICAgJ2xvdHRlZCcsXG4gICAgJ2xvdCcsXG4gICAgJ2xlc3QnLFxuICAgICdsZXNzJyxcbiAgICAnaWUnLFxuICAgICdpZnMnLFxuICAgICdpZicsXG4gICAgJ2knLFxuICAgICdpbmZvJyxcbiAgICAnaW5mb3JtYXRpb24nLFxuICAgICdpdHNlbGYnLFxuICAgICdpdHMnLFxuICAgICdpdCcsXG4gICAgJ2lzJyxcbiAgICAnaWRlbScsXG4gICAgJ2lkZW1lcicsXG4gICAgJ2lkZW1lc3QnLFxuICAgICdpbW1lZGlhdGUnLFxuICAgICdpbW1lZGlhdGVseScsXG4gICAgJ2ltbWVkaWF0ZXN0JyxcbiAgICAnaW1tZWRpYXRlcicsXG4gICAgJ2luJyxcbiAgICAnaW53YXJkcycsXG4gICAgJ2lud2FyZGVzdCcsXG4gICAgJ2lud2FyZGVyJyxcbiAgICAnaW53YXJkJyxcbiAgICAnaW5hc211Y2gnLFxuICAgICdpbnRvJyxcbiAgICAnaW5zdGVhZCcsXG4gICAgJ2luc29mYXInLFxuICAgICdpbmRpY2F0ZXMnLFxuICAgICdpbmRpY2F0ZWQnLFxuICAgICdpbmRpY2F0ZScsXG4gICAgJ2luZGljYXRpbmcnLFxuICAgICdpbmRlZWQnLFxuICAgICdpbmMnLFxuICAgICdmJyxcbiAgICAnZmFjdCcsXG4gICAgJ2ZhY3RzJyxcbiAgICAnZnMnLFxuICAgICdmaWd1cG9uJyxcbiAgICAnZmlndXBvbnMnLFxuICAgICdmaWd1cG9uaW5nJyxcbiAgICAnZmlndXBvbmVkJyxcbiAgICAnZmV3JyxcbiAgICAnZmV3ZXInLFxuICAgICdmZXdlc3QnLFxuICAgICdmcmFlJyxcbiAgICAnZnJvbScsXG4gICAgJ2ZhaWxpbmcnLFxuICAgICdmYWlsaW5ncycsXG4gICAgJ2ZpdmUnLFxuICAgICdmdXJ0aGVycycsXG4gICAgJ2Z1cnRoZXJlcicsXG4gICAgJ2Z1cnRoZXJlZCcsXG4gICAgJ2Z1cnRoZXJlc3QnLFxuICAgICdmdXJ0aGVyJyxcbiAgICAnZnVydGhlcmluZycsXG4gICAgJ2Z1cnRoZXJtb3JlJyxcbiAgICAnZm91cnNjb3JlJyxcbiAgICAnZm9sbG93dGhyb3VnaCcsXG4gICAgJ2ZvcicsXG4gICAgJ2ZvcndoeScsXG4gICAgJ2Zvcm5lbnN0JyxcbiAgICAnZm9ybWVybHknLFxuICAgICdmb3JtZXInLFxuICAgICdmb3JtZXJlcicsXG4gICAgJ2Zvcm1lcmVzdCcsXG4gICAgJ2Zvcm1lcnMnLFxuICAgICdmb3JieWUnLFxuICAgICdmb3JieScsXG4gICAgJ2ZvcmUnLFxuICAgICdmb3JldmVyJyxcbiAgICAnZm9yZXInLFxuICAgICdmb3JlcycsXG4gICAgJ2ZvdXInLFxuICAgICdkJyxcbiAgICAnZGRheXMnLFxuICAgICdkZGF5JyxcbiAgICAnZG8nLFxuICAgICdkb2luZycsXG4gICAgJ2RvaW5ncycsXG4gICAgJ2RvZScsXG4gICAgJ2RvZXMnLFxuICAgICdkb3RoJyxcbiAgICAnZG93bndhcmRlcicsXG4gICAgJ2Rvd253YXJkZXN0JyxcbiAgICAnZG93bndhcmQnLFxuICAgICdkb3dud2FyZHMnLFxuICAgICdkb3ducycsXG4gICAgJ2RvbmUnLFxuICAgICdkb25lcicsXG4gICAgJ2RvbmVzJyxcbiAgICAnZG9uZXN0JyxcbiAgICAnZG9zJyxcbiAgICAnZG9zdCcsXG4gICAgJ2RpZCcsXG4gICAgJ2RpZmZlcmVudGVzdCcsXG4gICAgJ2RpZmZlcmVudGVyJyxcbiAgICAnZGlmZmVyZW50JyxcbiAgICAnZGVzY3JpYmluZycsXG4gICAgJ2Rlc2NyaWJlJyxcbiAgICAnZGVzY3JpYmVzJyxcbiAgICAnZGVzY3JpYmVkJyxcbiAgICAnZGVzcGl0aW5nJyxcbiAgICAnZGVzcGl0ZXMnLFxuICAgICdkZXNwaXRlZCcsXG4gICAgJ2Rlc3BpdGUnLFxuICAgICdkdXJpbmcnLFxuICAgICdjJyxcbiAgICAnY3VtJyxcbiAgICAnY2lyY2EnLFxuICAgICdjaGV6JyxcbiAgICAnY2VyJyxcbiAgICAnY2VydGFpbicsXG4gICAgJ2NlcnRhaW5lc3QnLFxuICAgICdjZXJ0YWluZXInLFxuICAgICdjZXN0JyxcbiAgICAnY2Fuc3QnLFxuICAgICdjYW5ub3QnLFxuICAgICdjYW50JyxcbiAgICAnY2FudHMnLFxuICAgICdjYW50aW5nJyxcbiAgICAnY2FudGVzdCcsXG4gICAgJ2NhbnRlZCcsXG4gICAgJ2NvJyxcbiAgICAnY291bGQnLFxuICAgICdjb3VsZHN0JyxcbiAgICAnY29tZW9uJyxcbiAgICAnY29tZW9ucycsXG4gICAgJ2NvbWUtb25zJyxcbiAgICAnY29tZS1vbicsXG4gICAgJ2NvbmNlcm5pbmcnLFxuICAgICdjb25jZXJuaW5nZXInLFxuICAgICdjb25jZXJuaW5nZXN0JyxcbiAgICAnY29uc2VxdWVudGx5JyxcbiAgICAnY29uc2lkZXJpbmcnLFxuICAgICdlJyxcbiAgICAnZWcnLFxuICAgICdlaWdodCcsXG4gICAgJ2VpdGhlcicsXG4gICAgJ2V2ZW4nLFxuICAgICdldmVucycsXG4gICAgJ2V2ZW5zZXInLFxuICAgICdldmVuc2VzdCcsXG4gICAgJ2V2ZW5lZCcsXG4gICAgJ2V2ZW5lc3QnLFxuICAgICdldmVyJyxcbiAgICAnZXZlcnlvbmUnLFxuICAgICdldmVyeXRoaW5nJyxcbiAgICAnZXZlcnlib2R5JyxcbiAgICAnZXZlcnl3aGVyZScsXG4gICAgJ2V2ZXJ5JyxcbiAgICAnZXJlJyxcbiAgICAnZWFjaCcsXG4gICAgJ2V0JyxcbiAgICAnZXRjJyxcbiAgICAnZWxzZXdoZXJlJyxcbiAgICAnZWxzZScsXG4gICAgJ2V4JyxcbiAgICAnZXhjZXB0ZWQnLFxuICAgICdleGNlcHRzJyxcbiAgICAnZXhjZXB0JyxcbiAgICAnZXhjZXB0aW5nJyxcbiAgICAnZXhlcycsXG4gICAgJ2Vub3VnaCcsXG4gICAgJ2F3YXknXG5dO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFVzZXJCeUlkID0gZXhwb3J0cy5nZXRVc2VyQnlFbWFpbCA9IGV4cG9ydHMuZ2V0VXNlcnMgPSBleHBvcnRzLnZhbGlkYXRlU2Vzc2lvbiA9IGV4cG9ydHMuZ2V0TmV3QWNjZXNzVG9rZW4gPSBleHBvcnRzLmRlY29kZUFjY2Vzc1Rva2VuID0gdm9pZCAwO1xudmFyIGF4aW9zID0gcmVxdWlyZShcImF4aW9zXCIpO1xudmFyIE9ORUFVVEhfQVBJID0gcHJvY2Vzcy5lbnYuT05FQVVUSF9BUEkgfHwgXCJodHRwOi8vbG9jYWxob3N0OjQwMTAvYXBpXCI7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIG1vZGVsXzIgPSByZXF1aXJlKFwiLi4vdXNlci9pbnZpdGUvbW9kZWxcIik7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgZGJ1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2xpYi9kYnV0aWxzXCIpO1xudmFyIGhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2F1dGgvaGVscGVyXCIpO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG52YXIgZGVjb2RlQWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAoc3BhY2UsIGFjY2Vzc1Rva2VuKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWNvZGVkUmVzcG9uc2UsIGVycl8xLCBtb2RlbCwgZXhpc3RpbmdVc2VyUmVjb3JkLCBkYXRhO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGRlY29kZWRSZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMSwgMywgLCA0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBheGlvcy5nZXQoXCJcIi5jb25jYXQoT05FQVVUSF9BUEksIFwiL2F1dGgvdG9rZW4vZGVjb2RlXCIpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbjogYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZGVjb2RlZFJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgZXJyXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycl8xLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgXCJleHBpcmVkXCJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIFwiZXhwaXJlZFwiXTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZiAoIShkZWNvZGVkUmVzcG9uc2Uuc3RhdHVzID09PSAyMDApKSByZXR1cm4gWzMsIDldO1xuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRHbG9iYWxDb2xsZWN0aW9uKShtb2RlbF8xLnVzZXJDb2xsZWN0aW9uLCBtb2RlbF8xLnVzZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogZGVjb2RlZFJlc3BvbnNlLmRhdGEuZW1haWwsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBleGlzdGluZ1VzZXJSZWNvcmQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShkZWNvZGVkUmVzcG9uc2UuZGF0YS51c2VyX2lkLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVjb2RlZFJlc3BvbnNlLmRhdGEpLCB7IHJlc29sdmVyOiBcIm9uZWF1dGhfc3BhY2VcIiB9KSwgeyBuZXc6IHRydWUsIHVwc2VydDogdHJ1ZSB9KV07XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIShleGlzdGluZ1VzZXJSZWNvcmQubGVuZ3RoID09PSAwKSkgcmV0dXJuIFszLCA4XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGF1dG9BY2NlcHRJbnZpdGVzKGRhdGEpXTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA4O1xuICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gWzIsIGRlY29kZWRSZXNwb25zZS5kYXRhIHx8IG51bGxdO1xuICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZGVjb2RlQWNjZXNzVG9rZW4gPSBkZWNvZGVBY2Nlc3NUb2tlbjtcbnZhciBhdXRvQWNjZXB0SW52aXRlcyA9IGZ1bmN0aW9uICh1c2VyKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgcGVuZGluZ0ludml0ZUxpc3QsIGksIHJlcztcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9ICgwLCBkYnV0aWxzXzEuZ2V0R2xvYmFsQ29sbGVjdGlvbikobW9kZWxfMi51c2VySW52aXRlQ29sbGVjdGlvbiwgbW9kZWxfMi51c2VySW52aXRlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmQoeyBlbWFpbDogdXNlci5lbWFpbCB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcGVuZGluZ0ludml0ZUxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocGVuZGluZ0ludml0ZUxpc3QpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgcGVuZGluZ0ludml0ZUxpc3QubGVuZ3RoKSkgcmV0dXJuIFszLCA1XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKHBlbmRpbmdJbnZpdGVMaXN0W2ldLl9pZCwgX19hc3NpZ24oX19hc3NpZ24oe30sIHBlbmRpbmdJbnZpdGVMaXN0W2ldLl9kb2MpLCB7IHVzZXJJZDogdXNlci5faWQsIGFjY2VwdGVkOiB0cnVlIH0pLCB7IG5ldzogdHJ1ZSwgdXBzZXJ0OiB0cnVlIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coX19hc3NpZ24oX19hc3NpZ24oe30sIHBlbmRpbmdJbnZpdGVMaXN0W2ldKSwgeyB1c2VySWQ6IHVzZXIuX2lkLCBhY2NlcHRlZDogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbnZhciBnZXROZXdBY2Nlc3NUb2tlbiA9IGZ1bmN0aW9uIChzcGFjZSwgcmVmcmVzaFRva2VuKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWZyZXNoVG9rZW5SZXNwb25zZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBheGlvcy5wb3N0KFwiXCIuY29uY2F0KE9ORUFVVEhfQVBJLCBcIi9hdXRoL3Rva2VuXCIpLCB7XG4gICAgICAgICAgICAgICAgICAgIGdyYW50X3R5cGU6IFwicmVmcmVzaF90b2tlblwiLFxuICAgICAgICAgICAgICAgICAgICByZWFsbTogc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2hfdG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuUmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZnJlc2hUb2tlblJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVmcmVzaFRva2VuUmVzcG9uc2UuZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXROZXdBY2Nlc3NUb2tlbiA9IGdldE5ld0FjY2Vzc1Rva2VuO1xudmFyIHZhbGlkYXRlU2Vzc2lvbiA9IGZ1bmN0aW9uIChsb2NhbEFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4sIGFwcFJlYWxtKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbCwgbG9jYWxUb2tlblJlc3BvbnNlLCBhY2Nlc3NUb2tlbiwgbG9jYWxDbGFpbXMsIF9hLCBfYWNjZXNzVG9rZW4sIF9sb2NhbENsYWltcywgYWNjZXNzVG9rZW5SZXNwb25zZSwgbmV3QWNjZXNzVG9rZW4sIG5ld0FjY2Vzc1Rva2VuUmVzcG9uc2U7XG4gICAgdmFyIF9iO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRHbG9iYWxDb2xsZWN0aW9uKShtb2RlbF8xLnVzZXJDb2xsZWN0aW9uLCBtb2RlbF8xLnVzZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgKDAsIGhlbHBlcl8xLmRlY29kZUFwcFRva2VuKShsb2NhbEFjY2Vzc1Rva2VuKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbG9jYWxUb2tlblJlc3BvbnNlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsb2NhbENsYWltcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxUb2tlblJlc3BvbnNlLm91dGNvbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2EgPSBsb2NhbFRva2VuUmVzcG9uc2UuY2xhaW1zLCBfYWNjZXNzVG9rZW4gPSBfYS5hY2Nlc3NUb2tlbiwgX2xvY2FsQ2xhaW1zID0gX19yZXN0KF9hLCBbXCJhY2Nlc3NUb2tlblwiXSk7XG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSBfYWNjZXNzVG9rZW47XG4gICAgICAgICAgICAgICAgbG9jYWxDbGFpbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlOiBfbG9jYWxDbGFpbXMuc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhbnlJZDogX2xvY2FsQ2xhaW1zLmNvbXBhbnlJZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgSGVscGVyLmRlY29kZUFjY2Vzc1Rva2VuKE51bWJlcihhcHBSZWFsbSksIGFjY2Vzc1Rva2VuKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgYWNjZXNzVG9rZW5SZXNwb25zZSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW5SZXNwb25zZSAhPT0gXCJleHBpcmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhaW1zOiBhY2Nlc3NUb2tlblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYWNlOiBsb2NhbENsYWltcy5zcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXROZXdBY2Nlc3NUb2tlbihhcHBSZWFsbSwgcmVmcmVzaFRva2VuKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbmV3QWNjZXNzVG9rZW4gPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKCEobmV3QWNjZXNzVG9rZW4gPT09IG51bGwgfHwgbmV3QWNjZXNzVG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld0FjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikpIHJldHVybiBbMywgNl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZGVjb2RlQWNjZXNzVG9rZW4oYXBwUmVhbG0sIG5ld0FjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbildO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG5ld0FjY2Vzc1Rva2VuUmVzcG9uc2UgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgX2IgPSB7fTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsICgwLCBzZXJ2aWNlXzEuZ2V0TG9jYWxUb2tlbkltcGwpKG5ld0FjY2Vzc1Rva2VuUmVzcG9uc2UudXNlcl9pZCwgbmV3QWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuKV07XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiwgKF9iLmFjY2Vzc1Rva2VuID0gX2Muc2VudCgpLFxuICAgICAgICAgICAgICAgICAgICBfYi5jbGFpbXMgPSBuZXdBY2Nlc3NUb2tlblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBfYi5zcGFjZSA9IGxvY2FsQ2xhaW1zLnNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBfYildO1xuICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudmFsaWRhdGVTZXNzaW9uID0gdmFsaWRhdGVTZXNzaW9uO1xudmFyIGdldFVzZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbW9kZWwgPSAoMCwgZGJ1dGlsc18xLmdldEdsb2JhbENvbGxlY3Rpb24pKG1vZGVsXzEudXNlckNvbGxlY3Rpb24sIG1vZGVsXzEudXNlclNjaGVtYSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kKCldO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRVc2VycyA9IGdldFVzZXJzO1xudmFyIGdldFVzZXJCeUVtYWlsID0gZnVuY3Rpb24gKGVtYWlsKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2RlbDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtb2RlbCA9ICgwLCBkYnV0aWxzXzEuZ2V0R2xvYmFsQ29sbGVjdGlvbikobW9kZWxfMS51c2VyQ29sbGVjdGlvbiwgbW9kZWxfMS51c2VyU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIG1vZGVsLmZpbmRPbmUoeyBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSB9KV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFVzZXJCeUVtYWlsID0gZ2V0VXNlckJ5RW1haWw7XG52YXIgZ2V0VXNlckJ5SWQgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRHbG9iYWxDb2xsZWN0aW9uKShtb2RlbF8xLnVzZXJDb2xsZWN0aW9uLCBtb2RlbF8xLnVzZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZEJ5SWQoaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0VXNlckJ5SWQgPSBnZXRVc2VyQnlJZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x2ZXJzID0gZXhwb3J0cy50eXBlRGVmcyA9IHZvaWQgMDtcbnZhciBhcG9sbG9fc2VydmVyX2V4cHJlc3NfMSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyLWV4cHJlc3NcIik7XG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xudmFyIEhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJcIikpO1xudmFyIGdldENvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vbGliL2RidXRpbHNcIikuZ2V0Q29sbGVjdGlvbjtcbnZhciB0eXBlRGVmcyA9ICgwLCBhcG9sbG9fc2VydmVyX2V4cHJlc3NfMS5ncWwpKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHR5cGUgUXVlcnkge1xcbiAgICB1c2VyOiBbVXNlcl1cXG4gICAgYXV0aG9yaXplVXNlcihcXG4gICAgICBhY2Nlc3NUb2tlbjogU3RyaW5nXFxuICAgICAgcmVmcmVzaFRva2VuOiBTdHJpbmdcXG4gICAgICBzcGFjZTogU3RyaW5nXFxuICAgICk6IEF1dGhvcml6ZVJlc3BvbnNlXFxuICB9XFxuXFxuICB0eXBlIE11dGF0aW9uIHtcXG4gICAgY3JlYXRlRW1haWxBY2NvdW50KHBheWxvYWQ6IFVzZXJQYXlsb2FkKTogVXNlciFcXG4gIH1cXG5cXG4gIGlucHV0IFVzZXJQYXlsb2FkIHtcXG4gICAgZmlyc3ROYW1lOiBTdHJpbmchXFxuICAgIGxhc3ROYW1lOiBTdHJpbmchXFxuICAgIGVtYWlsOiBTdHJpbmchXFxuICB9XFxuXFxuICB0eXBlIFVzZXIge1xcbiAgICBpZDogSUQhXFxuICAgIGdpdmVuX25hbWU6IFN0cmluZ1xcbiAgICBmYW1pbHlfbmFtZTogU3RyaW5nXFxuICAgIG5hbWU6IFN0cmluZ1xcbiAgICBuaWNrbmFtZTogU3RyaW5nXFxuICAgIGVtYWlsOiBTdHJpbmdcXG4gICAgcmVzb2x2ZXI6IFN0cmluZ1xcbiAgfVxcblxcbiAgdHlwZSBBdXRob3JpemVSZXNwb25zZSB7XFxuICAgIGFjY2Vzc1Rva2VuOiBTdHJpbmdcXG4gICAgY2xhaW1zOiBKU09OXFxuICB9XFxuXCJdLCBbXCJcXG4gIHR5cGUgUXVlcnkge1xcbiAgICB1c2VyOiBbVXNlcl1cXG4gICAgYXV0aG9yaXplVXNlcihcXG4gICAgICBhY2Nlc3NUb2tlbjogU3RyaW5nXFxuICAgICAgcmVmcmVzaFRva2VuOiBTdHJpbmdcXG4gICAgICBzcGFjZTogU3RyaW5nXFxuICAgICk6IEF1dGhvcml6ZVJlc3BvbnNlXFxuICB9XFxuXFxuICB0eXBlIE11dGF0aW9uIHtcXG4gICAgY3JlYXRlRW1haWxBY2NvdW50KHBheWxvYWQ6IFVzZXJQYXlsb2FkKTogVXNlciFcXG4gIH1cXG5cXG4gIGlucHV0IFVzZXJQYXlsb2FkIHtcXG4gICAgZmlyc3ROYW1lOiBTdHJpbmchXFxuICAgIGxhc3ROYW1lOiBTdHJpbmchXFxuICAgIGVtYWlsOiBTdHJpbmchXFxuICB9XFxuXFxuICB0eXBlIFVzZXIge1xcbiAgICBpZDogSUQhXFxuICAgIGdpdmVuX25hbWU6IFN0cmluZ1xcbiAgICBmYW1pbHlfbmFtZTogU3RyaW5nXFxuICAgIG5hbWU6IFN0cmluZ1xcbiAgICBuaWNrbmFtZTogU3RyaW5nXFxuICAgIGVtYWlsOiBTdHJpbmdcXG4gICAgcmVzb2x2ZXI6IFN0cmluZ1xcbiAgfVxcblxcbiAgdHlwZSBBdXRob3JpemVSZXNwb25zZSB7XFxuICAgIGFjY2Vzc1Rva2VuOiBTdHJpbmdcXG4gICAgY2xhaW1zOiBKU09OXFxuICB9XFxuXCJdKSkpO1xuZXhwb3J0cy50eXBlRGVmcyA9IHR5cGVEZWZzO1xudmFyIHJlc29sdmVycyA9IHtcbiAgICBRdWVyeToge1xuICAgICAgICB1c2VyOiBmdW5jdGlvbiAoXzEsIF9hLCBfYikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgW18xLCBfYSwgX2JdLCB2b2lkIDAsIGZ1bmN0aW9uIChfLCBfYywgX2QpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbDtcbiAgICAgICAgICAgIHZhciBlbWFpbCA9IF9jLmVtYWlsO1xuICAgICAgICAgICAgdmFyIHNwYWNlID0gX2Quc3BhY2UsIHVzZXIgPSBfZC51c2VyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzcGFjZSB8fCAhdXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbmV3IGFwb2xsb19zZXJ2ZXJfZXhwcmVzc18xLkF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsID0gZ2V0Q29sbGVjdGlvbihzcGFjZSwgbW9kZWxfMS51c2VyQ29sbGVjdGlvbiwgbW9kZWxfMS51c2VyU2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIsIF9lLnNlbnQoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9LFxuICAgICAgICBhdXRob3JpemVVc2VyOiBmdW5jdGlvbiAoXzEsIF9hLCBfXzEpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIFtfMSwgX2EsIF9fMV0sIHZvaWQgMCwgZnVuY3Rpb24gKF8sIF9iLCBfXykge1xuICAgICAgICAgICAgdmFyIG1vZGVsLCBhY2Nlc3NUb2tlblJlc3BvbnNlLCBuZXdBY2Nlc3NUb2tlbiwgbmV3QWNjZXNzVG9rZW5SZXNwb25zZTtcbiAgICAgICAgICAgIHZhciBhY2Nlc3NUb2tlbiA9IF9iLmFjY2Vzc1Rva2VuLCByZWZyZXNoVG9rZW4gPSBfYi5yZWZyZXNoVG9rZW4sIHNwYWNlID0gX2Iuc3BhY2U7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbCA9IGdldENvbGxlY3Rpb24oc3BhY2UsIG1vZGVsXzEudXNlckNvbGxlY3Rpb24sIG1vZGVsXzEudXNlclNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWNvZGVBY2Nlc3NUb2tlbihOdW1iZXIoc3BhY2UpLCBhY2Nlc3NUb2tlbildO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlblJlc3BvbnNlID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjY2Vzc1Rva2VuUmVzcG9uc2UgIT09IFwiZXhwaXJlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYWltczogYWNjZXNzVG9rZW5SZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5nZXROZXdBY2Nlc3NUb2tlbihzcGFjZSwgcmVmcmVzaFRva2VuKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FjY2Vzc1Rva2VuID0gX2Muc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV3QWNjZXNzVG9rZW4gPT09IG51bGwgfHwgbmV3QWNjZXNzVG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5ld0FjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbikpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIEhlbHBlci5kZWNvZGVBY2Nlc3NUb2tlbihzcGFjZSwgbmV3QWNjZXNzVG9rZW4uYWNjZXNzX3Rva2VuKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FjY2Vzc1Rva2VuUmVzcG9uc2UgPSBfYy5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IG5ld0FjY2Vzc1Rva2VuLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhaW1zOiBuZXdBY2Nlc3NUb2tlblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9LFxuICAgIH0sXG4gICAgTXV0YXRpb246IHtcbiAgICAgICAgY3JlYXRlRW1haWxBY2NvdW50OiBmdW5jdGlvbiAoXzEsIGFyZ3NfMSwgX2EpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIFtfMSwgYXJnc18xLCBfYV0sIHZvaWQgMCwgZnVuY3Rpb24gKF8sIGFyZ3MsIF9iKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwsIHJlc3BvbnNlO1xuICAgICAgICAgICAgdmFyIHNwYWNlID0gX2Iuc3BhY2UsIHVzZXIgPSBfYi51c2VyO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKHNwYWNlLCBtb2RlbF8xLnVzZXJDb2xsZWN0aW9uLCBtb2RlbF8xLnVzZXJTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5maW5kT25lQW5kVXBkYXRlKHsgZW1haWw6IGFyZ3MucGF5bG9hZC5lbWFpbCwgcmVzb2x2ZXI6IFwiZW1haWxcIiB9LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYXJncy5wYXlsb2FkKSwgeyByZXNvbHZlcjogXCJlbWFpbFwiIH0pLCB7IHVwc2VydDogdHJ1ZSwgbmV3OiB0cnVlLCByYXdSZXN1bHQ6IHRydWUgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9jLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzcG9uc2UudmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgfSxcbiAgICB9LFxufTtcbmV4cG9ydHMucmVzb2x2ZXJzID0gcmVzb2x2ZXJzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VXNlckludml0ZUJ5VXNlcklkID0gZXhwb3J0cy5yZWdpc3RlclVzZXJJbnZpdGUgPSBleHBvcnRzLmdldFVzZXJJbnZpdGUgPSBleHBvcnRzLnVwZGF0ZVVzZXJJbnZpdGUgPSB2b2lkIDA7XG52YXIgYXhpb3MgPSByZXF1aXJlKFwiYXhpb3NcIik7XG52YXIgT05FQVVUSF9BUEkgPSBwcm9jZXNzLmVudi5PTkVBVVRIX0FQSSB8fCBcImh0dHA6Ly9sb2NhbGhvc3Q6NDAxMC9hcGlcIjtcbnZhciBtb2RlbF8xID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG52YXIgY29tcGFueVNlcnZpY2UgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uLy4uL2NvbXBhbnkvc2VydmljZVwiKSk7XG52YXIgdXNlclNlcnZpY2UgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3NlcnZpY2VcIikpO1xudmFyIGRidXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZGJ1dGlsc1wiKTtcbnZhciB1cGRhdGVVc2VySW52aXRlID0gZnVuY3Rpb24gKHNwYWNlLCBkYXRhLCB1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbXBhbnksIG1vZGVsLCB1c2VyLCBwYXlsb2FkLCBleGlzdGluZ1JlY29yZDtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBjb21wYW55U2VydmljZS5nZXRDb21wYW55QnlSZWZlcmVuY2Uoc3BhY2UpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjb21wYW55ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghY29tcGFueSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIG51bGxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RlbCA9ICgwLCBkYnV0aWxzXzEuZ2V0R2xvYmFsQ29sbGVjdGlvbikobW9kZWxfMS51c2VySW52aXRlQ29sbGVjdGlvbiwgbW9kZWxfMS51c2VySW52aXRlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHVzZXJTZXJ2aWNlLmdldFVzZXJCeUVtYWlsKGRhdGEuZW1haWwpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB1c2VyID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHBheWxvYWQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgZW1haWw6IGRhdGEuZW1haWwudG9Mb3dlckNhc2UoKSwgY29tcGFueUlkOiBjb21wYW55Ll9pZCwgYWNjZXB0ZWQ6ICEhdXNlciwgdXNlcklkOiB1c2VyID8gdXNlci5faWQgOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogcGF5bG9hZC5lbWFpbC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFueUlkOiBjb21wYW55Ll9pZCxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGV4aXN0aW5nUmVjb3JkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICgoZXhpc3RpbmdSZWNvcmQgPT09IG51bGwgfHwgZXhpc3RpbmdSZWNvcmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4aXN0aW5nUmVjb3JkLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgbnVsbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuY3JlYXRlKHBheWxvYWQpXTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudXBkYXRlVXNlckludml0ZSA9IHVwZGF0ZVVzZXJJbnZpdGU7XG52YXIgZ2V0VXNlckludml0ZSA9IGZ1bmN0aW9uIChzcGFjZSkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29tcGFueSwgbW9kZWw7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgY29tcGFueVNlcnZpY2UuZ2V0Q29tcGFueUJ5UmVmZXJlbmNlKHNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY29tcGFueSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBbXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRHbG9iYWxDb2xsZWN0aW9uKShtb2RlbF8xLnVzZXJJbnZpdGVDb2xsZWN0aW9uLCBtb2RlbF8xLnVzZXJJbnZpdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IGNvbXBhbnlJZDogY29tcGFueS5faWQgfSldO1xuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIsIF9hLnNlbnQoKV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRVc2VySW52aXRlID0gZ2V0VXNlckludml0ZTtcbnZhciByZWdpc3RlclVzZXJJbnZpdGUgPSBmdW5jdGlvbiAoc3BhY2UsIGNvbXBhbnlJZCwgdXNlcklkLCBlbWFpbCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kZWwsIGV4aXN0aW5nUmVjb3JkO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRHbG9iYWxDb2xsZWN0aW9uKShtb2RlbF8xLnVzZXJJbnZpdGVDb2xsZWN0aW9uLCBtb2RlbF8xLnVzZXJJbnZpdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhbnlJZDogY29tcGFueUlkLFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdSZWNvcmQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKChleGlzdGluZ1JlY29yZCA9PT0gbnVsbCB8fCBleGlzdGluZ1JlY29yZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhpc3RpbmdSZWNvcmQubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBudWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBtb2RlbC5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFueUlkOiBjb21wYW55SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogZW1haWwudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJJZDogdXNlcklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMucmVnaXN0ZXJVc2VySW52aXRlID0gcmVnaXN0ZXJVc2VySW52aXRlO1xudmFyIGdldFVzZXJJbnZpdGVCeVVzZXJJZCA9IGZ1bmN0aW9uICh1c2VySWQpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1vZGVsO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1vZGVsID0gKDAsIGRidXRpbHNfMS5nZXRHbG9iYWxDb2xsZWN0aW9uKShtb2RlbF8xLnVzZXJJbnZpdGVDb2xsZWN0aW9uLCBtb2RlbF8xLnVzZXJJbnZpdGVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCwgbW9kZWwuZmluZCh7IHVzZXJJZDogdXNlcklkIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0VXNlckludml0ZUJ5VXNlcklkID0gZ2V0VXNlckludml0ZUJ5VXNlcklkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZXJJbnZpdGVDb2xsZWN0aW9uID0gZXhwb3J0cy51c2VySW52aXRlU2NoZW1hID0gdm9pZCAwO1xudmFyIG1vbmdvb3NlID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpO1xudmFyIFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbnZhciB1c2VySW52aXRlU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgZW1haWw6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdXNlcklkOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGNvbXBhbnlJZDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBhY2NlcHRlZDogeyB0eXBlOiBCb29sZWFuIH0sXG59LCB7IHRpbWVzdGFtcHM6IHRydWUgfSk7XG5leHBvcnRzLnVzZXJJbnZpdGVTY2hlbWEgPSB1c2VySW52aXRlU2NoZW1hO1xudmFyIHVzZXJJbnZpdGVDb2xsZWN0aW9uID0gXCJ1c2VyLnBlcm1pc3Npb25cIjtcbmV4cG9ydHMudXNlckludml0ZUNvbGxlY3Rpb24gPSB1c2VySW52aXRlQ29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1pZGRsZXdhcmVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vbWlkZGxld2FyZXNcIik7XG52YXIgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbnZhciBzZWxmUmVhbG0gPSAxMDA7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICByb3V0ZXIucG9zdChcIi91c2VyL2ludml0ZS86c3BhY2VcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksIHNlcnZpY2VfMS5jcmVhdGVVc2VySW52aXRlRW5kcG9pbnQpO1xuICAgIHJvdXRlci5nZXQoXCIvdXNlci9pbnZpdGUvOnNwYWNlXCIsIG1pZGRsZXdhcmVzXzEuYXV0aG9yaXplQXBpLCBzZXJ2aWNlXzEuZ2V0VXNlckludml0ZSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0VXNlckludml0ZSA9IGV4cG9ydHMucmVnaXN0ZXJVc2VySW52aXRlID0gZXhwb3J0cy5jcmVhdGVVc2VySW52aXRlRW5kcG9pbnQgPSB2b2lkIDA7XG52YXIgSGVscGVyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2hlbHBlclwiKSk7XG52YXIgc2VsZlJlYWxtID0gMTAwO1xudmFyIGNyZWF0ZVVzZXJJbnZpdGVFbmRwb2ludCA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdXNlcklkLCB1c2VySW52aXRlO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIudXBkYXRlVXNlckludml0ZShyZXEucGFyYW1zLnNwYWNlLCByZXEuYm9keSwgdXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdXNlckludml0ZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQodXNlckludml0ZSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5jcmVhdGVVc2VySW52aXRlRW5kcG9pbnQgPSBjcmVhdGVVc2VySW52aXRlRW5kcG9pbnQ7XG52YXIgcmVnaXN0ZXJVc2VySW52aXRlID0gZnVuY3Rpb24gKHNwYWNlLCBjb21wYW55SWQsIHVzZXJJZCwgZW1haWwpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgSGVscGVyLnJlZ2lzdGVyVXNlckludml0ZShzcGFjZSwgY29tcGFueUlkLCB1c2VySWQsIGVtYWlsKV07XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgX2Euc2VudCgpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnJlZ2lzdGVyVXNlckludml0ZSA9IHJlZ2lzdGVyVXNlckludml0ZTtcbnZhciBnZXRVc2VySW52aXRlID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHVzZXJJbnZpdGVMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0VXNlckludml0ZShyZXEucGFyYW1zLnNwYWNlKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdXNlckludml0ZUxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHVzZXJJbnZpdGVMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFVzZXJJbnZpdGUgPSBnZXRVc2VySW52aXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVzZXJDb2xsZWN0aW9uID0gZXhwb3J0cy51c2VyU2NoZW1hID0gdm9pZCAwO1xudmFyIG1vbmdvb3NlID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpO1xudmFyIFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbnZhciB1c2VyU2NoZW1hID0gbmV3IFNjaGVtYSh7XG4gICAgZ2l2ZW5fbmFtZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBmYW1pbHlfbmFtZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIG5pY2tuYW1lOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGVtYWlsOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHJlc29sdmVyOiB7IHR5cGU6IFN0cmluZyB9LFxufSwgeyB0aW1lc3RhbXBzOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VyU2NoZW1hID0gdXNlclNjaGVtYTtcbnZhciB1c2VyQ29sbGVjdGlvbiA9IFwidXNlclwiO1xuZXhwb3J0cy51c2VyQ29sbGVjdGlvbiA9IHVzZXJDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFuZGxlcl8xID0gcmVxdWlyZShcIi4uLy4uL2hhbmRsZXJcIik7XG52YXIgbWlkZGxld2FyZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9taWRkbGV3YXJlc1wiKTtcbnZhciBzZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlXCIpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgIHJvdXRlci5wb3N0KFwiL3VzZXIvOnJlYWxtSWQvYXV0aG9yaXplX3VzZXJcIiwgKDAsIGhhbmRsZXJfMS5hc3luY0hhbmRsZXIpKHNlcnZpY2VfMS52YWxpZGF0ZVNlc3Npb24pKTtcbiAgICByb3V0ZXIuZ2V0KFwiL3VzZXIvOnJlYWxtSWRcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGksICgwLCBoYW5kbGVyXzEuYXN5bmNIYW5kbGVyKShzZXJ2aWNlXzEuZ2V0VXNlcnMpKTtcbiAgICByb3V0ZXIuZ2V0KFwiL3VzZXIvdG9rZW4vbG9jYWxcIiwgbWlkZGxld2FyZXNfMS5hdXRob3JpemVBcGlPbmVhdXRoLCAoMCwgaGFuZGxlcl8xLmFzeW5jSGFuZGxlcikoc2VydmljZV8xLmdldExvY2FsVG9rZW4pKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVc2VyQnlJZCA9IGV4cG9ydHMuZ2V0VXNlckJ5RW1haWwgPSBleHBvcnRzLmdldExvY2FsVG9rZW5JbXBsID0gZXhwb3J0cy5nZXRMb2NhbFRva2VuID0gZXhwb3J0cy5nZXRVc2VycyA9IGV4cG9ydHMudmFsaWRhdGVTZXNzaW9uID0gdm9pZCAwO1xudmFyIEhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9oZWxwZXJcIikpO1xudmFyIHVzZXJJbnZpdGVIZWxwZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3VzZXIvaW52aXRlL2hlbHBlclwiKSk7XG52YXIgY29tcGFueUhlbHBlciA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vY29tcGFueS9oZWxwZXJcIikpO1xudmFyIGhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2F1dGgvaGVscGVyXCIpO1xudmFyIHNlbGZSZWFsbSA9IDEwMDtcbnZhciB2YWxpZGF0ZVNlc3Npb24gPSBmdW5jdGlvbiAocmVxLCByZXMpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlc3Npb247XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgSGVscGVyLnZhbGlkYXRlU2Vzc2lvbihyZXEuYm9keS5hY2Nlc3NUb2tlbiwgcmVxLmJvZHkucmVmcmVzaFRva2VuLCByZXEucGFyYW1zLnJlYWxtSWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDQwNCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5zZW5kKFwiU2Vzc2lvbiBub3QgZm91bmRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMudmFsaWRhdGVTZXNzaW9uID0gdmFsaWRhdGVTZXNzaW9uO1xudmFyIGdldFVzZXJzID0gZnVuY3Rpb24gKHJlcSwgcmVzKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySWQsIHVzZXJMaXN0O1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVzZXJJZCA9IHJlcS51c2VyLnVzZXJfaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBIZWxwZXIuZ2V0VXNlcnMoKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdXNlckxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmVzLnN0YXR1cygyMDApO1xuICAgICAgICAgICAgICAgIHJlcy5zZW5kKHVzZXJMaXN0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmdldFVzZXJzID0gZ2V0VXNlcnM7XG52YXIgZ2V0TG9jYWxUb2tlbiA9IGZ1bmN0aW9uIChyZXEsIHJlcykgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjZXNzVG9rZW4sIGFwcFRva2VuO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gcmVxLmhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdO1xuICAgICAgICAgICAgICAgIGlmICghYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXMuc2VuZFN0YXR1cyg0MDEpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0LCAoMCwgZXhwb3J0cy5nZXRMb2NhbFRva2VuSW1wbCkocmVxLnVzZXIudXNlcl9pZCwgYWNjZXNzVG9rZW4pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBhcHBUb2tlbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzKDIwMCk7XG4gICAgICAgICAgICAgICAgcmVzLnNlbmQoeyB0b2tlbjogYXBwVG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRMb2NhbFRva2VuID0gZ2V0TG9jYWxUb2tlbjtcbnZhciBnZXRMb2NhbFRva2VuSW1wbCA9IGZ1bmN0aW9uICh1c2VySWQsIGFjY2Vzc1Rva2VuKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB1c2VySW52aXRlTGlzdCwgY29tcGFueUlkTGlzdCwgY29tcGFueUxpc3QsIGNvbXBhbnlSZWZlcmVuY2VMaXN0LCBjbGFpbXM7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdXNlckludml0ZUhlbHBlci5nZXRVc2VySW52aXRlQnlVc2VySWQodXNlcklkKV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdXNlckludml0ZUxpc3QgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgY29tcGFueUlkTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIHVzZXJJbnZpdGVMaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFueUlkTGlzdC5wdXNoKGl0ZW0uY29tcGFueUlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGNvbXBhbnlIZWxwZXIuZ2V0Q29tcGFueUJ5SWRMaXN0KGNvbXBhbnlJZExpc3QpXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjb21wYW55TGlzdCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBjb21wYW55UmVmZXJlbmNlTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbXBhbnlMaXN0LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGFueVJlZmVyZW5jZUxpc3QucHVzaChpdGVtLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xhaW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHNwYWNlOiBjb21wYW55UmVmZXJlbmNlTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgY29tcGFueUlkOiBjb21wYW55SWRMaXN0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCAoMCwgaGVscGVyXzEuZW5jb2RlQXBwVG9rZW4pKGNsYWltcyldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0TG9jYWxUb2tlbkltcGwgPSBnZXRMb2NhbFRva2VuSW1wbDtcbnZhciBnZXRVc2VyQnlFbWFpbCA9IGZ1bmN0aW9uIChlbWFpbCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBIZWxwZXIuZ2V0VXNlckJ5RW1haWwoZW1haWwpXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0VXNlckJ5RW1haWwgPSBnZXRVc2VyQnlFbWFpbDtcbnZhciBnZXRVc2VyQnlJZCA9IGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCBIZWxwZXIuZ2V0VXNlckJ5SWQoaWQpXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyLCBfYS5zZW50KCldO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0VXNlckJ5SWQgPSBnZXRVc2VyQnlJZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIGV4cHJlc3MgPSByZXF1aXJlKFwiZXhwcmVzc1wiKTtcbnZhciByb3V0ZXIgPSBleHByZXNzLlJvdXRlcigpO1xucm91dGVyLmdldChcIi9cIiwgZnVuY3Rpb24gKF8sIHJlcykge1xuICAgIHJlcy5zZW5kKFwidjEuMC4wXCIpO1xuICAgIHJlcy5lbmQoKTtcbn0pO1xucmVxdWlyZShcIi4vbW9kdWxlcy9oZWxsby9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9hdXRoL3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL25vdGUvcm91dGVcIikocm91dGVyKTtcbnJlcXVpcmUoXCIuL21vZHVsZXMvbm90ZS90YWcvcm91dGVcIikocm91dGVyKTtcbnJlcXVpcmUoXCIuL21vZHVsZXMvdXNlci9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy91c2VyL2ludml0ZS9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9jb21wYW55L3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL25vdGVsaW5rL3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL25vdGVsaW5rL2F1dG8vcm91dGVcIikocm91dGVyKTtcbnJlcXVpcmUoXCIuL21vZHVsZXMvYm9vay9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9ib29rL2NoYXB0ZXIvcm91dGVcIikocm91dGVyKTtcbnJlcXVpcmUoXCIuL21vZHVsZXMvYm9vay9zZWN0aW9uL3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL2Jvb2svc2VjdGlvbmRldGFpbC9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9ib29rL2NvbmNlcHQvcm91dGVcIikocm91dGVyKTtcbnJlcXVpcmUoXCIuL21vZHVsZXMvYm9vay9jb25jZXB0ZGV0YWlsL3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL2Jvb2svdGhlbWUvcm91dGVcIikocm91dGVyKTtcbnJlcXVpcmUoXCIuL21vZHVsZXMvYm9vay90aGVtZWRldGFpbC9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9ib29rL3N1YnRoZW1lL3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL2Jvb2svc2hvcnRmb3JtL3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL2Jvb2svZXh0cmFjdC9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9ib29rL2xvZy9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9pbXBvcnQvcm91dGVcIikocm91dGVyKTtcbnJlcXVpcmUoXCIuL21vZHVsZXMvaW1wb3J0L2xvZy9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9jb2xvcmZpbHRlci9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9tZXRhZGF0YS9kZWZpbml0aW9uL3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL21ldGFkYXRhL3ZhbHVlL3JvdXRlXCIpKHJvdXRlcik7XG5yZXF1aXJlKFwiLi9tb2R1bGVzL3N0b3B3b3Jkcy9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9rZXl3b3Jkcy9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9sYWJlbC9yb3V0ZVwiKShyb3V0ZXIpO1xucmVxdWlyZShcIi4vbW9kdWxlcy9yZXBvcnQvcm91dGVcIikocm91dGVyKTtcbnJlcXVpcmUoXCIuL21vZHVsZXMvZmxhc2hjYXJkL3JvdXRlXCIpKHJvdXRlcik7XG5tb2R1bGUuZXhwb3J0cyA9IHJvdXRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbml0aWFsaXplU2VxdWVuY2VzID0gdm9pZCAwO1xudmFyIHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc2VxdWVuY2Uvc2VydmljZVwiKTtcbnZhciBpbml0aWFsaXplU2VxdWVuY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICgwLCBzZXJ2aWNlXzEuY3JlYXRlX3NlcXVlbmNlKShcImFzc2V0SWRcIiwgbnVsbCwgMSk7XG4gICAgKDAsIHNlcnZpY2VfMS5jcmVhdGVfc2VxdWVuY2UpKFwiY29tcGFueUlkXCIsIG51bGwsIDEpO1xufTtcbmV4cG9ydHMuaW5pdGlhbGl6ZVNlcXVlbmNlcyA9IGluaXRpYWxpemVTZXF1ZW5jZXM7XG4iLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG4vKipcbiAqIEBwYXJhbSB7KHN0cmluZyB8IG51bWJlcilbXX0gdXBkYXRlZE1vZHVsZXMgdXBkYXRlZCBtb2R1bGVzXG4gKiBAcGFyYW0geyhzdHJpbmcgfCBudW1iZXIpW10gfCBudWxsfSByZW5ld2VkTW9kdWxlcyByZW5ld2VkIG1vZHVsZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXBkYXRlZE1vZHVsZXMsIHJlbmV3ZWRNb2R1bGVzKSB7XG5cdHZhciB1bmFjY2VwdGVkTW9kdWxlcyA9IHVwZGF0ZWRNb2R1bGVzLmZpbHRlcihmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRyZXR1cm4gcmVuZXdlZE1vZHVsZXMgJiYgcmVuZXdlZE1vZHVsZXMuaW5kZXhPZihtb2R1bGVJZCkgPCAwO1xuXHR9KTtcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcblxuXHRpZiAodW5hY2NlcHRlZE1vZHVsZXMubGVuZ3RoID4gMCkge1xuXHRcdGxvZyhcblx0XHRcdFwid2FybmluZ1wiLFxuXHRcdFx0XCJbSE1SXSBUaGUgZm9sbG93aW5nIG1vZHVsZXMgY291bGRuJ3QgYmUgaG90IHVwZGF0ZWQ6IChUaGV5IHdvdWxkIG5lZWQgYSBmdWxsIHJlbG9hZCEpXCJcblx0XHQpO1xuXHRcdHVuYWNjZXB0ZWRNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG5cdFx0XHRsb2coXCJ3YXJuaW5nXCIsIFwiW0hNUl0gIC0gXCIgKyBtb2R1bGVJZCk7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIXJlbmV3ZWRNb2R1bGVzIHx8IHJlbmV3ZWRNb2R1bGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSBOb3RoaW5nIGhvdCB1cGRhdGVkLlwiKTtcblx0fSBlbHNlIHtcblx0XHRsb2coXCJpbmZvXCIsIFwiW0hNUl0gVXBkYXRlZCBtb2R1bGVzOlwiKTtcblx0XHRyZW5ld2VkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0aWYgKHR5cGVvZiBtb2R1bGVJZCA9PT0gXCJzdHJpbmdcIiAmJiBtb2R1bGVJZC5pbmRleE9mKFwiIVwiKSAhPT0gLTEpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gbW9kdWxlSWQuc3BsaXQoXCIhXCIpO1xuXHRcdFx0XHRsb2cuZ3JvdXBDb2xsYXBzZWQoXCJpbmZvXCIsIFwiW0hNUl0gIC0gXCIgKyBwYXJ0cy5wb3AoKSk7XG5cdFx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcblx0XHRcdFx0bG9nLmdyb3VwRW5kKFwiaW5mb1wiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxvZyhcImluZm9cIiwgXCJbSE1SXSAgLSBcIiArIG1vZHVsZUlkKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHR2YXIgbnVtYmVySWRzID0gcmVuZXdlZE1vZHVsZXMuZXZlcnkoZnVuY3Rpb24gKG1vZHVsZUlkKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIG1vZHVsZUlkID09PSBcIm51bWJlclwiO1xuXHRcdH0pO1xuXHRcdGlmIChudW1iZXJJZHMpXG5cdFx0XHRsb2coXG5cdFx0XHRcdFwiaW5mb1wiLFxuXHRcdFx0XHQnW0hNUl0gQ29uc2lkZXIgdXNpbmcgdGhlIG9wdGltaXphdGlvbi5tb2R1bGVJZHM6IFwibmFtZWRcIiBmb3IgbW9kdWxlIG5hbWVzLidcblx0XHRcdCk7XG5cdH1cbn07XG4iLCIvKiogQHR5cGVkZWYge1wiaW5mb1wiIHwgXCJ3YXJuaW5nXCIgfCBcImVycm9yXCJ9IExvZ0xldmVsICovXG5cbi8qKiBAdHlwZSB7TG9nTGV2ZWx9ICovXG52YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gZHVtbXkoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7TG9nTGV2ZWx9IGxldmVsIGxvZyBsZXZlbFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUsIGlmIHNob3VsZCBsb2dcbiAqL1xuZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsKSB7XG5cdHZhciBzaG91bGRMb2cgPVxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCIpO1xuXHRyZXR1cm4gc2hvdWxkTG9nO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KG1zZz86IHN0cmluZykgPT4gdm9pZH0gbG9nRm4gbG9nIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7KGxldmVsOiBMb2dMZXZlbCwgbXNnPzogc3RyaW5nKSA9PiB2b2lkfSBmdW5jdGlvbiB0aGF0IGxvZ3Mgd2hlbiBsb2cgbGV2ZWwgaXMgc3VmZmljaWVudFxuICovXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGxldmVsLCBtc2cpIHtcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0bG9nRm4obXNnKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtMb2dMZXZlbH0gbGV2ZWwgbG9nIGxldmVsXG4gKiBAcGFyYW0ge3N0cmluZ3xFcnJvcn0gbXNnIG1lc3NhZ2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGV2ZWwsIG1zZykge1xuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdGlmIChsZXZlbCA9PT0gXCJpbmZvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcblx0XHRcdGNvbnNvbGUud2Fybihtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIGdyb3VwID0gY29uc29sZS5ncm91cCB8fCBkdW1teTtcbnZhciBncm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgfHwgZHVtbXk7XG52YXIgZ3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kIHx8IGR1bW15O1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG4vKipcbiAqIEBwYXJhbSB7TG9nTGV2ZWx9IGxldmVsIGxvZyBsZXZlbFxuICovXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuXHRsb2dMZXZlbCA9IGxldmVsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgZXJyb3JcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGZvcm1hdHRlZCBlcnJvclxuICovXG5tb2R1bGUuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0dmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcblx0dmFyIHN0YWNrID0gZXJyLnN0YWNrO1xuXHRpZiAoIXN0YWNrKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdH0gZWxzZSBpZiAoc3RhY2suaW5kZXhPZihtZXNzYWdlKSA8IDApIHtcblx0XHRyZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcblx0fVxuXHRyZXR1cm4gc3RhY2s7XG59O1xuIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8qIGdsb2JhbHMgX19yZXNvdXJjZVF1ZXJ5ICovXG5pZiAobW9kdWxlLmhvdCkge1xuXHR2YXIgaG90UG9sbEludGVydmFsID0gK19fcmVzb3VyY2VRdWVyeS5zbGljZSgxKSB8fCAxMCAqIDYwICogMTAwMDtcblx0dmFyIGxvZyA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtib29sZWFuPX0gZnJvbVVwZGF0ZSB0cnVlIHdoZW4gY2FsbGVkIGZyb20gdXBkYXRlXG5cdCAqL1xuXHR2YXIgY2hlY2tGb3JVcGRhdGUgPSBmdW5jdGlvbiBjaGVja0ZvclVwZGF0ZShmcm9tVXBkYXRlKSB7XG5cdFx0aWYgKG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09IFwiaWRsZVwiKSB7XG5cdFx0XHRtb2R1bGUuaG90XG5cdFx0XHRcdC5jaGVjayh0cnVlKVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAodXBkYXRlZE1vZHVsZXMpIHtcblx0XHRcdFx0XHRpZiAoIXVwZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRcdFx0XHRpZiAoZnJvbVVwZGF0ZSkgbG9nKFwiaW5mb1wiLCBcIltITVJdIFVwZGF0ZSBhcHBsaWVkLlwiKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVxdWlyZShcIi4vbG9nLWFwcGx5LXJlc3VsdFwiKSh1cGRhdGVkTW9kdWxlcywgdXBkYXRlZE1vZHVsZXMpO1xuXHRcdFx0XHRcdGNoZWNrRm9yVXBkYXRlKHRydWUpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuXHRcdFx0XHRcdHZhciBzdGF0dXMgPSBtb2R1bGUuaG90LnN0YXR1cygpO1xuXHRcdFx0XHRcdGlmIChbXCJhYm9ydFwiLCBcImZhaWxcIl0uaW5kZXhPZihzdGF0dXMpID49IDApIHtcblx0XHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBDYW5ub3QgYXBwbHkgdXBkYXRlLlwiKTtcblx0XHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBcIiArIGxvZy5mb3JtYXRFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBZb3UgbmVlZCB0byByZXN0YXJ0IHRoZSBhcHBsaWNhdGlvbiFcIik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxvZyhcIndhcm5pbmdcIiwgXCJbSE1SXSBVcGRhdGUgZmFpbGVkOiBcIiArIGxvZy5mb3JtYXRFcnJvcihlcnIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblx0c2V0SW50ZXJ2YWwoY2hlY2tGb3JVcGRhdGUsIGhvdFBvbGxJbnRlcnZhbCk7XG59IGVsc2Uge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJbSE1SXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGlzIGRpc2FibGVkLlwiKTtcbn1cbiIsImNvbnN0IHsgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcblxuY29uc3QgaXNVbmF1dGhvcml6ZWQgPSAodXNlcikgPT4ge1xuICBpZiAoIXVzZXIpIHtcbiAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBpc1VuYXV0aG9yaXplZCB9O1xuIiwiY29uc3QgeyBncWwsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyLWV4cHJlc3NcIik7XG5jb25zdCB7IGNhdGVnb3J5Q29sbGVjdGlvbiwgY2F0ZWdvcnlTY2hlbWEgfSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuY29uc3QgeyBnZXRDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIik7XG5jb25zdCB7IGlzVW5hdXRob3JpemVkIH0gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2F1dGh1dGlsc1wiKTtcblxuY29uc3QgdHlwZURlZnMgPSBncWxgXG4gIGV4dGVuZCB0eXBlIFF1ZXJ5IHtcbiAgICBhcnRpY2xlQ2F0ZWdvcnkoaWQ6IElEISk6IEFydGljbGVDYXRlZ29yeVxuICAgIGFydGljbGVDYXRlZ29yaWVzOiBbQXJ0aWNsZUNhdGVnb3J5XVxuICB9XG5cbiAgZXh0ZW5kIHR5cGUgTXV0YXRpb24ge1xuICAgIGFkZEFydGljbGVDYXRlZ29yeShwYXlsb2FkOiBBcnRpY2xlQ2F0ZWdvcnlQYXlsb2FkKTogQXJ0aWNsZUNhdGVnb3J5XG4gIH1cblxuICBpbnB1dCBBcnRpY2xlQ2F0ZWdvcnlQYXlsb2FkIHtcbiAgICBpZDogU3RyaW5nXG4gICAgbmFtZTogU3RyaW5nXG4gIH1cblxuICBleHRlbmQgdHlwZSBBcnRpY2xlIHtcbiAgICBjYXRlZ29yeTogQXJ0aWNsZUNhdGVnb3J5XG4gIH1cblxuICB0eXBlIEFydGljbGVDYXRlZ29yeSB7XG4gICAgaWQ6IElEIVxuICAgIG5hbWU6IFN0cmluZ1xuICAgIGFydGljbGVzOiBJbnRcbiAgfVxuYDtcblxuY29uc3QgcmVzb2x2ZXJzID0ge1xuICBRdWVyeToge1xuICAgIGFydGljbGVDYXRlZ29yeTogYXN5bmMgKF8sIHsgaWQgfSwgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIGNhdGVnb3J5Q29sbGVjdGlvbiwgY2F0ZWdvcnlTY2hlbWEpO1xuICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmRCeUlkKGlkKTtcbiAgICB9LFxuICAgIGFydGljbGVDYXRlZ29yaWVzOiBhc3luYyAoXywgX18sIHsgdXNlciwgYXNzZXQgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBjYXRlZ29yeUNvbGxlY3Rpb24sIGNhdGVnb3J5U2NoZW1hKTtcbiAgICAgIHJldHVybiBhd2FpdCBtb2RlbC5maW5kKCk7XG4gICAgfSxcbiAgfSxcblxuICBNdXRhdGlvbjoge1xuICAgIGFkZEFydGljbGVDYXRlZ29yeTogYXN5bmMgKF8sIGFyZ3MsIHsgdXNlciwgYXNzZXQgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBjYXRlZ29yeUNvbGxlY3Rpb24sIGNhdGVnb3J5U2NoZW1hKTtcbiAgICAgIGlmIChhcmdzLnBheWxvYWQuaWQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKGFyZ3MucGF5bG9hZC5pZCwgYXJncy5wYXlsb2FkLCB7XG4gICAgICAgICAgbmV3OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgbW9kZWwoYXJncy5wYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRhdGEuc2F2ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG5cbiAgQXJ0aWNsZToge1xuICAgIGNhdGVnb3J5OiB7XG4gICAgICByZXNvbHZlOiBhc3luYyAocGFyZW50LCBfYXJncywgeyBhc3NldCwgdXNlciB9LCBpbmZvKSA9PiB7XG4gICAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgICBcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBjYXRlZ29yeUNvbGxlY3Rpb24sIGNhdGVnb3J5U2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmRCeUlkKHBhcmVudC5jYXRlZ29yeUlkKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0eXBlRGVmcywgcmVzb2x2ZXJzIH07XG4iLCJ2YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG5cbmNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbmNvbnN0IGNhdGVnb3J5U2NoZW1hID0gbmV3IFNjaGVtYShcbiAge1xuICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgLy8gcGFyZW50Q2F0ZWdvcnlJZDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBhcnRpY2xlczogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDAgfSxcbiAgfSxcbiAgeyB0aW1lc3RhbXBzOiB0cnVlIH1cbik7XG5cbmNvbnN0IGNhdGVnb3J5Q29sbGVjdGlvbiA9IFwiYXJ0aWNsZS5jYXRlZ29yeVwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgY2F0ZWdvcnlTY2hlbWEsIGNhdGVnb3J5Q29sbGVjdGlvbiB9O1xuIiwiY29uc3QgeyBncWwsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyLWV4cHJlc3NcIik7XG5jb25zdCB7XG4gIGFydGljbGVDb21tZW50RmVlZGJhY2tTY2hlbWEsXG4gIGFydGljbGVDb21tZW50RmVlZGJhY2tDb2xsZWN0aW9uLFxufSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuY29uc3QgeyBhcnRpY2xlQ29tbWVudFNjaGVtYSwgYXJ0aWNsZUNvbW1lbnRDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vbW9kZWxcIik7XG5jb25zdCB7IGdldENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9saWIvZGJ1dGlsc1wiKTtcblxuY29uc3QgdHlwZURlZnMgPSBncWxgXG4gIGV4dGVuZCB0eXBlIFF1ZXJ5IHtcbiAgICBhcnRpY2xlQ29tbWVudEZlZWRiYWNrKGNvbW1lbnRJZDogSUQhKTogW0FydGljbGVDb21tZW50RmVlZGJhY2tdXG4gIH1cblxuICBleHRlbmQgdHlwZSBNdXRhdGlvbiB7XG4gICAgYWRkQXJ0aWNsZUNvbW1lbnRGZWVkYmFjayhcbiAgICAgIGNvbW1lbnRJZDogU3RyaW5nIVxuICAgICAgdHlwZTogU3RyaW5nIVxuICAgICk6IEFydGljbGVDb21tZW50RmVlZGJhY2tcbiAgICByZW1vdmVBcnRpY2xlQ29tbWVudEZlZWRiYWNrKFxuICAgICAgY29tbWVudElkOiBTdHJpbmchXG4gICAgICB0eXBlOiBTdHJpbmchXG4gICAgKTogQXJ0aWNsZUNvbW1lbnRGZWVkYmFja1xuICB9XG5cbiAgdHlwZSBBcnRpY2xlQ29tbWVudEZlZWRiYWNrIHtcbiAgICBpZDogSUQhXG4gICAgdHlwZTogU3RyaW5nXG4gIH1cblxuICBleHRlbmQgdHlwZSBBcnRpY2xlQ29tbWVudCB7XG4gICAgZmVlZGJhY2s6IFtBcnRpY2xlQ29tbWVudEZlZWRiYWNrXVxuICB9XG5gO1xuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gIFF1ZXJ5OiB7XG4gICAgYXJ0aWNsZUNvbW1lbnRGZWVkYmFjazogYXN5bmMgKF8sIHsgY29tbWVudElkIH0sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja0NvbGxlY3Rpb24sXG4gICAgICAgIGFydGljbGVDb21tZW50RmVlZGJhY2tTY2hlbWFcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZCh7IGNvbW1lbnRJZDogY29tbWVudElkLCB1c2VySWQ6IHVzZXIudXNlcklkIH0pO1xuICAgIH0sXG4gIH0sXG5cbiAgQXJ0aWNsZUNvbW1lbnQ6IHtcbiAgICBmZWVkYmFjazoge1xuICAgICAgcmVzb2x2ZTogYXN5bmMgKHBhcmVudCwgX2FyZ3MsIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgICAgXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgICBhc3NldCxcbiAgICAgICAgICBhcnRpY2xlQ29tbWVudEZlZWRiYWNrQ29sbGVjdGlvbixcbiAgICAgICAgICBhcnRpY2xlQ29tbWVudEZlZWRiYWNrU2NoZW1hXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhd2FpdCBtb2RlbC5maW5kKHsgY29tbWVudElkOiBwYXJlbnQuaWQsIHVzZXJJZDogdXNlci51c2VySWQgfSk7XG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG5cbiAgTXV0YXRpb246IHtcbiAgICBhZGRBcnRpY2xlQ29tbWVudEZlZWRiYWNrOiBhc3luYyAoXywgYXJncywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhcnRpY2xlQ29tbWVudEZlZWRiYWNrQ29sbGVjdGlvbixcbiAgICAgICAgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja1NjaGVtYVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZmluZE9uZUFuZFVwZGF0ZShcbiAgICAgICAgeyBjb21tZW50SWQ6IGFyZ3MuY29tbWVudElkLCB1c2VySWQ6IHVzZXIudXNlcklkLCB0eXBlOiBhcmdzLnR5cGUgfSxcbiAgICAgICAgeyBjb21tZW50SWQ6IGFyZ3MuY29tbWVudElkLCB1c2VySWQ6IHVzZXIudXNlcklkLCB0eXBlOiBhcmdzLnR5cGUgfSxcbiAgICAgICAgeyB1cHNlcnQ6IHRydWUsIG5ldzogdHJ1ZSwgcmF3UmVzdWx0OiB0cnVlIH1cbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3BvbnNlLmxhc3RFcnJvck9iamVjdC51cGRhdGVkRXhpc3RpbmcpIHtcbiAgICAgICAgY29uc3QgYXJ0aWNsZUNvbW1lbnRNb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgYXJ0aWNsZUNvbW1lbnRDb2xsZWN0aW9uLFxuICAgICAgICAgIGFydGljbGVDb21tZW50U2NoZW1hXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IGFydGljbGVDb21tZW50TW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgICAgYXJncy5jb21tZW50SWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgJGluYzogeyBbYXJncy50eXBlXTogMSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnZhbHVlO1xuICAgIH0sXG4gICAgcmVtb3ZlQXJ0aWNsZUNvbW1lbnRGZWVkYmFjazogYXN5bmMgKF8sIGFyZ3MsIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja0NvbGxlY3Rpb24sXG4gICAgICAgIGFydGljbGVDb21tZW50RmVlZGJhY2tTY2hlbWFcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsLmZpbmRPbmVBbmREZWxldGUoXG4gICAgICAgIHsgY29tbWVudElkOiBhcmdzLmNvbW1lbnRJZCwgdXNlcklkOiB1c2VyLnVzZXJJZCwgdHlwZTogYXJncy50eXBlIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByYXdSZXN1bHQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2UubGFzdEVycm9yT2JqZWN0Lm4gPiAwKSB7XG4gICAgICAgIGNvbnN0IGFydGljbGVDb21tZW50TW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgIGFydGljbGVDb21tZW50Q29sbGVjdGlvbixcbiAgICAgICAgICBhcnRpY2xlQ29tbWVudFNjaGVtYVxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBhcnRpY2xlQ29tbWVudE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICAgIGFyZ3MuY29tbWVudElkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICRpbmM6IHsgW2FyZ3MudHlwZV06IC0xIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG5ldzogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UudmFsdWU7XG4gICAgfSxcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0eXBlRGVmcywgcmVzb2x2ZXJzIH07XG4iLCJ2YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG5cbmNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbmNvbnN0IGFydGljbGVDb21tZW50RmVlZGJhY2tTY2hlbWEgPSBuZXcgU2NoZW1hKFxuICB7XG4gICAgY29tbWVudElkOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHR5cGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdXNlcklkOiB7IHR5cGU6IFN0cmluZyB9LFxuICB9LFxuICB7IHRpbWVzdGFtcHM6IHRydWUgfVxuKTtcblxuY29uc3QgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja0NvbGxlY3Rpb24gPSBcImFydGljbGUuY29tbWVudC5mZWVkYmFja1wiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja1NjaGVtYSxcbiAgYXJ0aWNsZUNvbW1lbnRGZWVkYmFja0NvbGxlY3Rpb24sXG59O1xuIiwiY29uc3QgeyBncWwsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyLWV4cHJlc3NcIik7XG5jb25zdCB7IGFydGljbGVDb21tZW50U2NoZW1hLCBhcnRpY2xlQ29tbWVudENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuY29uc3QgeyBhcnRpY2xlU2NoZW1hLCBhcnRpY2xlQ29sbGVjdGlvbiB9ID0gcmVxdWlyZShcIi4uL21vZGVsXCIpO1xuY29uc3QgeyBnZXRDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIik7XG5cbmNvbnN0IHR5cGVEZWZzID0gZ3FsYFxuICBleHRlbmQgdHlwZSBRdWVyeSB7XG4gICAgYXJ0aWNsZUNvbW1lbnRzKFxuICAgICAgYXJ0aWNsZUlkOiBTdHJpbmchXG4gICAgICBwYWdlU2l6ZTogSW50XG4gICAgICBwYWdlTm86IEludFxuICAgICk6IEFydGljbGVDb21tZW50UGFnaW5hdGVkXG4gICAgYXJ0aWNsZUNvbW1lbnQoaWQ6IElEISk6IEFydGljbGVDb21tZW50XG4gIH1cblxuICBleHRlbmQgdHlwZSBNdXRhdGlvbiB7XG4gICAgdXBkYXRlQXJ0aWNsZUNvbW1lbnQocGF5bG9hZDogQXJ0aWNsZUNvbW1lbnRQYXlsb2FkISk6IEFydGljbGVDb21tZW50XG4gICAgbWFya0FydGljbGVDb21tZW50QXNBbnN3ZXIoaWQ6IElEISk6IEFydGljbGVDb21tZW50XG4gICAgdW5tYXJrQXJ0aWNsZUNvbW1lbnRBc0Fuc3dlcihpZDogSUQhKTogQXJ0aWNsZUNvbW1lbnRcbiAgfVxuXG4gIHR5cGUgQXJ0aWNsZUNvbW1lbnRQYWdpbmF0ZWQge1xuICAgIHBhZ2VObzogSW50XG4gICAgaGFzTW9yZTogQm9vbGVhblxuICAgIHRvdGFsOiBJbnRcbiAgICByZXN1bHRzOiBbQXJ0aWNsZUNvbW1lbnRdIVxuICB9XG5cbiAgaW5wdXQgQXJ0aWNsZUNvbW1lbnRQYXlsb2FkIHtcbiAgICBpZDogSURcbiAgICB0ZXh0OiBTdHJpbmdcbiAgICBwYXJlbnRJZDogU3RyaW5nXG4gICAgYXJ0aWNsZUlkOiBTdHJpbmchXG4gIH1cblxuICB0eXBlIEFydGljbGVDb21tZW50IHtcbiAgICBpZDogSUQhXG4gICAgdGV4dDogU3RyaW5nXG4gICAgcGFyZW50SWQ6IFN0cmluZ1xuICAgIGhlbHBmdWw6IEludFxuICAgIG5vdEhlbHBmdWw6IEludFxuICAgIGlzQW5zd2VyOiBCb29sZWFuXG4gICAgY3JlYXRlZEJ5OiBTdHJpbmdcbiAgICB1cGRhdGVkQnk6IFN0cmluZ1xuICAgIGNyZWF0ZWRBdDogRGF0ZVNjYWxhclxuICAgIHVwZGF0ZWRBdDogRGF0ZVNjYWxhclxuICB9XG5cbiAgZXh0ZW5kIHR5cGUgQXJ0aWNsZUNvbW1lbnRGZWVkYmFjayB7XG4gICAgYXJ0aWNsZUNvbW1lbnQ6IEFydGljbGVDb21tZW50XG4gIH1cbmA7XG5cbmNvbnN0IHJlc29sdmVycyA9IHtcbiAgUXVlcnk6IHtcbiAgICBhcnRpY2xlQ29tbWVudHM6IGFzeW5jIChcbiAgICAgIF8sXG4gICAgICB7IGFydGljbGVJZCwgcGFnZVNpemUgPSAwLCBwYWdlTm8gPSAwIH0sXG4gICAgICB7IGFzc2V0LCB1c2VyIH1cbiAgICApID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIGFydGljbGVDb21tZW50Q29sbGVjdGlvbixcbiAgICAgICAgYXJ0aWNsZUNvbW1lbnRTY2hlbWFcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsXG4gICAgICAgIC5maW5kKHsgYXJ0aWNsZUlkOiBhcnRpY2xlSWQgfSlcbiAgICAgICAgLy8gLnNvcnQoeyByb290UGFyZW50SWQ6IDEsIHBhcmVudElkOiAxLCBjcmVhdGVkQXQ6IDEgfSlcbiAgICAgICAgLnNvcnQoeyBpc0Fuc3dlcjogLTEgfSlcbiAgICAgICAgLnNvcnQoeyBjcmVhdGVkQXQ6IDEgfSlcbiAgICAgICAgLnNraXAocGFnZU5vICogcGFnZVNpemUpXG4gICAgICAgIC5saW1pdChwYWdlU2l6ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRzOiByZXNwb25zZSxcbiAgICAgICAgcGFnZU5vOiByZXNwb25zZS5sZW5ndGggPT09IHBhZ2VTaXplID8gcGFnZU5vICsgMSA6IHBhZ2VObyxcbiAgICAgICAgaGFzTW9yZTogcmVzcG9uc2UubGVuZ3RoID09PSBwYWdlU2l6ZSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBhcnRpY2xlQ29tbWVudDogYXN5bmMgKF8sIHsgaWQgfSwgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhcnRpY2xlQ29tbWVudENvbGxlY3Rpb24sXG4gICAgICAgIGFydGljbGVDb21tZW50U2NoZW1hXG4gICAgICApO1xuICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmRCeUlkKGlkKTtcbiAgICB9LFxuICB9LFxuXG4gIEFydGljbGVDb21tZW50RmVlZGJhY2s6IHtcbiAgICBhcnRpY2xlQ29tbWVudDogYXN5bmMgKHBhcmVudCwgXywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhcnRpY2xlQ29tbWVudENvbGxlY3Rpb24sXG4gICAgICAgIGFydGljbGVDb21tZW50U2NoZW1hXG4gICAgICApO1xuICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmRCeUlkKHBhcmVudC5jb21tZW50SWQpO1xuICAgIH0sXG4gIH0sXG5cbiAgTXV0YXRpb246IHtcbiAgICB1cGRhdGVBcnRpY2xlQ29tbWVudDogYXN5bmMgKF8sIHsgcGF5bG9hZCB9LCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIGFydGljbGVDb21tZW50Q29sbGVjdGlvbixcbiAgICAgICAgYXJ0aWNsZUNvbW1lbnRTY2hlbWFcbiAgICAgICk7XG5cbiAgICAgIGxldCBpZCA9IHBheWxvYWQuaWQ7XG5cbiAgICAgIGlmICghcGF5bG9hZC5pZCkge1xuICAgICAgICBjb25zdCBhcnRpY2xlTW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgIGFydGljbGVDb2xsZWN0aW9uLFxuICAgICAgICAgIGFydGljbGVTY2hlbWFcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgYXJ0aWNsZU1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICAgIHBheWxvYWQuYXJ0aWNsZUlkLFxuICAgICAgICAgIHsgJGluYzogeyBjb21tZW50czogMSB9IH0sXG4gICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5ldyBtb2RlbCh7XG4gICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICBjcmVhdGVkQnk6IHVzZXIudXNlcklkLFxuICAgICAgICB9KS5zYXZlKCk7XG4gICAgICAgIGlkID0gcmVzcG9uc2UuaWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudEZpZWxkcyA9IHsgcGFyZW50SWQ6IHBheWxvYWQucGFyZW50SWQgfHwgaWQgfTtcbiAgICAgIGlmICghcGF5bG9hZC5pZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRDb21tZW50ID0gYXdhaXQgbW9kZWwuZmluZEJ5SWQocGF5bG9hZC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChwYXJlbnRDb21tZW50KSB7XG4gICAgICAgICAgcGFyZW50RmllbGRzLnJvb3RQYXJlbnRJZCA9IHBhcmVudENvbW1lbnQucm9vdFBhcmVudElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudEZpZWxkcy5yb290UGFyZW50SWQgPSBwYXJlbnRGaWVsZHMucGFyZW50SWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICBpZCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgLi4ucGFyZW50RmllbGRzLFxuICAgICAgICAgIHVwZGF0ZWRCeTogdXNlci51c2VySWQsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBtYXJrQXJ0aWNsZUNvbW1lbnRBc0Fuc3dlcjogYXN5bmMgKF8sIHsgaWQgfSwgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhcnRpY2xlQ29tbWVudENvbGxlY3Rpb24sXG4gICAgICAgIGFydGljbGVDb21tZW50U2NoZW1hXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICBpZCxcbiAgICAgICAge1xuICAgICAgICAgIGlzQW5zd2VyOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZWRCeTogdXNlci51c2VySWQsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IG1vZGVsLnVwZGF0ZU1hbnkoXG4gICAgICAgIHsgJGFuZDogW3sgYXJ0aWNsZUlkOiByZXNwb25zZS5hcnRpY2xlSWQgfSwgeyBfaWQ6IHsgJG5lOiBpZCB9IH1dIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICBpc0Fuc3dlcjogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5ldzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgYXJ0aWNsZU1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIGFydGljbGVDb2xsZWN0aW9uLFxuICAgICAgICBhcnRpY2xlU2NoZW1hXG4gICAgICApO1xuICAgICAgYXdhaXQgYXJ0aWNsZU1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICByZXNwb25zZS5hcnRpY2xlSWQsXG4gICAgICAgIHsgaXNBbnN3ZXJlZDogdHJ1ZSwgYW5zd2VyZWRPbjogbmV3IERhdGUoKSB9LFxuICAgICAgICB7IG5ldzogdHJ1ZSB9XG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbiAgICB1bm1hcmtBcnRpY2xlQ29tbWVudEFzQW5zd2VyOiBhc3luYyAoXywgeyBpZCB9LCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIGFydGljbGVDb21tZW50Q29sbGVjdGlvbixcbiAgICAgICAgYXJ0aWNsZUNvbW1lbnRTY2hlbWFcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgIGlkLFxuICAgICAgICB7XG4gICAgICAgICAgaXNBbnN3ZXI6IGZhbHNlLFxuICAgICAgICAgIHVwZGF0ZWRCeTogdXNlci51c2VySWQsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGFydGljbGVNb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhcnRpY2xlQ29sbGVjdGlvbixcbiAgICAgICAgYXJ0aWNsZVNjaGVtYVxuICAgICAgKTtcbiAgICAgIGF3YWl0IGFydGljbGVNb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShcbiAgICAgICAgcmVzcG9uc2UuYXJ0aWNsZUlkLFxuICAgICAgICB7IGlzQW5zd2VyZWQ6IGZhbHNlLCBhbnN3ZXJlZE9uOiBudWxsIH0sXG4gICAgICAgIHsgbmV3OiB0cnVlIH1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHR5cGVEZWZzLCByZXNvbHZlcnMgfTtcbiIsInZhciBtb25nb29zZSA9IHJlcXVpcmUoXCJtb25nb29zZVwiKTtcblxuY29uc3QgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xuY29uc3QgYXJ0aWNsZUNvbW1lbnRTY2hlbWEgPSBuZXcgU2NoZW1hKFxuICB7XG4gICAgdGV4dDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBwYXJlbnRJZDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICByb290UGFyZW50SWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgYXJ0aWNsZUlkOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGhlbHBmdWw6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAwIH0sXG4gICAgbm90SGVscGZ1bDogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDAgfSxcbiAgICBpc0Fuc3dlcjogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIGNyZWF0ZWRCeTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB1cGRhdGVkQnk6IHsgdHlwZTogU3RyaW5nIH0sXG4gIH0sXG4gIHsgdGltZXN0YW1wczogdHJ1ZSB9XG4pO1xuXG5jb25zdCBhcnRpY2xlQ29tbWVudENvbGxlY3Rpb24gPSBcImFydGljbGUuY29tbWVudFwiO1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IG1vbmdvb3NlLm1vZGVsKCdib29rbWFya3MnLCBwb3N0U2NoZW1hKTtcbm1vZHVsZS5leHBvcnRzID0geyBhcnRpY2xlQ29tbWVudFNjaGVtYSwgYXJ0aWNsZUNvbW1lbnRDb2xsZWN0aW9uIH07XG4iLCJjb25zdCB7IGdxbCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcbmNvbnN0IHsgYXJ0aWNsZUZlZWRiYWNrU2NoZW1hLCBhcnRpY2xlRmVlZGJhY2tDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbmNvbnN0IHsgYXJ0aWNsZVNjaGVtYSwgYXJ0aWNsZUNvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi9tb2RlbFwiKTtcbmNvbnN0IHsgZ2V0Q29sbGVjdGlvbiB9ID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9kYnV0aWxzXCIpO1xuXG5jb25zdCB0eXBlRGVmcyA9IGdxbGBcbiAgZXh0ZW5kIHR5cGUgUXVlcnkge1xuICAgIGFydGljbGVGZWVkYmFjayhhcnRpY2xlSWQ6IElEISk6IFtBcnRpY2xlRmVlZGJhY2tdXG4gIH1cblxuICBleHRlbmQgdHlwZSBNdXRhdGlvbiB7XG4gICAgYWRkQXJ0aWNsZUZlZWRiYWNrKGFydGljbGVJZDogU3RyaW5nISwgdHlwZTogU3RyaW5nISk6IEFydGljbGVGZWVkYmFja1xuICAgIHJlbW92ZUFydGljbGVGZWVkYmFjayhhcnRpY2xlSWQ6IFN0cmluZyEsIHR5cGU6IFN0cmluZyEpOiBBcnRpY2xlRmVlZGJhY2tcbiAgfVxuXG4gIHR5cGUgQXJ0aWNsZUZlZWRiYWNrIHtcbiAgICBpZDogSUQhXG4gICAgdHlwZTogU3RyaW5nXG4gIH1cblxuICBleHRlbmQgdHlwZSBBcnRpY2xlIHtcbiAgICBmZWVkYmFjazogW0FydGljbGVGZWVkYmFja11cbiAgfVxuYDtcblxuY29uc3QgcmVzb2x2ZXJzID0ge1xuICBRdWVyeToge1xuICAgIGFydGljbGVGZWVkYmFjazogYXN5bmMgKF8sIHsgYXJ0aWNsZUlkIH0sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgYXJ0aWNsZUZlZWRiYWNrQ29sbGVjdGlvbixcbiAgICAgICAgYXJ0aWNsZUZlZWRiYWNrU2NoZW1hXG4gICAgICApO1xuICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmQoeyBhcnRpY2xlSWQ6IGFydGljbGVJZCwgdXNlcklkOiB1c2VyLnVzZXJJZCB9KTtcbiAgICB9LFxuICB9LFxuXG4gIEFydGljbGU6IHtcbiAgICBmZWVkYmFjazoge1xuICAgICAgcmVzb2x2ZTogYXN5bmMgKHBhcmVudCwgX2FyZ3MsIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgICAgXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgICBhc3NldCxcbiAgICAgICAgICBhcnRpY2xlRmVlZGJhY2tDb2xsZWN0aW9uLFxuICAgICAgICAgIGFydGljbGVGZWVkYmFja1NjaGVtYVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZCh7IGFydGljbGVJZDogcGFyZW50LmlkLCB1c2VySWQ6IHVzZXIudXNlcklkIH0pO1xuICAgICAgfSxcbiAgICB9LFxuICB9LFxuXG4gIE11dGF0aW9uOiB7XG4gICAgYWRkQXJ0aWNsZUZlZWRiYWNrOiBhc3luYyAoXywgYXJncywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhcnRpY2xlRmVlZGJhY2tDb2xsZWN0aW9uLFxuICAgICAgICBhcnRpY2xlRmVlZGJhY2tTY2hlbWFcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsLmZpbmRPbmVBbmRVcGRhdGUoXG4gICAgICAgIHsgYXJ0aWNsZUlkOiBhcmdzLmFydGljbGVJZCwgdXNlcklkOiB1c2VyLnVzZXJJZCwgdHlwZTogYXJncy50eXBlIH0sXG4gICAgICAgIHsgYXJ0aWNsZUlkOiBhcmdzLmFydGljbGVJZCwgdXNlcklkOiB1c2VyLnVzZXJJZCwgdHlwZTogYXJncy50eXBlIH0sXG4gICAgICAgIHsgdXBzZXJ0OiB0cnVlLCBuZXc6IHRydWUsIHJhd1Jlc3VsdDogdHJ1ZSB9XG4gICAgICApO1xuICAgICAgaWYgKCFyZXNwb25zZS5sYXN0RXJyb3JPYmplY3QudXBkYXRlZEV4aXN0aW5nKSB7XG4gICAgICAgIGNvbnN0IGFydGljbGVNb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgYXJ0aWNsZUNvbGxlY3Rpb24sXG4gICAgICAgICAgYXJ0aWNsZVNjaGVtYVxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBhcnRpY2xlTW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgICAgYXJncy5hcnRpY2xlSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgJGluYzogeyBbYXJncy50eXBlXTogMSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnZhbHVlO1xuICAgIH0sXG4gICAgcmVtb3ZlQXJ0aWNsZUZlZWRiYWNrOiBhc3luYyAoXywgYXJncywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBhcnRpY2xlRmVlZGJhY2tDb2xsZWN0aW9uLFxuICAgICAgICBhcnRpY2xlRmVlZGJhY2tTY2hlbWFcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsLmZpbmRPbmVBbmREZWxldGUoXG4gICAgICAgIHsgYXJ0aWNsZUlkOiBhcmdzLmFydGljbGVJZCwgdXNlcklkOiB1c2VyLnVzZXJJZCwgdHlwZTogYXJncy50eXBlIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByYXdSZXN1bHQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2UubGFzdEVycm9yT2JqZWN0Lm4gPiAwKSB7XG4gICAgICAgIGNvbnN0IGFydGljbGVNb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgYXJ0aWNsZUNvbGxlY3Rpb24sXG4gICAgICAgICAgYXJ0aWNsZVNjaGVtYVxuICAgICAgICApO1xuICAgICAgICBhd2FpdCBhcnRpY2xlTW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgICAgYXJncy5hcnRpY2xlSWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgJGluYzogeyBbYXJncy50eXBlXTogLTEgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgbmV3OiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS52YWx1ZTtcbiAgICB9LFxuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHR5cGVEZWZzLCByZXNvbHZlcnMgfTtcbiIsInZhciBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG5cbmNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbmNvbnN0IGFydGljbGVGZWVkYmFja1NjaGVtYSA9IG5ldyBTY2hlbWEoXG4gIHtcbiAgICBhcnRpY2xlSWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdHlwZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB1c2VySWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gIH0sXG4gIHsgdGltZXN0YW1wczogdHJ1ZSB9XG4pO1xuXG5jb25zdCBhcnRpY2xlRmVlZGJhY2tDb2xsZWN0aW9uID0gJ2FydGljbGUuZmVlZGJhY2snO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgYXJ0aWNsZUZlZWRiYWNrU2NoZW1hLCBhcnRpY2xlRmVlZGJhY2tDb2xsZWN0aW9uIH07XG4iLCJjb25zdCB7IGdxbCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcbmNvbnN0IHsgR3JhcGhRTFNjYWxhclR5cGUgfSA9IHJlcXVpcmUoXCJncmFwaHFsXCIpO1xuY29uc3QgeyBhcnRpY2xlU2NoZW1hLCBhcnRpY2xlQ29sbGVjdGlvbiB9ID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG5jb25zdCB7IGFydGljbGVUYWdTY2hlbWEsIGFydGljbGVUYWdDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi90YWcvbW9kZWxcIik7XG5jb25zdCB7IGNhdGVnb3J5U2NoZW1hLCBjYXRlZ29yeUNvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuL2NhdGVnb3J5L21vZGVsXCIpO1xuY29uc3QgeyBnZXRDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vLi4vbGliL2RidXRpbHNcIik7XG5cbmNvbnN0IHR5cGVEZWZzID0gZ3FsYFxuICBzY2FsYXIgRGF0ZVNjYWxhclxuICBleHRlbmQgdHlwZSBRdWVyeSB7XG4gICAgYXJ0aWNsZShpZDogSUQhKTogQXJ0aWNsZVxuICAgIGFydGljbGVzKGNhdGVnb3J5SWQ6IElEISwgcGFnZVNpemU6IEludCwgcGFnZU5vOiBJbnQpOiBBcnRpY2xlUGFnaW5hdGVkXG4gICAgc2VhcmNoQXJ0aWNsZXModGV4dDogU3RyaW5nLCBwYWdlU2l6ZTogSW50LCBwYWdlTm86IEludCk6IEFydGljbGVQYWdpbmF0ZWRcbiAgICBnZXRBcnRpY2xlcyhcbiAgICAgIHRleHQ6IFN0cmluZ1xuICAgICAgY2F0ZWdvcnlJZDogU3RyaW5nXG4gICAgICBwYWdlU2l6ZTogSW50XG4gICAgICBwYWdlTm86IEludFxuICAgICk6IEFydGljbGVQYWdpbmF0ZWRcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIE11dGF0aW9uIHtcbiAgICBhZGRBcnRpY2xlKHBheWxvYWQ6IEFydGljbGVQYXlsb2FkKTogQXJ0aWNsZVxuICAgIGRlbGV0ZUFydGljbGUoaWQ6IElEISk6IEFydGljbGVcbiAgfVxuXG4gIGlucHV0IEFydGljbGVQYXlsb2FkIHtcbiAgICBpZDogU3RyaW5nXG4gICAgdGl0bGU6IEpTT05cbiAgICBkZXNjcmlwdGlvbjogSlNPTlxuICAgIGNhdGVnb3J5SWQ6IFN0cmluZ1xuICAgIGFkZFRhZ3M6IFtTdHJpbmddXG4gICAgcmVtb3ZlVGFnczogW1N0cmluZ11cbiAgfVxuXG4gIHR5cGUgQXJ0aWNsZVBhZ2luYXRlZCB7XG4gICAgcGFnZU5vOiBJbnRcbiAgICBoYXNNb3JlOiBCb29sZWFuXG4gICAgdG90YWw6IEludFxuICAgIHJlc3VsdHM6IFtBcnRpY2xlXSFcbiAgfVxuXG4gIHR5cGUgQXJ0aWNsZSB7XG4gICAgaWQ6IElEIVxuICAgIHRpdGxlOiBKU09OXG4gICAgZGVzY3JpcHRpb246IEpTT05cbiAgICB2aWV3czogSW50IVxuICAgIGNvbW1lbnRzOiBJbnQhXG4gICAgaXNBbnN3ZXJlZDogQm9vbGVhbiFcbiAgICBhbnN3ZXJlZE9uOiBEYXRlU2NhbGFyXG4gICAgaGVscGZ1bDogSW50IVxuICAgIG5vdEhlbHBmdWw6IEludCFcbiAgICBjcmVhdGVkQXQ6IERhdGVTY2FsYXJcbiAgICB1cGRhdGVkQXQ6IERhdGVTY2FsYXJcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIEFydGljbGVGZWVkYmFjayB7XG4gICAgYXJ0aWNsZTogQXJ0aWNsZVxuICB9XG4gIGV4dGVuZCB0eXBlIEFydGljbGVUYWcge1xuICAgIGFydGljbGU6IEFydGljbGVcbiAgfVxuICBleHRlbmQgdHlwZSBBcnRpY2xlQ29tbWVudCB7XG4gICAgYXJ0aWNsZTogQXJ0aWNsZVxuICB9XG5gO1xuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gIERhdGVTY2FsYXI6IG5ldyBHcmFwaFFMU2NhbGFyVHlwZSh7XG4gICAgbmFtZTogXCJEYXRlU2NhbGFyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiRGF0ZSBjdXN0b20gc2NhbGFyIHR5cGVcIixcbiAgICBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpOyAvLyB2YWx1ZSBmcm9tIHRoZSBjbGllbnRcbiAgICB9LFxuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmdldFRpbWUoKTsgLy8gdmFsdWUgc2VudCB0byB0aGUgY2xpZW50XG4gICAgfSxcbiAgICBwYXJzZUxpdGVyYWwoYXN0KSB7XG4gICAgICBpZiAoYXN0LmtpbmQgPT09IEtpbmQuSU5UKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgrYXN0LnZhbHVlKTsgLy8gYXN0IHZhbHVlIGlzIGFsd2F5cyBpbiBzdHJpbmcgZm9ybWF0XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICB9KSxcbiAgUXVlcnk6IHtcbiAgICBhcnRpY2xlOiBhc3luYyAoXywgeyBpZCB9LCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgYXJ0aWNsZUNvbGxlY3Rpb24sIGFydGljbGVTY2hlbWEpO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShcbiAgICAgICAgaWQsXG4gICAgICAgIHsgJGluYzogeyB2aWV3czogMSB9IH0sXG4gICAgICAgIHsgbmV3OiB0cnVlIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbiAgICBhcnRpY2xlczogYXN5bmMgKFxuICAgICAgXyxcbiAgICAgIHsgY2F0ZWdvcnlJZCwgcGFnZVNpemUgPSAwLCBwYWdlTm8gPSAwIH0sXG4gICAgICB7IGFzc2V0LCB1c2VyIH1cbiAgICApID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghY2F0ZWdvcnlJZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgIHBhZ2VObzogMCxcbiAgICAgICAgICBoYXNNb3JlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgYXJ0aWNsZUNvbGxlY3Rpb24sIGFydGljbGVTY2hlbWEpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtb2RlbFxuICAgICAgICAuZmluZCh7IGNhdGVnb3J5SWQ6IGNhdGVnb3J5SWQgfSlcbiAgICAgICAgLnNraXAocGFnZU5vICogcGFnZVNpemUpXG4gICAgICAgIC5saW1pdChwYWdlU2l6ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRzOiByZXNwb25zZSxcbiAgICAgICAgcGFnZU5vOiByZXNwb25zZS5sZW5ndGggPT09IHBhZ2VTaXplID8gcGFnZU5vICsgMSA6IHBhZ2VObyxcbiAgICAgICAgaGFzTW9yZTogcmVzcG9uc2UubGVuZ3RoID09PSBwYWdlU2l6ZSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBzZWFyY2hBcnRpY2xlczogYXN5bmMgKFxuICAgICAgXyxcbiAgICAgIHsgdGV4dCwgcGFnZVNpemUgPSAwLCBwYWdlTm8gPSAwIH0sXG4gICAgICB7IGFzc2V0LCB1c2VyIH1cbiAgICApID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgIHBhZ2VObzogMCxcbiAgICAgICAgICBoYXNNb3JlOiBmYWxzZSxcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgYXJ0aWNsZUNvbGxlY3Rpb24sIGFydGljbGVTY2hlbWEpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgbW9kZWxcbiAgICAgICAgLmZpbmQoe1xuICAgICAgICAgICRvcjogW1xuICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogeyAkcmVnZXg6IG5ldyBSZWdFeHAodGV4dCwgXCJpZ1wiKSB9IH0sXG4gICAgICAgICAgICB7IHRpdGxlOiB7ICRyZWdleDogbmV3IFJlZ0V4cCh0ZXh0LCBcImlnXCIpIH0gfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KVxuICAgICAgICAuc2tpcChwYWdlTm8gKiBwYWdlU2l6ZSlcbiAgICAgICAgLmxpbWl0KHBhZ2VTaXplKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0czogcmVzLFxuICAgICAgICBwYWdlTm86IHJlcy5sZW5ndGggPT09IHBhZ2VTaXplID8gcGFnZU5vICsgMSA6IHBhZ2VObyxcbiAgICAgICAgaGFzTW9yZTogcmVzLmxlbmd0aCA9PT0gcGFnZVNpemUgPyB0cnVlIDogZmFsc2UsXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0QXJ0aWNsZXM6IGFzeW5jIChcbiAgICAgIF8sXG4gICAgICB7IHRleHQsIGNhdGVnb3J5SWQsIHBhZ2VTaXplID0gMCwgcGFnZU5vID0gMCB9LFxuICAgICAgeyBhc3NldCwgdXNlciB9XG4gICAgKSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIGFydGljbGVDb2xsZWN0aW9uLCBhcnRpY2xlU2NoZW1hKTtcbiAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IG1vZGVsXG4gICAgICAgICAgLmZpbmQoe1xuICAgICAgICAgICAgJG9yOiBbXG4gICAgICAgICAgICAgIHsgZGVzY3JpcHRpb246IHsgJHJlZ2V4OiBuZXcgUmVnRXhwKHRleHQsIFwiaWdcIikgfSB9LFxuICAgICAgICAgICAgICB7IHRpdGxlOiB7ICRyZWdleDogbmV3IFJlZ0V4cCh0ZXh0LCBcImlnXCIpIH0gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc2tpcChwYWdlTm8gKiBwYWdlU2l6ZSlcbiAgICAgICAgICAubGltaXQocGFnZVNpemUpO1xuICAgICAgfSBlbHNlIGlmIChjYXRlZ29yeUlkKSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IG1vZGVsXG4gICAgICAgICAgLmZpbmQoeyBjYXRlZ29yeUlkOiBjYXRlZ29yeUlkIH0pXG4gICAgICAgICAgLnNraXAocGFnZU5vICogcGFnZVNpemUpXG4gICAgICAgICAgLmxpbWl0KHBhZ2VTaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IG1vZGVsXG4gICAgICAgICAgLmZpbmQoKVxuICAgICAgICAgIC5za2lwKHBhZ2VObyAqIHBhZ2VTaXplKVxuICAgICAgICAgIC5saW1pdChwYWdlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybiB7XG4gICAgICAvLyAgIHJlc3VsdHM6IFtdLFxuICAgICAgLy8gICBwYWdlTm86IDAsXG4gICAgICAvLyAgIGhhc01vcmU6IGZhbHNlLFxuICAgICAgLy8gICB0b3RhbDogMCxcbiAgICAgIC8vIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRzOiByZXMsXG4gICAgICAgIHBhZ2VObzogcmVzLmxlbmd0aCA9PT0gcGFnZVNpemUgPyBwYWdlTm8gKyAxIDogcGFnZU5vLFxuICAgICAgICBoYXNNb3JlOiByZXMubGVuZ3RoID09PSBwYWdlU2l6ZSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfSxcbiAgfSxcblxuICBBcnRpY2xlRmVlZGJhY2s6IHtcbiAgICBhcnRpY2xlOiBhc3luYyAocGFyZW50LCBfLCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgYXJ0aWNsZUNvbGxlY3Rpb24sIGFydGljbGVTY2hlbWEpO1xuICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmRCeUlkKHBhcmVudC5hcnRpY2xlSWQpO1xuICAgIH0sXG4gIH0sXG5cbiAgQXJ0aWNsZVRhZzoge1xuICAgIGFydGljbGU6IGFzeW5jIChwYXJlbnQsIF8sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBhcnRpY2xlQ29sbGVjdGlvbiwgYXJ0aWNsZVNjaGVtYSk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZEJ5SWQocGFyZW50LmFydGljbGVJZCk7XG4gICAgfSxcbiAgfSxcblxuICBBcnRpY2xlQ29tbWVudDoge1xuICAgIGFydGljbGU6IGFzeW5jIChwYXJlbnQsIF8sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBhcnRpY2xlQ29sbGVjdGlvbiwgYXJ0aWNsZVNjaGVtYSk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZEJ5SWQocGFyZW50LmFydGljbGVJZCk7XG4gICAgfSxcbiAgfSxcblxuICBNdXRhdGlvbjoge1xuICAgIGFkZEFydGljbGU6IGFzeW5jIChfLCBhcmdzLCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgYXJ0aWNsZUNvbGxlY3Rpb24sIGFydGljbGVTY2hlbWEpO1xuICAgICAgY29uc3QgdGFnTW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgYXJ0aWNsZVRhZ0NvbGxlY3Rpb24sXG4gICAgICAgIGFydGljbGVUYWdTY2hlbWFcbiAgICAgICk7XG4gICAgICBsZXQgYXJ0aWNsZVJlc3BvbnNlO1xuXG4gICAgICBpZiAoYXJncy5wYXlsb2FkLmlkKSB7XG4gICAgICAgIGV4aXN0aW5nQXJ0aWNsZSA9IGF3YWl0IG1vZGVsLmZpbmRCeUlkKGFyZ3MucGF5bG9hZC5pZCk7XG4gICAgICAgIGlmIChleGlzdGluZ0FydGljbGUuY2F0ZWdvcnlJZCAhPT0gYXJncy5wYXlsb2FkLmNhdGVnb3J5SWQpIHtcbiAgICAgICAgICBjb25zdCBjYXRlZ29yeU1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgICAgY2F0ZWdvcnlDb2xsZWN0aW9uLFxuICAgICAgICAgICAgY2F0ZWdvcnlTY2hlbWFcbiAgICAgICAgICApO1xuICAgICAgICAgIGF3YWl0IGNhdGVnb3J5TW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgICAgICBleGlzdGluZ0FydGljbGUuY2F0ZWdvcnlJZCxcbiAgICAgICAgICAgIHsgJGluYzogeyBhcnRpY2xlczogLTEgfSB9LFxuICAgICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgYXdhaXQgY2F0ZWdvcnlNb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShcbiAgICAgICAgICAgIGFyZ3MucGF5bG9hZC5jYXRlZ29yeUlkLFxuICAgICAgICAgICAgeyAkaW5jOiB7IGFydGljbGVzOiAxIH0gfSxcbiAgICAgICAgICAgIHsgbmV3OiB0cnVlIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGFydGljbGVSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICAgIGFyZ3MucGF5bG9hZC5pZCxcbiAgICAgICAgICBhcmdzLnBheWxvYWQsXG4gICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBtb2RlbChhcmdzLnBheWxvYWQpO1xuICAgICAgICBhcnRpY2xlUmVzcG9uc2UgPSBhd2FpdCBkYXRhLnNhdmUoKTtcbiAgICAgICAgY29uc3QgY2F0ZWdvcnlNb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgY2F0ZWdvcnlDb2xsZWN0aW9uLFxuICAgICAgICAgIGNhdGVnb3J5U2NoZW1hXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IGNhdGVnb3J5TW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgICAgYXJncy5wYXlsb2FkLmNhdGVnb3J5SWQsXG4gICAgICAgICAgeyAkaW5jOiB7IGFydGljbGVzOiAxIH0gfSxcbiAgICAgICAgICB7IG5ldzogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGFyZ3MucGF5bG9hZC5hZGRUYWdzLmZvckVhY2goYXN5bmMgKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyB0YWdNb2RlbCh7XG4gICAgICAgICAgbmFtZTogaXRlbSxcbiAgICAgICAgICBhcnRpY2xlSWQ6IGFydGljbGVSZXNwb25zZS5faWQsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBkYXRhLnNhdmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBhcmdzLnBheWxvYWQucmVtb3ZlVGFncy5mb3JFYWNoKGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgIGF3YWl0IHRhZ01vZGVsLmRlbGV0ZU1hbnkoe1xuICAgICAgICAgIGFydGljbGVJZDogYXJ0aWNsZVJlc3BvbnNlLl9pZCxcbiAgICAgICAgICBuYW1lOiBpdGVtLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjb25zdCBjYXRlZ29yeVN0YXQgPSBhd2FpdCBtb2RlbC5hZ2dyZWdhdGUoW1xuICAgICAgLy8gICB7XG4gICAgICAvLyAgICAgJGdyb3VwOiB7XG4gICAgICAvLyAgICAgICBfaWQ6ICckY2F0ZWdvcnlJZCcsXG4gICAgICAvLyAgICAgICBjb3VudDogeyAkc3VtOiAxIH0sXG4gICAgICAvLyAgICAgfSxcbiAgICAgIC8vICAgfSxcbiAgICAgIC8vIF0pO1xuXG4gICAgICByZXR1cm4gYXJ0aWNsZVJlc3BvbnNlO1xuICAgIH0sXG4gICAgZGVsZXRlQXJ0aWNsZTogYXN5bmMgKF8sIHsgaWQgfSwgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIGFydGljbGVDb2xsZWN0aW9uLCBhcnRpY2xlU2NoZW1hKTtcbiAgICAgIGNvbnN0IHRhZ01vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIGFydGljbGVUYWdDb2xsZWN0aW9uLFxuICAgICAgICBhcnRpY2xlVGFnU2NoZW1hXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBtb2RlbC5maW5kQnlJZEFuZERlbGV0ZShpZCk7XG5cbiAgICAgIGF3YWl0IHRhZ01vZGVsLmRlbGV0ZU1hbnkoe1xuICAgICAgICBhcnRpY2xlSWQ6IGlkLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0eXBlRGVmcywgcmVzb2x2ZXJzIH07XG4iLCJ2YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG5cbmNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbmNvbnN0IGFydGljbGVTY2hlbWEgPSBuZXcgU2NoZW1hKFxuICB7XG4gICAgdGl0bGU6IHsgdHlwZTogQXJyYXkgfSxcbiAgICBkZXNjcmlwdGlvbjogeyB0eXBlOiBBcnJheSB9LFxuICAgIGNhdGVnb3J5SWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdmlld3M6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAwIH0sXG4gICAgY29tbWVudHM6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAwIH0sXG4gICAgaXNBbnN3ZXJlZDogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIGFuc3dlcmVkT246IHsgdHlwZTogRGF0ZSB9LFxuICAgIGhlbHBmdWw6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAwIH0sXG4gICAgbm90SGVscGZ1bDogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDAgfSxcbiAgfSxcbiAgeyB0aW1lc3RhbXBzOiB0cnVlIH1cbik7XG5cbmNvbnN0IGFydGljbGVDb2xsZWN0aW9uID0gXCJhcnRpY2xlXCI7XG5cbi8vIG1vZHVsZS5leHBvcnRzID0gbW9uZ29vc2UubW9kZWwoJ2Jvb2ttYXJrcycsIGFydGljbGVTY2hlbWEpO1xubW9kdWxlLmV4cG9ydHMgPSB7IGFydGljbGVTY2hlbWEsIGFydGljbGVDb2xsZWN0aW9uIH07XG4iLCJjb25zdCB7IGdxbCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcbmNvbnN0IHsgYXJ0aWNsZVRhZ1NjaGVtYSwgYXJ0aWNsZVRhZ0NvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuY29uc3QgeyBnZXRDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIik7XG5cbmNvbnN0IHR5cGVEZWZzID0gZ3FsYFxuICBleHRlbmQgdHlwZSBRdWVyeSB7XG4gICAgYXJ0aWNsZVRhZ0Nsb3VkOiBbQXJ0aWNsZVRhZ0Nsb3VkXVxuICAgIGFydGljbGVzQnlUYWcodGFnOiBTdHJpbmchLCBwYWdlU2l6ZTogSW50LCBwYWdlTm86IEludCk6IEFydGljbGVUYWdQYWdpbmF0ZWRcbiAgfVxuXG4gIHR5cGUgQXJ0aWNsZVRhZ1BhZ2luYXRlZCB7XG4gICAgcGFnZU5vOiBJbnRcbiAgICBoYXNNb3JlOiBCb29sZWFuXG4gICAgdG90YWw6IEludFxuICAgIHJlc3VsdHM6IFtBcnRpY2xlVGFnXSFcbiAgfVxuXG4gIHR5cGUgQXJ0aWNsZVRhZ0Nsb3VkIHtcbiAgICBuYW1lOiBTdHJpbmdcbiAgICBjb3VudDogSW50XG4gIH1cblxuICB0eXBlIEFydGljbGVUYWcge1xuICAgIGlkOiBJRCFcbiAgICBuYW1lOiBTdHJpbmdcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIEFydGljbGUge1xuICAgIHRhZ3M6IFtBcnRpY2xlVGFnXVxuICB9XG5gO1xuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gIFF1ZXJ5OiB7XG4gICAgYXJ0aWNsZVRhZ0Nsb3VkOiBhc3luYyAoXywgX18sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgYXJ0aWNsZVRhZ0NvbGxlY3Rpb24sXG4gICAgICAgIGFydGljbGVUYWdTY2hlbWFcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuYWdncmVnYXRlKFtcbiAgICAgICAge1xuICAgICAgICAgICRncm91cDoge1xuICAgICAgICAgICAgX2lkOiBcIiRuYW1lXCIsXG4gICAgICAgICAgICBjb3VudDogeyAkc3VtOiAxIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICRwcm9qZWN0OiB7XG4gICAgICAgICAgICBuYW1lOiBcIiRfaWRcIixcbiAgICAgICAgICAgIGNvdW50OiBcIiRjb3VudFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdKTtcbiAgICB9LFxuICAgIGFydGljbGVzQnlUYWc6IGFzeW5jIChcbiAgICAgIF8sXG4gICAgICB7IHRhZywgcGFnZVNpemUgPSAwLCBwYWdlTm8gPSAwIH0sXG4gICAgICB7IGFzc2V0LCB1c2VyIH1cbiAgICApID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGFnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0czogW10sXG4gICAgICAgICAgcGFnZU5vOiAwLFxuICAgICAgICAgIGhhc01vcmU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgYXJ0aWNsZVRhZ0NvbGxlY3Rpb24sXG4gICAgICAgIGFydGljbGVUYWdTY2hlbWFcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsXG4gICAgICAgIC5maW5kKHsgbmFtZTogdGFnIH0pXG4gICAgICAgIC5za2lwKHBhZ2VObyAqIHBhZ2VTaXplKVxuICAgICAgICAubGltaXQocGFnZVNpemUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0czogcmVzcG9uc2UsXG4gICAgICAgIHBhZ2VObzogcmVzcG9uc2UubGVuZ3RoID09PSBwYWdlU2l6ZSA/IHBhZ2VObyArIDEgOiBwYWdlTm8sXG4gICAgICAgIGhhc01vcmU6IHJlc3BvbnNlLmxlbmd0aCA9PT0gcGFnZVNpemUgPyB0cnVlIDogZmFsc2UsXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gdGFnczogYXN5bmMgKF8sIF9fLCB7IHVzZXIgfSkgPT4ge1xuICAgIC8vICAgLy8gaWYgKCF1c2VyKSB7XG4gICAgLy8gICAvLyAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcignTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudCcpO1xuICAgIC8vICAgLy8gfVxuICAgIC8vICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKDIxMCwgYXJ0aWNsZVRhZ0NvbGxlY3Rpb24sIGFydGljbGVUYWdTY2hlbWEpO1xuICAgIC8vICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmQoe30pO1xuICAgIC8vIH0sXG4gIH0sXG5cbiAgQXJ0aWNsZToge1xuICAgIHRhZ3M6IHtcbiAgICAgIHJlc29sdmU6IGFzeW5jIChwYXJlbnQsIF9hcmdzLCB7IGFzc2V0LCB1c2VyIH0sIGluZm8pID0+IHtcbiAgICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICAgIFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgYXJ0aWNsZVRhZ0NvbGxlY3Rpb24sXG4gICAgICAgICAgYXJ0aWNsZVRhZ1NjaGVtYVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZCh7IGFydGljbGVJZDogcGFyZW50LmlkIH0pO1xuICAgICAgfSxcbiAgICB9LFxuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHR5cGVEZWZzLCByZXNvbHZlcnMgfTtcbiIsInZhciBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG5cbmNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbmNvbnN0IGFydGljbGVUYWdTY2hlbWEgPSBuZXcgU2NoZW1hKFxuICB7XG4gICAgbmFtZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBhcnRpY2xlSWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gIH0sXG4gIHsgdGltZXN0YW1wczogdHJ1ZSB9XG4pO1xuXG5jb25zdCBhcnRpY2xlVGFnQ29sbGVjdGlvbiA9ICdhcnRpY2xlLnRhZyc7XG5cbi8vIG1vZHVsZS5leHBvcnRzID0gbW9uZ29vc2UubW9kZWwoJ2Jvb2ttYXJrcycsIGFydGljbGVTY2hlbWEpO1xubW9kdWxlLmV4cG9ydHMgPSB7IGFydGljbGVUYWdTY2hlbWEsIGFydGljbGVUYWdDb2xsZWN0aW9uIH07XG4iLCJjb25zdCB7IGdxbCB9ID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcbmNvbnN0IHsgYXNzZXRDb2xsZWN0aW9uLCBhc3NldFNjaGVtYSB9ID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG5jb25zdCB7IGdldEdsb2JhbENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvZGJ1dGlsc1wiKTtcbmNvbnN0IHsgaXNVbmF1dGhvcml6ZWQgfSA9IHJlcXVpcmUoXCIuLi8uLi9saWIvYXV0aHV0aWxzXCIpO1xuY29uc3QgeyBuZXh0dmFsIH0gPSByZXF1aXJlKFwiLi4vc2VxdWVuY2Uvc2VydmljZVwiKTtcblxuY29uc3QgdHlwZURlZnMgPSBncWxgXG4gIGV4dGVuZCB0eXBlIFF1ZXJ5IHtcbiAgICBhc3NldChhc3NldElkOiBTdHJpbmchKTogQXNzZXRcbiAgICBhc3NldEJ5SWQoaWQ6IElEISk6IEFzc2V0XG4gICAgYXNzZXRzOiBbQXNzZXRdXG4gIH1cblxuICBleHRlbmQgdHlwZSBNdXRhdGlvbiB7XG4gICAgdXBkYXRlQXNzZXQocGF5bG9hZDogQXNzZXRQYXlsb2FkKTogQXNzZXRcbiAgICBjcmVhdGVBc3NldChwYXlsb2FkOiBBc3NldFBheWxvYWQsIGFkZGl0aW9uOiBBc3NldEFkZGl0aW9uUGF5bG9hZCk6IEFzc2V0XG4gIH1cblxuICBpbnB1dCBBc3NldFBheWxvYWQge1xuICAgIGlkOiBTdHJpbmdcbiAgICBuYW1lOiBTdHJpbmdcbiAgICBzZWN0aW9uOiBKU09OXG4gICAgZmVhdHVyZWRUaXRsZTogU3RyaW5nXG4gICAgZmVhdHVyZWRTdWJ0aXRsZTogU3RyaW5nXG4gICAgaGVybzogSlNPTlxuICAgIGp3dFBhc3N3b3JkOiBTdHJpbmdcbiAgICBwcm9kdWN0aW9uTW9kZTogQm9vbGVhblxuICB9XG5cbiAgaW5wdXQgQXNzZXRBZGRpdGlvblBheWxvYWQge1xuICAgIGVtYWlsOiBTdHJpbmdcbiAgfVxuXG4gIHR5cGUgQXNzZXQge1xuICAgIGlkOiBJRCFcbiAgICBuYW1lOiBTdHJpbmdcbiAgICBzZWN0aW9uOiBKU09OXG4gICAgZmVhdHVyZWRUaXRsZTogU3RyaW5nXG4gICAgZmVhdHVyZWRTdWJ0aXRsZTogU3RyaW5nXG4gICAgaGVybzogSlNPTlxuICAgIGp3dFBhc3N3b3JkOiBTdHJpbmdcbiAgICBwcm9kdWN0aW9uTW9kZTogQm9vbGVhblxuICAgIGFzc2V0SWQ6IFN0cmluZ1xuICB9XG5gO1xuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gIFF1ZXJ5OiB7XG4gICAgYXNzZXQ6IGFzeW5jIChfLCB7IGFzc2V0SWQgfSwgeyB1c2VyIH0pID0+IHtcbiAgICAgIC8vIGlmICghdXNlcikge1xuICAgICAgLy8gICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoJ05vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnQnKTtcbiAgICAgIC8vIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0R2xvYmFsQ29sbGVjdGlvbihhc3NldENvbGxlY3Rpb24sIGFzc2V0U2NoZW1hKTtcbiAgICAgIHJldHVybiBhd2FpdCBtb2RlbC5maW5kT25lKHsgYXNzZXRJZCB9KTtcbiAgICB9LFxuICAgIGFzc2V0czogYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gaWYgKCF1c2VyKSB7XG4gICAgICAvLyAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcignTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudCcpO1xuICAgICAgLy8gfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRHbG9iYWxDb2xsZWN0aW9uKGFzc2V0Q29sbGVjdGlvbiwgYXNzZXRTY2hlbWEpO1xuICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmQoKTtcbiAgICB9LFxuICB9LFxuXG4gIE11dGF0aW9uOiB7XG4gICAgdXBkYXRlQXNzZXQ6IGFzeW5jIChfLCBhcmdzLCB7IHVzZXIgfSkgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBnZXRHbG9iYWxDb2xsZWN0aW9uKGFzc2V0Q29sbGVjdGlvbiwgYXNzZXRTY2hlbWEpO1xuICAgICAgaWYgKGFyZ3MucGF5bG9hZC5pZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoYXJncy5wYXlsb2FkLmlkLCBhcmdzLnBheWxvYWQsIHtcbiAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLnBheWxvYWQuYXNzZXRJZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZE9uZUFuZFVwZGF0ZShcbiAgICAgICAgICB7IGFzc2V0SWQ6IGFyZ3MucGF5bG9hZC5hc3NldElkIH0sXG4gICAgICAgICAgYXJncy5wYXlsb2FkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5ldzogdHJ1ZSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IG1vZGVsKHtcbiAgICAgICAgICAuLi5hcmdzLnBheWxvYWQsXG4gICAgICAgICAgYXNzZXRJZDogYGEke2F3YWl0IG5leHR2YWwoXCJhc3NldElkXCIpfWAsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgZGF0YS5zYXZlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVBc3NldDogYXN5bmMgKF8sIHsgcGF5bG9hZCwgYWRkaXRpb24gfSwgeyB1c2VyIH0pID0+IHtcbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0R2xvYmFsQ29sbGVjdGlvbihhc3NldENvbGxlY3Rpb24sIGFzc2V0U2NoZW1hKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgbW9kZWwoe1xuICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICBhc3NldElkOiBgYSR7YXdhaXQgbmV4dHZhbChcImFzc2V0SWRcIil9YCxcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGB1c2VyIGFjY291bnQgbmVlZHMgdG8gYmUgc2V0dXAgZm9yICR7YWRkaXRpb24uZW1haWx9IGluICR7cGF5bG9hZC5uYW1lfWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXdhaXQgZGF0YS5zYXZlKCk7XG4gICAgfSxcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0eXBlRGVmcywgcmVzb2x2ZXJzIH07XG4iLCJ2YXIgbW9uZ29vc2UgPSByZXF1aXJlKFwibW9uZ29vc2VcIik7XG5cbmNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbmNvbnN0IGFzc2V0U2NoZW1hID0gbmV3IFNjaGVtYShcbiAge1xuICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgc2VjdGlvbjogeyB0eXBlOiBBcnJheSB9LFxuICAgIGZlYXR1cmVkVGl0bGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgZmVhdHVyZWRTdWJ0aXRsZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBqd3RQYXNzd29yZDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBwcm9kdWN0aW9uTW9kZTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIGFzc2V0SWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgaGVybzogeyB0eXBlOiBPYmplY3QgfSxcbiAgfSxcbiAgeyB0aW1lc3RhbXBzOiB0cnVlIH1cbik7XG5cbmNvbnN0IGFzc2V0Q29sbGVjdGlvbiA9IFwiYXNzZXRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7IGFzc2V0U2NoZW1hLCBhc3NldENvbGxlY3Rpb24gfTtcbiIsImNvbnN0IHsgZ3FsLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlKFwiYXBvbGxvLXNlcnZlci1leHByZXNzXCIpO1xuY29uc3QgR3JhcGhRTEpTT04gPSByZXF1aXJlKFwiZ3JhcGhxbC10eXBlLWpzb25cIik7XG5cbmNvbnN0IHR5cGVEZWZzID0gZ3FsYFxuICBzY2FsYXIgSlNPTlxuYDtcblxuY29uc3QgcmVzb2x2ZXJzID0ge1xuICBKU09OOiBHcmFwaFFMSlNPTixcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0eXBlRGVmcywgcmVzb2x2ZXJzIH07XG4iLCJjb25zdCB7IGdxbCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcbmNvbnN0IHtcbiAgcG9zdENvbW1lbnRGZWVkYmFja1NjaGVtYSxcbiAgcG9zdENvbW1lbnRGZWVkYmFja0NvbGxlY3Rpb24sXG59ID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG5jb25zdCB7IHBvc3RDb21tZW50U2NoZW1hLCBwb3N0Q29tbWVudENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi9tb2RlbFwiKTtcbmNvbnN0IHsgZ2V0Q29sbGVjdGlvbiB9ID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2xpYi9kYnV0aWxzXCIpO1xuXG5jb25zdCB0eXBlRGVmcyA9IGdxbGBcbiAgZXh0ZW5kIHR5cGUgUXVlcnkge1xuICAgIHBvc3RDb21tZW50RmVlZGJhY2soY29tbWVudElkOiBJRCEpOiBbUG9zdENvbW1lbnRGZWVkYmFja11cbiAgfVxuXG4gIGV4dGVuZCB0eXBlIE11dGF0aW9uIHtcbiAgICBhZGRQb3N0Q29tbWVudEZlZWRiYWNrKFxuICAgICAgY29tbWVudElkOiBTdHJpbmchXG4gICAgICB0eXBlOiBTdHJpbmchXG4gICAgKTogUG9zdENvbW1lbnRGZWVkYmFja1xuICAgIHJlbW92ZVBvc3RDb21tZW50RmVlZGJhY2soXG4gICAgICBjb21tZW50SWQ6IFN0cmluZyFcbiAgICAgIHR5cGU6IFN0cmluZyFcbiAgICApOiBQb3N0Q29tbWVudEZlZWRiYWNrXG4gIH1cblxuICB0eXBlIFBvc3RDb21tZW50RmVlZGJhY2sge1xuICAgIGlkOiBJRCFcbiAgICB0eXBlOiBTdHJpbmdcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIFBvc3RDb21tZW50IHtcbiAgICBmZWVkYmFjazogW1Bvc3RDb21tZW50RmVlZGJhY2tdXG4gIH1cbmA7XG5cbmNvbnN0IHJlc29sdmVycyA9IHtcbiAgUXVlcnk6IHtcbiAgICBwb3N0Q29tbWVudEZlZWRiYWNrOiBhc3luYyAoXywgeyBjb21tZW50SWQgfSwgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBwb3N0Q29tbWVudEZlZWRiYWNrQ29sbGVjdGlvbixcbiAgICAgICAgcG9zdENvbW1lbnRGZWVkYmFja1NjaGVtYVxuICAgICAgKTtcbiAgICAgIHJldHVybiBhd2FpdCBtb2RlbC5maW5kKHsgY29tbWVudElkOiBjb21tZW50SWQsIHVzZXJJZDogdXNlci51c2VySWQgfSk7XG4gICAgfSxcbiAgfSxcblxuICBQb3N0Q29tbWVudDoge1xuICAgIGZlZWRiYWNrOiB7XG4gICAgICByZXNvbHZlOiBhc3luYyAocGFyZW50LCBfYXJncywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgICBcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgIHBvc3RDb21tZW50RmVlZGJhY2tDb2xsZWN0aW9uLFxuICAgICAgICAgIHBvc3RDb21tZW50RmVlZGJhY2tTY2hlbWFcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmQoeyBjb21tZW50SWQ6IHBhcmVudC5pZCwgdXNlcklkOiB1c2VyLnVzZXJJZCB9KTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcblxuICBNdXRhdGlvbjoge1xuICAgIGFkZFBvc3RDb21tZW50RmVlZGJhY2s6IGFzeW5jIChfLCBhcmdzLCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIHBvc3RDb21tZW50RmVlZGJhY2tDb2xsZWN0aW9uLFxuICAgICAgICBwb3N0Q29tbWVudEZlZWRiYWNrU2NoZW1hXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5maW5kT25lQW5kVXBkYXRlKFxuICAgICAgICB7IGNvbW1lbnRJZDogYXJncy5jb21tZW50SWQsIHVzZXJJZDogdXNlci51c2VySWQsIHR5cGU6IGFyZ3MudHlwZSB9LFxuICAgICAgICB7IGNvbW1lbnRJZDogYXJncy5jb21tZW50SWQsIHVzZXJJZDogdXNlci51c2VySWQsIHR5cGU6IGFyZ3MudHlwZSB9LFxuICAgICAgICB7IHVwc2VydDogdHJ1ZSwgbmV3OiB0cnVlLCByYXdSZXN1bHQ6IHRydWUgfVxuICAgICAgKTtcbiAgICAgIGlmICghcmVzcG9uc2UubGFzdEVycm9yT2JqZWN0LnVwZGF0ZWRFeGlzdGluZykge1xuICAgICAgICBjb25zdCBwb3N0Q29tbWVudE1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgICBhc3NldCxcbiAgICAgICAgICBwb3N0Q29tbWVudENvbGxlY3Rpb24sXG4gICAgICAgICAgcG9zdENvbW1lbnRTY2hlbWFcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgcG9zdENvbW1lbnRNb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShcbiAgICAgICAgICBhcmdzLmNvbW1lbnRJZCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAkaW5jOiB7IFthcmdzLnR5cGVdOiAxIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG5ldzogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UudmFsdWU7XG4gICAgfSxcbiAgICByZW1vdmVQb3N0Q29tbWVudEZlZWRiYWNrOiBhc3luYyAoXywgYXJncywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBwb3N0Q29tbWVudEZlZWRiYWNrQ29sbGVjdGlvbixcbiAgICAgICAgcG9zdENvbW1lbnRGZWVkYmFja1NjaGVtYVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZmluZE9uZUFuZERlbGV0ZShcbiAgICAgICAgeyBjb21tZW50SWQ6IGFyZ3MuY29tbWVudElkLCB1c2VySWQ6IHVzZXIudXNlcklkLCB0eXBlOiBhcmdzLnR5cGUgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJhd1Jlc3VsdDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5sYXN0RXJyb3JPYmplY3QubiA+IDApIHtcbiAgICAgICAgY29uc3QgcG9zdENvbW1lbnRNb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgICAgYXNzZXQsXG4gICAgICAgICAgcG9zdENvbW1lbnRDb2xsZWN0aW9uLFxuICAgICAgICAgIHBvc3RDb21tZW50U2NoZW1hXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHBvc3RDb21tZW50TW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgICAgYXJncy5jb21tZW50SWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgJGluYzogeyBbYXJncy50eXBlXTogLTEgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgbmV3OiB0cnVlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS52YWx1ZTtcbiAgICB9LFxuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHR5cGVEZWZzLCByZXNvbHZlcnMgfTtcbiIsInZhciBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG5cbmNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbmNvbnN0IHBvc3RDb21tZW50RmVlZGJhY2tTY2hlbWEgPSBuZXcgU2NoZW1hKFxuICB7XG4gICAgY29tbWVudElkOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHR5cGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdXNlcklkOiB7IHR5cGU6IFN0cmluZyB9LFxuICB9LFxuICB7IHRpbWVzdGFtcHM6IHRydWUgfVxuKTtcblxuY29uc3QgcG9zdENvbW1lbnRGZWVkYmFja0NvbGxlY3Rpb24gPSAncG9zdC5jb21tZW50LmZlZWRiYWNrJztcblxubW9kdWxlLmV4cG9ydHMgPSB7IHBvc3RDb21tZW50RmVlZGJhY2tTY2hlbWEsIHBvc3RDb21tZW50RmVlZGJhY2tDb2xsZWN0aW9uIH07XG4iLCJjb25zdCB7IGdxbCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcbmNvbnN0IHsgcG9zdENvbW1lbnRTY2hlbWEsIHBvc3RDb21tZW50Q29sbGVjdGlvbiB9ID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG5jb25zdCB7IHBvc3RTY2hlbWEsIHBvc3RDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vbW9kZWxcIik7XG5jb25zdCB7IGdldENvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvZGJ1dGlsc1wiKTtcblxuY29uc3QgdHlwZURlZnMgPSBncWxgXG4gIGV4dGVuZCB0eXBlIFF1ZXJ5IHtcbiAgICBwb3N0Q29tbWVudHMoXG4gICAgICBwb3N0SWQ6IFN0cmluZyFcbiAgICAgIHBhZ2VTaXplOiBJbnRcbiAgICAgIHBhZ2VObzogSW50XG4gICAgKTogUG9zdENvbW1lbnRQYWdpbmF0ZWRcbiAgICBwb3N0Q29tbWVudChpZDogSUQhKTogUG9zdENvbW1lbnRcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIE11dGF0aW9uIHtcbiAgICB1cGRhdGVQb3N0Q29tbWVudChwYXlsb2FkOiBQb3N0Q29tbWVudFBheWxvYWQhKTogUG9zdENvbW1lbnRcbiAgICBtYXJrUG9zdENvbW1lbnRBc0Fuc3dlcihpZDogSUQhKTogUG9zdENvbW1lbnRcbiAgICB1bm1hcmtQb3N0Q29tbWVudEFzQW5zd2VyKGlkOiBJRCEpOiBQb3N0Q29tbWVudFxuICB9XG5cbiAgdHlwZSBQb3N0Q29tbWVudFBhZ2luYXRlZCB7XG4gICAgcGFnZU5vOiBJbnRcbiAgICBoYXNNb3JlOiBCb29sZWFuXG4gICAgdG90YWw6IEludFxuICAgIHJlc3VsdHM6IFtQb3N0Q29tbWVudF0hXG4gIH1cblxuICBpbnB1dCBQb3N0Q29tbWVudFBheWxvYWQge1xuICAgIGlkOiBJRFxuICAgIHRleHQ6IFN0cmluZ1xuICAgIHBhcmVudElkOiBTdHJpbmdcbiAgICBwb3N0SWQ6IFN0cmluZyFcbiAgfVxuXG4gIHR5cGUgUG9zdENvbW1lbnQge1xuICAgIGlkOiBJRCFcbiAgICB0ZXh0OiBTdHJpbmdcbiAgICBwYXJlbnRJZDogU3RyaW5nXG4gICAgaGVscGZ1bDogSW50XG4gICAgbm90SGVscGZ1bDogSW50XG4gICAgaXNBbnN3ZXI6IEJvb2xlYW5cbiAgICBjcmVhdGVkQnk6IFN0cmluZ1xuICAgIHVwZGF0ZWRCeTogU3RyaW5nXG4gICAgY3JlYXRlZEF0OiBEYXRlU2NhbGFyXG4gICAgdXBkYXRlZEF0OiBEYXRlU2NhbGFyXG4gIH1cblxuICBleHRlbmQgdHlwZSBQb3N0Q29tbWVudEZlZWRiYWNrIHtcbiAgICBwb3N0Q29tbWVudDogUG9zdENvbW1lbnRcbiAgfVxuYDtcblxuY29uc3QgcmVzb2x2ZXJzID0ge1xuICBRdWVyeToge1xuICAgIHBvc3RDb21tZW50czogYXN5bmMgKFxuICAgICAgXyxcbiAgICAgIHsgcG9zdElkLCBwYWdlU2l6ZSA9IDAsIHBhZ2VObyA9IDAgfSxcbiAgICAgIHsgYXNzZXQsIHVzZXIgfVxuICAgICkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgcG9zdENvbW1lbnRDb2xsZWN0aW9uLFxuICAgICAgICBwb3N0Q29tbWVudFNjaGVtYVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWxcbiAgICAgICAgLmZpbmQoeyBwb3N0SWQ6IHBvc3RJZCB9KVxuICAgICAgICAvLyAuc29ydCh7IHJvb3RQYXJlbnRJZDogMSwgcGFyZW50SWQ6IDEsIGNyZWF0ZWRBdDogMSB9KVxuICAgICAgICAuc29ydCh7IGlzQW5zd2VyOiAtMSB9KVxuICAgICAgICAuc29ydCh7IGNyZWF0ZWRBdDogMSB9KVxuICAgICAgICAuc2tpcChwYWdlTm8gKiBwYWdlU2l6ZSlcbiAgICAgICAgLmxpbWl0KHBhZ2VTaXplKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdHM6IHJlc3BvbnNlLFxuICAgICAgICBwYWdlTm86IHJlc3BvbnNlLmxlbmd0aCA9PT0gcGFnZVNpemUgPyBwYWdlTm8gKyAxIDogcGFnZU5vLFxuICAgICAgICBoYXNNb3JlOiByZXNwb25zZS5sZW5ndGggPT09IHBhZ2VTaXplID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9LFxuICAgIHBvc3RDb21tZW50OiBhc3luYyAoXywgeyBpZCB9LCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIHBvc3RDb21tZW50Q29sbGVjdGlvbixcbiAgICAgICAgcG9zdENvbW1lbnRTY2hlbWFcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZEJ5SWQoaWQpO1xuICAgIH0sXG4gIH0sXG5cbiAgUG9zdENvbW1lbnRGZWVkYmFjazoge1xuICAgIHBvc3RDb21tZW50OiBhc3luYyAocGFyZW50LCBfLCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIHBvc3RDb21tZW50Q29sbGVjdGlvbixcbiAgICAgICAgcG9zdENvbW1lbnRTY2hlbWFcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZEJ5SWQocGFyZW50LmNvbW1lbnRJZCk7XG4gICAgfSxcbiAgfSxcblxuICBNdXRhdGlvbjoge1xuICAgIHVwZGF0ZVBvc3RDb21tZW50OiBhc3luYyAoXywgeyBwYXlsb2FkIH0sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgcG9zdENvbW1lbnRDb2xsZWN0aW9uLFxuICAgICAgICBwb3N0Q29tbWVudFNjaGVtYVxuICAgICAgKTtcblxuICAgICAgbGV0IGlkID0gcGF5bG9hZC5pZDtcblxuICAgICAgaWYgKCFwYXlsb2FkLmlkKSB7XG4gICAgICAgIGNvbnN0IHBvc3RNb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RDb2xsZWN0aW9uLCBwb3N0U2NoZW1hKTtcbiAgICAgICAgYXdhaXQgcG9zdE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICAgIHBheWxvYWQucG9zdElkLFxuICAgICAgICAgIHsgJGluYzogeyBjb21tZW50czogMSB9IH0sXG4gICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5ldyBtb2RlbCh7XG4gICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICBjcmVhdGVkQnk6IHVzZXIudXNlcklkLFxuICAgICAgICB9KS5zYXZlKCk7XG4gICAgICAgIGlkID0gcmVzcG9uc2UuaWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudEZpZWxkcyA9IHsgcGFyZW50SWQ6IHBheWxvYWQucGFyZW50SWQgfHwgaWQgfTtcbiAgICAgIGlmICghcGF5bG9hZC5pZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRDb21tZW50ID0gYXdhaXQgbW9kZWwuZmluZEJ5SWQocGF5bG9hZC5wYXJlbnRJZCk7XG4gICAgICAgIGlmIChwYXJlbnRDb21tZW50KSB7XG4gICAgICAgICAgcGFyZW50RmllbGRzLnJvb3RQYXJlbnRJZCA9IHBhcmVudENvbW1lbnQucm9vdFBhcmVudElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcmVudEZpZWxkcy5yb290UGFyZW50SWQgPSBwYXJlbnRGaWVsZHMucGFyZW50SWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICBpZCxcbiAgICAgICAge1xuICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgLi4ucGFyZW50RmllbGRzLFxuICAgICAgICAgIHVwZGF0ZWRCeTogdXNlci51c2VySWQsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBtYXJrUG9zdENvbW1lbnRBc0Fuc3dlcjogYXN5bmMgKF8sIHsgaWQgfSwgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBwb3N0Q29tbWVudENvbGxlY3Rpb24sXG4gICAgICAgIHBvc3RDb21tZW50U2NoZW1hXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICBpZCxcbiAgICAgICAge1xuICAgICAgICAgIGlzQW5zd2VyOiB0cnVlLFxuICAgICAgICAgIHVwZGF0ZWRCeTogdXNlci51c2VySWQsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IG1vZGVsLnVwZGF0ZU1hbnkoXG4gICAgICAgIHsgJGFuZDogW3sgcG9zdElkOiByZXNwb25zZS5wb3N0SWQgfSwgeyBfaWQ6IHsgJG5lOiBpZCB9IH1dIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAkc2V0OiB7XG4gICAgICAgICAgICBpc0Fuc3dlcjogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5ldzogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcG9zdE1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgcG9zdENvbGxlY3Rpb24sIHBvc3RTY2hlbWEpO1xuICAgICAgYXdhaXQgcG9zdE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICByZXNwb25zZS5wb3N0SWQsXG4gICAgICAgIHsgaXNBbnN3ZXJlZDogdHJ1ZSwgYW5zd2VyZWRPbjogbmV3IERhdGUoKSB9LFxuICAgICAgICB7IG5ldzogdHJ1ZSB9XG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcbiAgICB1bm1hcmtQb3N0Q29tbWVudEFzQW5zd2VyOiBhc3luYyAoXywgeyBpZCB9LCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIHBvc3RDb21tZW50Q29sbGVjdGlvbixcbiAgICAgICAgcG9zdENvbW1lbnRTY2hlbWFcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgIGlkLFxuICAgICAgICB7XG4gICAgICAgICAgaXNBbnN3ZXI6IGZhbHNlLFxuICAgICAgICAgIHVwZGF0ZWRCeTogdXNlci51c2VySWQsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuZXc6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHBvc3RNb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RDb2xsZWN0aW9uLCBwb3N0U2NoZW1hKTtcbiAgICAgIGF3YWl0IHBvc3RNb2RlbC5maW5kQnlJZEFuZFVwZGF0ZShcbiAgICAgICAgcmVzcG9uc2UucG9zdElkLFxuICAgICAgICB7IGlzQW5zd2VyZWQ6IGZhbHNlLCBhbnN3ZXJlZE9uOiBudWxsIH0sXG4gICAgICAgIHsgbmV3OiB0cnVlIH1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9LFxuICB9LFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHR5cGVEZWZzLCByZXNvbHZlcnMgfTtcbiIsInZhciBtb25nb29zZSA9IHJlcXVpcmUoJ21vbmdvb3NlJyk7XG5cbmNvbnN0IFNjaGVtYSA9IG1vbmdvb3NlLlNjaGVtYTtcbmNvbnN0IHBvc3RDb21tZW50U2NoZW1hID0gbmV3IFNjaGVtYShcbiAge1xuICAgIHRleHQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgcGFyZW50SWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgcm9vdFBhcmVudElkOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHBvc3RJZDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBoZWxwZnVsOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMCB9LFxuICAgIG5vdEhlbHBmdWw6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAwIH0sXG4gICAgaXNBbnN3ZXI6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICBjcmVhdGVkQnk6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdXBkYXRlZEJ5OiB7IHR5cGU6IFN0cmluZyB9LFxuICB9LFxuICB7IHRpbWVzdGFtcHM6IHRydWUgfVxuKTtcblxuY29uc3QgcG9zdENvbW1lbnRDb2xsZWN0aW9uID0gJ3Bvc3QuY29tbWVudCc7XG5cbi8vIG1vZHVsZS5leHBvcnRzID0gbW9uZ29vc2UubW9kZWwoJ2Jvb2ttYXJrcycsIHBvc3RTY2hlbWEpO1xubW9kdWxlLmV4cG9ydHMgPSB7IHBvc3RDb21tZW50U2NoZW1hLCBwb3N0Q29tbWVudENvbGxlY3Rpb24gfTtcbiIsImNvbnN0IHsgZ3FsLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlKFwiYXBvbGxvLXNlcnZlci1leHByZXNzXCIpO1xuY29uc3QgeyBwb3N0RmVlZGJhY2tTY2hlbWEsIHBvc3RGZWVkYmFja0NvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuY29uc3QgeyBwb3N0U2NoZW1hLCBwb3N0Q29sbGVjdGlvbiB9ID0gcmVxdWlyZShcIi4uL21vZGVsXCIpO1xuY29uc3QgeyBnZXRDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIik7XG5cbmNvbnN0IHR5cGVEZWZzID0gZ3FsYFxuICBleHRlbmQgdHlwZSBRdWVyeSB7XG4gICAgcG9zdEZlZWRiYWNrKHBvc3RJZDogSUQhKTogW1Bvc3RGZWVkYmFja11cbiAgfVxuXG4gIGV4dGVuZCB0eXBlIE11dGF0aW9uIHtcbiAgICBhZGRQb3N0RmVlZGJhY2socG9zdElkOiBTdHJpbmchLCB0eXBlOiBTdHJpbmchKTogUG9zdEZlZWRiYWNrXG4gICAgcmVtb3ZlUG9zdEZlZWRiYWNrKHBvc3RJZDogU3RyaW5nISwgdHlwZTogU3RyaW5nISk6IFBvc3RGZWVkYmFja1xuICB9XG5cbiAgdHlwZSBQb3N0RmVlZGJhY2sge1xuICAgIGlkOiBJRCFcbiAgICB0eXBlOiBTdHJpbmdcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIFBvc3Qge1xuICAgIGZlZWRiYWNrOiBbUG9zdEZlZWRiYWNrXVxuICB9XG5gO1xuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gIFF1ZXJ5OiB7XG4gICAgcG9zdEZlZWRiYWNrOiBhc3luYyAoXywgeyBwb3N0SWQgfSwgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBwb3N0RmVlZGJhY2tDb2xsZWN0aW9uLFxuICAgICAgICBwb3N0RmVlZGJhY2tTY2hlbWFcbiAgICAgICk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZCh7IHBvc3RJZDogcG9zdElkLCB1c2VySWQ6IHVzZXIudXNlcklkIH0pO1xuICAgIH0sXG4gIH0sXG5cbiAgUG9zdDoge1xuICAgIGZlZWRiYWNrOiB7XG4gICAgICByZXNvbHZlOiBhc3luYyAocGFyZW50LCBfYXJncywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXG4gICAgICAgICAgICBcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgIHBvc3RGZWVkYmFja0NvbGxlY3Rpb24sXG4gICAgICAgICAgcG9zdEZlZWRiYWNrU2NoZW1hXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhd2FpdCBtb2RlbC5maW5kKHsgcG9zdElkOiBwYXJlbnQuaWQsIHVzZXJJZDogdXNlci51c2VySWQgfSk7XG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG5cbiAgTXV0YXRpb246IHtcbiAgICBhZGRQb3N0RmVlZGJhY2s6IGFzeW5jIChfLCBhcmdzLCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIHBvc3RGZWVkYmFja0NvbGxlY3Rpb24sXG4gICAgICAgIHBvc3RGZWVkYmFja1NjaGVtYVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZmluZE9uZUFuZFVwZGF0ZShcbiAgICAgICAgeyBwb3N0SWQ6IGFyZ3MucG9zdElkLCB1c2VySWQ6IHVzZXIudXNlcklkLCB0eXBlOiBhcmdzLnR5cGUgfSxcbiAgICAgICAgeyBwb3N0SWQ6IGFyZ3MucG9zdElkLCB1c2VySWQ6IHVzZXIudXNlcklkLCB0eXBlOiBhcmdzLnR5cGUgfSxcbiAgICAgICAgeyB1cHNlcnQ6IHRydWUsIG5ldzogdHJ1ZSwgcmF3UmVzdWx0OiB0cnVlIH1cbiAgICAgICk7XG4gICAgICBpZiAoIXJlc3BvbnNlLmxhc3RFcnJvck9iamVjdC51cGRhdGVkRXhpc3RpbmcpIHtcbiAgICAgICAgY29uc3QgcG9zdE1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgcG9zdENvbGxlY3Rpb24sIHBvc3RTY2hlbWEpO1xuICAgICAgICBhd2FpdCBwb3N0TW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgICAgYXJncy5wb3N0SWQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgJGluYzogeyBbYXJncy50eXBlXTogMSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnZhbHVlO1xuICAgIH0sXG4gICAgcmVtb3ZlUG9zdEZlZWRiYWNrOiBhc3luYyAoXywgYXJncywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oXG4gICAgICAgIGFzc2V0LFxuICAgICAgICBwb3N0RmVlZGJhY2tDb2xsZWN0aW9uLFxuICAgICAgICBwb3N0RmVlZGJhY2tTY2hlbWFcbiAgICAgICk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsLmZpbmRPbmVBbmREZWxldGUoXG4gICAgICAgIHsgcG9zdElkOiBhcmdzLnBvc3RJZCwgdXNlcklkOiB1c2VyLnVzZXJJZCwgdHlwZTogYXJncy50eXBlIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByYXdSZXN1bHQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2UubGFzdEVycm9yT2JqZWN0Lm4gPiAwKSB7XG4gICAgICAgIGNvbnN0IHBvc3RNb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RDb2xsZWN0aW9uLCBwb3N0U2NoZW1hKTtcbiAgICAgICAgYXdhaXQgcG9zdE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICAgIGFyZ3MucG9zdElkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICRpbmM6IHsgW2FyZ3MudHlwZV06IC0xIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG5ldzogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UudmFsdWU7XG4gICAgfSxcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0eXBlRGVmcywgcmVzb2x2ZXJzIH07XG4iLCJ2YXIgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuXG5jb25zdCBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG5jb25zdCBwb3N0RmVlZGJhY2tTY2hlbWEgPSBuZXcgU2NoZW1hKFxuICB7XG4gICAgcG9zdElkOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIHR5cGU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdXNlcklkOiB7IHR5cGU6IFN0cmluZyB9LFxuICB9LFxuICB7IHRpbWVzdGFtcHM6IHRydWUgfVxuKTtcblxuY29uc3QgcG9zdEZlZWRiYWNrQ29sbGVjdGlvbiA9ICdwb3N0LmZlZWRiYWNrJztcblxubW9kdWxlLmV4cG9ydHMgPSB7IHBvc3RGZWVkYmFja1NjaGVtYSwgcG9zdEZlZWRiYWNrQ29sbGVjdGlvbiB9O1xuIiwiY29uc3QgeyBncWwsIEF1dGhlbnRpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyLWV4cHJlc3NcIik7XG5jb25zdCB7IHBvc3RGb2xsb3dlclNjaGVtYSwgcG9zdEZvbGxvd2VyQ29sbGVjdGlvbiB9ID0gcmVxdWlyZShcIi4vbW9kZWxcIik7XG5jb25zdCB7IHBvc3RTY2hlbWEsIHBvc3RDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi8uLi9tb2RlbFwiKTtcbmNvbnN0IHsgZ2V0Q29sbGVjdGlvbiB9ID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9kYnV0aWxzXCIpO1xuXG5jb25zdCB0eXBlRGVmcyA9IGdxbGBcbiAgdHlwZSBQb3N0Rm9sbG93ZXIge1xuICAgIGlkOiBJRCFcbiAgICB1c2VySWQ6IFN0cmluZ1xuICAgIHBvc3RJZDogU3RyaW5nXG4gIH1cblxuICBleHRlbmQgdHlwZSBQb3N0IHtcbiAgICBmb2xsb3dlckxpc3Q6IFtQb3N0Rm9sbG93ZXJdXG4gIH1cblxuICBleHRlbmQgdHlwZSBNdXRhdGlvbiB7XG4gICAgZm9sbG93UG9zdChwb3N0SWQ6IFN0cmluZyEpOiBQb3N0Rm9sbG93ZXJcbiAgICB1bmZvbGxvd1Bvc3QocG9zdElkOiBTdHJpbmchKTogUG9zdEZvbGxvd2VyXG4gIH1cbmA7XG5cbmNvbnN0IHJlc29sdmVycyA9IHtcbiAgUG9zdDoge1xuICAgIGZvbGxvd2VyTGlzdDoge1xuICAgICAgcmVzb2x2ZTogYXN5bmMgKHBhcmVudCwgX2FyZ3MsIHsgYXNzZXQsIHVzZXIgfSwgaW5mbykgPT4ge1xuICAgICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFxuICAgICAgICAgICAgXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgICBhc3NldCxcbiAgICAgICAgICBwb3N0Rm9sbG93ZXJDb2xsZWN0aW9uLFxuICAgICAgICAgIHBvc3RGb2xsb3dlclNjaGVtYVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZCh7IHBvc3RJZDogcGFyZW50LmlkIH0pO1xuICAgICAgfSxcbiAgICB9LFxuICB9LFxuXG4gIE11dGF0aW9uOiB7XG4gICAgZm9sbG93UG9zdDogYXN5bmMgKF8sIGFyZ3MsIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKFxuICAgICAgICBhc3NldCxcbiAgICAgICAgcG9zdEZvbGxvd2VyQ29sbGVjdGlvbixcbiAgICAgICAgcG9zdEZvbGxvd2VyU2NoZW1hXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5maW5kT25lQW5kVXBkYXRlKFxuICAgICAgICB7IHBvc3RJZDogYXJncy5wb3N0SWQsIHVzZXJJZDogdXNlci51c2VySWQgfSxcbiAgICAgICAgeyBwb3N0SWQ6IGFyZ3MucG9zdElkLCB1c2VySWQ6IHVzZXIudXNlcklkIH0sXG4gICAgICAgIHsgdXBzZXJ0OiB0cnVlLCBuZXc6IHRydWUsIHJhd1Jlc3VsdDogdHJ1ZSB9XG4gICAgICApO1xuICAgICAgaWYgKCFyZXNwb25zZS5sYXN0RXJyb3JPYmplY3QudXBkYXRlZEV4aXN0aW5nKSB7XG4gICAgICAgIGNvbnN0IHBvc3RNb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RDb2xsZWN0aW9uLCBwb3N0U2NoZW1hKTtcbiAgICAgICAgYXdhaXQgcG9zdE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICAgIGFyZ3MucG9zdElkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICRpbmM6IHsgZm9sbG93ZXJzOiAxIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IG5ldzogdHJ1ZSB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UudmFsdWU7XG4gICAgfSxcbiAgICB1bmZvbGxvd1Bvc3Q6IGFzeW5jIChfLCBhcmdzLCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIHBvc3RGb2xsb3dlckNvbGxlY3Rpb24sXG4gICAgICAgIHBvc3RGb2xsb3dlclNjaGVtYVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZmluZE9uZUFuZERlbGV0ZShcbiAgICAgICAgeyBwb3N0SWQ6IGFyZ3MucG9zdElkLCB1c2VySWQ6IHVzZXIudXNlcklkIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByYXdSZXN1bHQ6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2UubGFzdEVycm9yT2JqZWN0Lm4gPiAwKSB7XG4gICAgICAgIGNvbnN0IHBvc3RNb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RDb2xsZWN0aW9uLCBwb3N0U2NoZW1hKTtcbiAgICAgICAgYXdhaXQgcG9zdE1vZGVsLmZpbmRCeUlkQW5kVXBkYXRlKFxuICAgICAgICAgIGFyZ3MucG9zdElkLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgICRpbmM6IHsgZm9sbG93ZXJzOiAtMSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnZhbHVlO1xuICAgIH0sXG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgdHlwZURlZnMsIHJlc29sdmVycyB9O1xuIiwidmFyIG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcblxuY29uc3QgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xuY29uc3QgcG9zdEZvbGxvd2VyU2NoZW1hID0gbmV3IFNjaGVtYShcbiAge1xuICAgIHBvc3RJZDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB1c2VySWQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gIH0sXG4gIHsgdGltZXN0YW1wczogdHJ1ZSB9XG4pO1xuXG5jb25zdCBwb3N0Rm9sbG93ZXJDb2xsZWN0aW9uID0gJ3Bvc3QuZm9sbG93ZXInO1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IG1vbmdvb3NlLm1vZGVsKCdib29rbWFya3MnLCBwb3N0U2NoZW1hKTtcbm1vZHVsZS5leHBvcnRzID0geyBwb3N0Rm9sbG93ZXJTY2hlbWEsIHBvc3RGb2xsb3dlckNvbGxlY3Rpb24gfTtcbiIsImNvbnN0IHsgZ3FsLCBBdXRoZW50aWNhdGlvbkVycm9yIH0gPSByZXF1aXJlKFwiYXBvbGxvLXNlcnZlci1leHByZXNzXCIpO1xuY29uc3QgeyBHcmFwaFFMU2NhbGFyVHlwZSB9ID0gcmVxdWlyZShcImdyYXBocWxcIik7XG5jb25zdCB7IHBvc3RTY2hlbWEsIHBvc3RDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbmNvbnN0IHsgcG9zdFRhZ1NjaGVtYSwgcG9zdFRhZ0NvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuL3RhZy9tb2RlbFwiKTtcbmNvbnN0IHtcbiAgcG9zdEZvbGxvd2VyU2NoZW1hLFxuICBwb3N0Rm9sbG93ZXJDb2xsZWN0aW9uLFxufSA9IHJlcXVpcmUoXCIuL2ZvbGxvd2VyL21vZGVsXCIpO1xuY29uc3QgeyBnZXRDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vLi4vbGliL2RidXRpbHNcIik7XG5cbmNvbnN0IHR5cGVEZWZzID0gZ3FsYFxuICBleHRlbmQgdHlwZSBRdWVyeSB7XG4gICAgcG9zdChpZDogSUQhKTogUG9zdFxuICAgIHBvc3RzKHBhZ2VTaXplOiBJbnQsIHBhZ2VObzogSW50KTogUG9zdFBhZ2luYXRlZFxuICAgIHNlYXJjaFBvc3RzKHRleHQ6IFN0cmluZywgcGFnZVNpemU6IEludCwgcGFnZU5vOiBJbnQpOiBQb3N0UGFnaW5hdGVkXG4gICAgbXlQb3N0cyhwYWdlU2l6ZTogSW50LCBwYWdlTm86IEludCk6IFBvc3RQYWdpbmF0ZWRcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIE11dGF0aW9uIHtcbiAgICBhZGRQb3N0KHBheWxvYWQ6IFBvc3RQYXlsb2FkKTogUG9zdFxuICAgIGRlbGV0ZVBvc3QoaWQ6IElEISk6IFBvc3RcbiAgfVxuXG4gIGlucHV0IFBvc3RQYXlsb2FkIHtcbiAgICBpZDogU3RyaW5nXG4gICAgdGl0bGU6IFN0cmluZ1xuICAgIGRlc2NyaXB0aW9uOiBTdHJpbmdcbiAgICBhZGRUYWdzOiBbU3RyaW5nXVxuICAgIHJlbW92ZVRhZ3M6IFtTdHJpbmddXG4gIH1cblxuICB0eXBlIFBvc3RQYWdpbmF0ZWQge1xuICAgIHBhZ2VObzogSW50XG4gICAgaGFzTW9yZTogQm9vbGVhblxuICAgIHRvdGFsOiBJbnRcbiAgICByZXN1bHRzOiBbUG9zdF0hXG4gIH1cblxuICB0eXBlIFBvc3Qge1xuICAgIGlkOiBJRCFcbiAgICB0aXRsZTogU3RyaW5nXG4gICAgZGVzY3JpcHRpb246IFN0cmluZ1xuICAgIHZpZXdzOiBJbnQhXG4gICAgY29tbWVudHM6IEludCFcbiAgICBpc0Fuc3dlcmVkOiBCb29sZWFuIVxuICAgIGFuc3dlcmVkT246IERhdGVTY2FsYXJcbiAgICBmb2xsb3dlcnM6IEludCFcbiAgICBoZWxwZnVsOiBJbnQhXG4gICAgbm90SGVscGZ1bDogSW50IVxuICAgIGNyZWF0ZWRBdDogRGF0ZVNjYWxhclxuICAgIHVwZGF0ZWRBdDogRGF0ZVNjYWxhclxuICAgIGNyZWF0ZWRCeTogU3RyaW5nXG4gICAgdXBkYXRlZEJ5OiBTdHJpbmdcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIFBvc3RGZWVkYmFjayB7XG4gICAgcG9zdDogUG9zdFxuICB9XG4gIGV4dGVuZCB0eXBlIFBvc3RUYWcge1xuICAgIHBvc3Q6IFBvc3RcbiAgfVxuICBleHRlbmQgdHlwZSBQb3N0Rm9sbG93ZXIge1xuICAgIHBvc3Q6IFBvc3RcbiAgfVxuICBleHRlbmQgdHlwZSBQb3N0Q29tbWVudCB7XG4gICAgcG9zdDogUG9zdFxuICB9XG5gO1xuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gIFF1ZXJ5OiB7XG4gICAgcG9zdDogYXN5bmMgKF8sIHsgaWQgfSwgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBpZiAoIWFzc2V0IHx8ICF1c2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcIk5vdCBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGlzIGNvbnRlbnRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RDb2xsZWN0aW9uLCBwb3N0U2NoZW1hKTtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgIGlkLFxuICAgICAgICB7ICRpbmM6IHsgdmlld3M6IDEgfSB9LFxuICAgICAgICB7IG5ldzogdHJ1ZSB9XG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sXG4gICAgcG9zdHM6IGFzeW5jIChfLCB7IHBhZ2VTaXplID0gMCwgcGFnZU5vID0gMCB9LCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgcG9zdENvbGxlY3Rpb24sIHBvc3RTY2hlbWEpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtb2RlbFxuICAgICAgICAuZmluZCh7fSlcbiAgICAgICAgLnNraXAocGFnZU5vICogcGFnZVNpemUpXG4gICAgICAgIC5saW1pdChwYWdlU2l6ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXN1bHRzOiByZXNwb25zZSxcbiAgICAgICAgcGFnZU5vOiByZXNwb25zZS5sZW5ndGggPT09IHBhZ2VTaXplID8gcGFnZU5vICsgMSA6IHBhZ2VObyxcbiAgICAgICAgaGFzTW9yZTogcmVzcG9uc2UubGVuZ3RoID09PSBwYWdlU2l6ZSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBzZWFyY2hQb3N0czogYXN5bmMgKFxuICAgICAgXyxcbiAgICAgIHsgdGV4dCwgcGFnZVNpemUgPSAwLCBwYWdlTm8gPSAwIH0sXG4gICAgICB7IGFzc2V0LCB1c2VyIH1cbiAgICApID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgIHBhZ2VObzogMCxcbiAgICAgICAgICBoYXNNb3JlOiBmYWxzZSxcbiAgICAgICAgICB0b3RhbDogMCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgcG9zdENvbGxlY3Rpb24sIHBvc3RTY2hlbWEpO1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgbW9kZWxcbiAgICAgICAgLmZpbmQoe1xuICAgICAgICAgICRvcjogW1xuICAgICAgICAgICAgeyBkZXNjcmlwdGlvbjogeyAkcmVnZXg6IG5ldyBSZWdFeHAodGV4dCwgXCJpZ1wiKSB9IH0sXG4gICAgICAgICAgICB7IHRpdGxlOiB7ICRyZWdleDogbmV3IFJlZ0V4cCh0ZXh0LCBcImlnXCIpIH0gfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9KVxuICAgICAgICAuc2tpcChwYWdlTm8gKiBwYWdlU2l6ZSlcbiAgICAgICAgLmxpbWl0KHBhZ2VTaXplKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0czogcmVzLFxuICAgICAgICBwYWdlTm86IHJlcy5sZW5ndGggPT09IHBhZ2VTaXplID8gcGFnZU5vICsgMSA6IHBhZ2VObyxcbiAgICAgICAgaGFzTW9yZTogcmVzLmxlbmd0aCA9PT0gcGFnZVNpemUgPyB0cnVlIDogZmFsc2UsXG4gICAgICB9O1xuICAgIH0sXG4gICAgbXlQb3N0czogYXN5bmMgKF8sIHsgcGFnZVNpemUgPSAwLCBwYWdlTm8gPSAwIH0sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBwb3N0Q29sbGVjdGlvbiwgcG9zdFNjaGVtYSk7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBtb2RlbFxuICAgICAgICAuZmluZCh7XG4gICAgICAgICAgY3JlYXRlZEJ5OiB1c2VyLnVzZXJJZCxcbiAgICAgICAgfSlcbiAgICAgICAgLnNraXAocGFnZU5vICogcGFnZVNpemUpXG4gICAgICAgIC5saW1pdChwYWdlU2l6ZSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdHM6IHJlcyxcbiAgICAgICAgcGFnZU5vOiByZXMubGVuZ3RoID09PSBwYWdlU2l6ZSA/IHBhZ2VObyArIDEgOiBwYWdlTm8sXG4gICAgICAgIGhhc01vcmU6IHJlcy5sZW5ndGggPT09IHBhZ2VTaXplID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9LFxuICB9LFxuXG4gIFBvc3RGZWVkYmFjazoge1xuICAgIHBvc3Q6IGFzeW5jIChwYXJlbnQsIF8sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBwb3N0Q29sbGVjdGlvbiwgcG9zdFNjaGVtYSk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZEJ5SWQocGFyZW50LnBvc3RJZCk7XG4gICAgfSxcbiAgfSxcblxuICBQb3N0VGFnOiB7XG4gICAgcG9zdDogYXN5bmMgKHBhcmVudCwgXywgeyBhc3NldCwgdXNlciB9KSA9PiB7XG4gICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RDb2xsZWN0aW9uLCBwb3N0U2NoZW1hKTtcbiAgICAgIHJldHVybiBhd2FpdCBtb2RlbC5maW5kQnlJZChwYXJlbnQucG9zdElkKTtcbiAgICB9LFxuICB9LFxuXG4gIFBvc3RGb2xsb3dlcjoge1xuICAgIHBvc3Q6IGFzeW5jIChwYXJlbnQsIF8sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBwb3N0Q29sbGVjdGlvbiwgcG9zdFNjaGVtYSk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZEJ5SWQocGFyZW50LnBvc3RJZCk7XG4gICAgfSxcbiAgfSxcblxuICBQb3N0Q29tbWVudDoge1xuICAgIHBvc3Q6IGFzeW5jIChwYXJlbnQsIF8sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBwb3N0Q29sbGVjdGlvbiwgcG9zdFNjaGVtYSk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuZmluZEJ5SWQocGFyZW50LnBvc3RJZCk7XG4gICAgfSxcbiAgfSxcblxuICBNdXRhdGlvbjoge1xuICAgIGFkZFBvc3Q6IGFzeW5jIChfLCBhcmdzLCB7IGFzc2V0LCB1c2VyIH0pID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sbGVjdGlvbihhc3NldCwgcG9zdENvbGxlY3Rpb24sIHBvc3RTY2hlbWEpO1xuICAgICAgY29uc3QgdGFnTW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBwb3N0VGFnQ29sbGVjdGlvbiwgcG9zdFRhZ1NjaGVtYSk7XG4gICAgICBjb25zdCBmb2xsb3dlck1vZGVsID0gZ2V0Q29sbGVjdGlvbihcbiAgICAgICAgYXNzZXQsXG4gICAgICAgIHBvc3RGb2xsb3dlckNvbGxlY3Rpb24sXG4gICAgICAgIHBvc3RGb2xsb3dlclNjaGVtYVxuICAgICAgKTtcbiAgICAgIGxldCBwb3N0UmVzcG9uc2U7XG5cbiAgICAgIGlmIChhcmdzLnBheWxvYWQuaWQpIHtcbiAgICAgICAgZXhpc3RpbmdQb3N0ID0gYXdhaXQgbW9kZWwuZmluZEJ5SWQoYXJncy5wYXlsb2FkLmlkKTtcbiAgICAgICAgcG9zdFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZmluZEJ5SWRBbmRVcGRhdGUoXG4gICAgICAgICAgYXJncy5wYXlsb2FkLmlkLFxuICAgICAgICAgIHsgLi4uYXJncy5wYXlsb2FkLCB1cGRhdGVkQnk6IHVzZXIudXNlcklkIH0sXG4gICAgICAgICAgeyBuZXc6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBtb2RlbCh7XG4gICAgICAgICAgLi4uYXJncy5wYXlsb2FkLFxuICAgICAgICAgIGZvbGxvd2VyczogMSxcbiAgICAgICAgICBjcmVhdGVkQnk6IHVzZXIudXNlcklkLFxuICAgICAgICAgIHVwZGF0ZWRCeTogdXNlci51c2VySWQsXG4gICAgICAgIH0pO1xuICAgICAgICBwb3N0UmVzcG9uc2UgPSBhd2FpdCBkYXRhLnNhdmUoKTtcblxuICAgICAgICBhd2FpdCBmb2xsb3dlck1vZGVsLmZpbmRPbmVBbmRVcGRhdGUoXG4gICAgICAgICAgeyBwb3N0SWQ6IHBvc3RSZXNwb25zZS5pZCwgdXNlcklkOiB1c2VyLnVzZXJJZCB9LFxuICAgICAgICAgIHsgcG9zdElkOiBwb3N0UmVzcG9uc2UuaWQsIHVzZXJJZDogdXNlci51c2VySWQgfSxcbiAgICAgICAgICB7IHVwc2VydDogdHJ1ZSwgbmV3OiB0cnVlLCByYXdSZXN1bHQ6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBhcmdzLnBheWxvYWQuYWRkVGFncy5mb3JFYWNoKGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgdGFnTW9kZWwoe1xuICAgICAgICAgIG5hbWU6IGl0ZW0sXG4gICAgICAgICAgcG9zdElkOiBwb3N0UmVzcG9uc2UuX2lkLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgZGF0YS5zYXZlKCk7XG4gICAgICB9KTtcblxuICAgICAgYXJncy5wYXlsb2FkLnJlbW92ZVRhZ3MuZm9yRWFjaChhc3luYyAoaXRlbSkgPT4ge1xuICAgICAgICBhd2FpdCB0YWdNb2RlbC5kZWxldGVNYW55KHtcbiAgICAgICAgICBwb3N0SWQ6IHBvc3RSZXNwb25zZS5faWQsXG4gICAgICAgICAgbmFtZTogaXRlbSxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHBvc3RSZXNwb25zZTtcbiAgICB9LFxuICAgIGRlbGV0ZVBvc3Q6IGFzeW5jIChfLCB7IGlkIH0sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBwb3N0Q29sbGVjdGlvbiwgcG9zdFNjaGVtYSk7XG4gICAgICBjb25zdCB0YWdNb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RUYWdDb2xsZWN0aW9uLCBwb3N0VGFnU2NoZW1hKTtcblxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgbW9kZWwuZmluZEJ5SWRBbmREZWxldGUoaWQpO1xuXG4gICAgICBhd2FpdCB0YWdNb2RlbC5kZWxldGVNYW55KHtcbiAgICAgICAgcG9zdElkOiBpZCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gIH0sXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgdHlwZURlZnMsIHJlc29sdmVycyB9O1xuIiwidmFyIG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcblxuY29uc3QgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xuY29uc3QgcG9zdFNjaGVtYSA9IG5ldyBTY2hlbWEoXG4gIHtcbiAgICB0aXRsZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBkZXNjcmlwdGlvbjogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICB2aWV3czogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDAgfSxcbiAgICBpc0Fuc3dlcmVkOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0sXG4gICAgYW5zd2VyZWRPbjogeyB0eXBlOiBEYXRlIH0sXG4gICAgZm9sbG93ZXJzOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMCB9LFxuICAgIGNvbW1lbnRzOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMCB9LFxuICAgIGhlbHBmdWw6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAwIH0sXG4gICAgbm90SGVscGZ1bDogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDAgfSxcbiAgICBjcmVhdGVkQnk6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgdXBkYXRlZEJ5OiB7IHR5cGU6IFN0cmluZyB9LFxuICB9LFxuICB7IHRpbWVzdGFtcHM6IHRydWUgfVxuKTtcblxuY29uc3QgcG9zdENvbGxlY3Rpb24gPSAncG9zdCc7XG5cbi8vIG1vZHVsZS5leHBvcnRzID0gbW9uZ29vc2UubW9kZWwoJ2Jvb2ttYXJrcycsIHBvc3RTY2hlbWEpO1xubW9kdWxlLmV4cG9ydHMgPSB7IHBvc3RTY2hlbWEsIHBvc3RDb2xsZWN0aW9uIH07XG4iLCJjb25zdCB7IGdxbCwgQXV0aGVudGljYXRpb25FcnJvciB9ID0gcmVxdWlyZShcImFwb2xsby1zZXJ2ZXItZXhwcmVzc1wiKTtcbmNvbnN0IHsgcG9zdFRhZ1NjaGVtYSwgcG9zdFRhZ0NvbGxlY3Rpb24gfSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xuY29uc3QgeyBnZXRDb2xsZWN0aW9uIH0gPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2RidXRpbHNcIik7XG5cbmNvbnN0IHR5cGVEZWZzID0gZ3FsYFxuICBleHRlbmQgdHlwZSBRdWVyeSB7XG4gICAgcG9zdFRhZ0Nsb3VkOiBbUG9zdFRhZ0Nsb3VkXVxuICAgIHBvc3RzQnlUYWcodGFnOiBTdHJpbmchLCBwYWdlU2l6ZTogSW50LCBwYWdlTm86IEludCk6IFBvc3RUYWdQYWdpbmF0ZWRcbiAgfVxuXG4gIHR5cGUgUG9zdFRhZ1BhZ2luYXRlZCB7XG4gICAgcGFnZU5vOiBJbnRcbiAgICBoYXNNb3JlOiBCb29sZWFuXG4gICAgdG90YWw6IEludFxuICAgIHJlc3VsdHM6IFtQb3N0VGFnXSFcbiAgfVxuXG4gIHR5cGUgUG9zdFRhZ0Nsb3VkIHtcbiAgICBuYW1lOiBTdHJpbmdcbiAgICBjb3VudDogSW50XG4gIH1cblxuICB0eXBlIFBvc3RUYWcge1xuICAgIGlkOiBJRCFcbiAgICBuYW1lOiBTdHJpbmdcbiAgfVxuXG4gIGV4dGVuZCB0eXBlIFBvc3Qge1xuICAgIHRhZ3M6IFtQb3N0VGFnXVxuICB9XG5gO1xuXG5jb25zdCByZXNvbHZlcnMgPSB7XG4gIFF1ZXJ5OiB7XG4gICAgcG9zdFRhZ0Nsb3VkOiBhc3luYyAoXywgX18sIHsgYXNzZXQsIHVzZXIgfSkgPT4ge1xuICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoXCJOb3QgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhpcyBjb250ZW50XCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBwb3N0VGFnQ29sbGVjdGlvbiwgcG9zdFRhZ1NjaGVtYSk7XG4gICAgICByZXR1cm4gYXdhaXQgbW9kZWwuYWdncmVnYXRlKFtcbiAgICAgICAge1xuICAgICAgICAgICRncm91cDoge1xuICAgICAgICAgICAgX2lkOiBcIiRuYW1lXCIsXG4gICAgICAgICAgICBjb3VudDogeyAkc3VtOiAxIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICRwcm9qZWN0OiB7XG4gICAgICAgICAgICBuYW1lOiBcIiRfaWRcIixcbiAgICAgICAgICAgIGNvdW50OiBcIiRjb3VudFwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdKTtcbiAgICB9LFxuICAgIHBvc3RzQnlUYWc6IGFzeW5jIChcbiAgICAgIF8sXG4gICAgICB7IHRhZywgcGFnZVNpemUgPSAwLCBwYWdlTm8gPSAwIH0sXG4gICAgICB7IGFzc2V0LCB1c2VyIH1cbiAgICApID0+IHtcbiAgICAgIGlmICghYXNzZXQgfHwgIXVzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGFnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0czogW10sXG4gICAgICAgICAgcGFnZU5vOiAwLFxuICAgICAgICAgIGhhc01vcmU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKGFzc2V0LCBwb3N0VGFnQ29sbGVjdGlvbiwgcG9zdFRhZ1NjaGVtYSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1vZGVsXG4gICAgICAgIC5maW5kKHsgbmFtZTogdGFnIH0pXG4gICAgICAgIC5za2lwKHBhZ2VObyAqIHBhZ2VTaXplKVxuICAgICAgICAubGltaXQocGFnZVNpemUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdWx0czogcmVzcG9uc2UsXG4gICAgICAgIHBhZ2VObzogcmVzcG9uc2UubGVuZ3RoID09PSBwYWdlU2l6ZSA/IHBhZ2VObyArIDEgOiBwYWdlTm8sXG4gICAgICAgIGhhc01vcmU6IHJlc3BvbnNlLmxlbmd0aCA9PT0gcGFnZVNpemUgPyB0cnVlIDogZmFsc2UsXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gdGFnczogYXN5bmMgKF8sIF9fLCB7IHVzZXIgfSkgPT4ge1xuICAgIC8vICAgLy8gaWYgKCF1c2VyKSB7XG4gICAgLy8gICAvLyAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcignTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudCcpO1xuICAgIC8vICAgLy8gfVxuICAgIC8vICAgY29uc3QgbW9kZWwgPSBnZXRDb2xsZWN0aW9uKDIxMCwgcG9zdFRhZ0NvbGxlY3Rpb24sIHBvc3RUYWdTY2hlbWEpO1xuICAgIC8vICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmQoe30pO1xuICAgIC8vIH0sXG4gIH0sXG5cbiAgUG9zdDoge1xuICAgIHRhZ3M6IHtcbiAgICAgIHJlc29sdmU6IGFzeW5jIChwYXJlbnQsIF9hcmdzLCB7IGFzc2V0LCB1c2VyIH0sIGluZm8pID0+IHtcbiAgICAgICAgaWYgKCFhc3NldCB8fCAhdXNlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihcbiAgICAgICAgICAgIFwiTm90IGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoaXMgY29udGVudFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IGdldENvbGxlY3Rpb24oYXNzZXQsIHBvc3RUYWdDb2xsZWN0aW9uLCBwb3N0VGFnU2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG1vZGVsLmZpbmQoeyBwb3N0SWQ6IHBhcmVudC5pZCB9KTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyB0eXBlRGVmcywgcmVzb2x2ZXJzIH07XG4iLCJ2YXIgbW9uZ29vc2UgPSByZXF1aXJlKCdtb25nb29zZScpO1xuXG5jb25zdCBTY2hlbWEgPSBtb25nb29zZS5TY2hlbWE7XG5jb25zdCBwb3N0VGFnU2NoZW1hID0gbmV3IFNjaGVtYShcbiAge1xuICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgcG9zdElkOiB7IHR5cGU6IFN0cmluZyB9LFxuICB9LFxuICB7IHRpbWVzdGFtcHM6IHRydWUgfVxuKTtcblxuY29uc3QgcG9zdFRhZ0NvbGxlY3Rpb24gPSAncG9zdC50YWcnO1xuXG4vLyBtb2R1bGUuZXhwb3J0cyA9IG1vbmdvb3NlLm1vZGVsKCdib29rbWFya3MnLCBwb3N0U2NoZW1hKTtcbm1vZHVsZS5leHBvcnRzID0geyBwb3N0VGFnU2NoZW1hLCBwb3N0VGFnQ29sbGVjdGlvbiB9O1xuIiwidmFyIG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTtcblxuY29uc3QgU2NoZW1hID0gbW9uZ29vc2UuU2NoZW1hO1xuY29uc3Qgc2VxdWVuY2VTY2hlbWEgPSBuZXcgU2NoZW1hKFxuICB7XG4gICAgZmllbGQ6IHsgdHlwZTogU3RyaW5nIH0sXG4gICAgY29udGV4dDogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBuZXh0dmFsOiB7IHR5cGU6IE51bWJlciB9LFxuICAgIGZhY3RvcjogeyB0eXBlOiBOdW1iZXIgfSxcbiAgfSxcbiAgeyB0aW1lc3RhbXBzOiB0cnVlIH1cbik7XG5cbmNvbnN0IHNlcXVlbmNlQ29sbGVjdGlvbiA9ICdzZXF1ZW5jZSc7XG5cbm1vZHVsZS5leHBvcnRzID0geyBzZXF1ZW5jZVNjaGVtYSwgc2VxdWVuY2VDb2xsZWN0aW9uIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhaWh1YlwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJhcG9sbG8tc2VydmVyLWV4cHJlc3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXhpb3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmNyeXB0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZGF0ZS1mbnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZWpzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImV4cHJlc3NcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZ3JhcGhxbFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJncmFwaHFsLXR5cGUtanNvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJoYW5kbGViYXJzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImpzb253ZWJ0b2tlblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJqc3ppcFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibW9tZW50XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm1vbmdvb3NlXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm11bHRlclwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXBhcGFyc2VcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidGVzc2VyYWN0LmpzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV1aWRcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdGlmIChjYWNoZWRNb2R1bGUuZXJyb3IgIT09IHVuZGVmaW5lZCkgdGhyb3cgY2FjaGVkTW9kdWxlLmVycm9yO1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHR0cnkge1xuXHRcdHZhciBleGVjT3B0aW9ucyA9IHsgaWQ6IG1vZHVsZUlkLCBtb2R1bGU6IG1vZHVsZSwgZmFjdG9yeTogX193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0sIHJlcXVpcmU6IF9fd2VicGFja19yZXF1aXJlX18gfTtcblx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKSB7IGhhbmRsZXIoZXhlY09wdGlvbnMpOyB9KTtcblx0XHRtb2R1bGUgPSBleGVjT3B0aW9ucy5tb2R1bGU7XG5cdFx0ZXhlY09wdGlvbnMuZmFjdG9yeS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBleGVjT3B0aW9ucy5yZXF1aXJlKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0bW9kdWxlLmVycm9yID0gZTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbl9fd2VicGFja19yZXF1aXJlX18uYyA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfXztcblxuLy8gZXhwb3NlIHRoZSBtb2R1bGUgZXhlY3V0aW9uIGludGVyY2VwdG9yXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBbXTtcblxuIiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYWxsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5odSA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gXCJcIiArIGNodW5rSWQgKyBcIi5cIiArIF9fd2VicGFja19yZXF1aXJlX18uaCgpICsgXCIuaG90LXVwZGF0ZS5qc1wiO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckYgPSAoKSA9PiAoXCJtYWluLlwiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5oKCkgKyBcIi5ob3QtdXBkYXRlLmpzb25cIik7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5oID0gKCkgPT4gKFwiOGZlMzJhMjA2MWQ5NjMyNWI2NjVcIikiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwidmFyIGN1cnJlbnRNb2R1bGVEYXRhID0ge307XG52YXIgaW5zdGFsbGVkTW9kdWxlcyA9IF9fd2VicGFja19yZXF1aXJlX18uYztcblxuLy8gbW9kdWxlIGFuZCByZXF1aXJlIGNyZWF0aW9uXG52YXIgY3VycmVudENoaWxkTW9kdWxlO1xudmFyIGN1cnJlbnRQYXJlbnRzID0gW107XG5cbi8vIHN0YXR1c1xudmFyIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycyA9IFtdO1xudmFyIGN1cnJlbnRTdGF0dXMgPSBcImlkbGVcIjtcblxuLy8gd2hpbGUgZG93bmxvYWRpbmdcbnZhciBibG9ja2luZ1Byb21pc2VzID0gMDtcbnZhciBibG9ja2luZ1Byb21pc2VzV2FpdGluZyA9IFtdO1xuXG4vLyBUaGUgdXBkYXRlIGluZm9cbnZhciBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycztcbnZhciBxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXM7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yRCA9IGN1cnJlbnRNb2R1bGVEYXRhO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmkucHVzaChmdW5jdGlvbiAob3B0aW9ucykge1xuXHR2YXIgbW9kdWxlID0gb3B0aW9ucy5tb2R1bGU7XG5cdHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShvcHRpb25zLnJlcXVpcmUsIG9wdGlvbnMuaWQpO1xuXHRtb2R1bGUuaG90ID0gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG9wdGlvbnMuaWQsIG1vZHVsZSk7XG5cdG1vZHVsZS5wYXJlbnRzID0gY3VycmVudFBhcmVudHM7XG5cdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRvcHRpb25zLnJlcXVpcmUgPSByZXF1aXJlO1xufSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18uaG1yQyA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVpcmUocmVxdWlyZSwgbW9kdWxlSWQpIHtcblx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cdGlmICghbWUpIHJldHVybiByZXF1aXJlO1xuXHR2YXIgZm4gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuXHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG5cdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuXHRcdFx0XHR2YXIgcGFyZW50cyA9IGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cztcblx0XHRcdFx0aWYgKHBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG5cdFx0XHRcdFx0cGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG5cdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuXHRcdFx0XHRcdHJlcXVlc3QgK1xuXHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG5cdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdCk7XG5cdFx0XHRjdXJyZW50UGFyZW50cyA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVxdWlyZShyZXF1ZXN0KTtcblx0fTtcblx0dmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHJlcXVpcmVbbmFtZV07XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0cmVxdWlyZVtuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH07XG5cdGZvciAodmFyIG5hbWUgaW4gcmVxdWlyZSkge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVxdWlyZSwgbmFtZSkgJiYgbmFtZSAhPT0gXCJlXCIpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKG5hbWUpKTtcblx0XHR9XG5cdH1cblx0Zm4uZSA9IGZ1bmN0aW9uIChjaHVua0lkLCBmZXRjaFByaW9yaXR5KSB7XG5cdFx0cmV0dXJuIHRyYWNrQmxvY2tpbmdQcm9taXNlKHJlcXVpcmUuZShjaHVua0lkLCBmZXRjaFByaW9yaXR5KSk7XG5cdH07XG5cdHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTW9kdWxlSG90T2JqZWN0KG1vZHVsZUlkLCBtZSkge1xuXHR2YXIgX21haW4gPSBjdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkO1xuXHR2YXIgaG90ID0ge1xuXHRcdC8vIHByaXZhdGUgc3R1ZmZcblx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuXHRcdF9hY2NlcHRlZEVycm9ySGFuZGxlcnM6IHt9LFxuXHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG5cdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG5cdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG5cdFx0X3NlbGZJbnZhbGlkYXRlZDogZmFsc2UsXG5cdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG5cdFx0X21haW46IF9tYWluLFxuXHRcdF9yZXF1aXJlU2VsZjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFBhcmVudHMgPSBtZS5wYXJlbnRzLnNsaWNlKCk7XG5cdFx0XHRjdXJyZW50Q2hpbGRNb2R1bGUgPSBfbWFpbiA/IHVuZGVmaW5lZCA6IG1vZHVsZUlkO1xuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCk7XG5cdFx0fSxcblxuXHRcdC8vIE1vZHVsZSBBUElcblx0XHRhY3RpdmU6IHRydWUsXG5cdFx0YWNjZXB0OiBmdW5jdGlvbiAoZGVwLCBjYWxsYmFjaywgZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHRpZiAoZGVwID09PSB1bmRlZmluZWQpIGhvdC5fc2VsZkFjY2VwdGVkID0gdHJ1ZTtcblx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIikgaG90Ll9zZWxmQWNjZXB0ZWQgPSBkZXA7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWRFcnJvckhhbmRsZXJzW2RlcFtpXV0gPSBlcnJvckhhbmRsZXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRob3QuX2FjY2VwdGVkRXJyb3JIYW5kbGVyc1tkZXBdID0gZXJyb3JIYW5kbGVyO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVjbGluZTogZnVuY3Rpb24gKGRlcCkge1xuXHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG5cdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiICYmIGRlcCAhPT0gbnVsbClcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcblx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGRpc3Bvc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuXHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG5cdFx0fSxcblx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9LFxuXHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcblx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcblx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0fSxcblx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGlzLl9zZWxmSW52YWxpZGF0ZWQgPSB0cnVlO1xuXHRcdFx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgXCJpZGxlXCI6XG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0XHRcdG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVyc1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzZXRTdGF0dXMoXCJyZWFkeVwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1ySVtrZXldKFxuXHRcdFx0XHRcdFx0XHRtb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwcmVwYXJlXCI6XG5cdFx0XHRcdGNhc2UgXCJjaGVja1wiOlxuXHRcdFx0XHRjYXNlIFwiZGlzcG9zZVwiOlxuXHRcdFx0XHRjYXNlIFwiYXBwbHlcIjpcblx0XHRcdFx0XHQocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID0gcXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzIHx8IFtdKS5wdXNoKFxuXHRcdFx0XHRcdFx0bW9kdWxlSWRcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIGlnbm9yZSByZXF1ZXN0cyBpbiBlcnJvciBzdGF0ZXNcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gTWFuYWdlbWVudCBBUElcblx0XHRjaGVjazogaG90Q2hlY2ssXG5cdFx0YXBwbHk6IGhvdEFwcGx5LFxuXHRcdHN0YXR1czogZnVuY3Rpb24gKGwpIHtcblx0XHRcdGlmICghbCkgcmV0dXJuIGN1cnJlbnRTdGF0dXM7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHRyZWdpc3RlcmVkU3RhdHVzSGFuZGxlcnMucHVzaChsKTtcblx0XHR9LFxuXHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uIChsKSB7XG5cdFx0XHR2YXIgaWR4ID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG5cdFx0XHRpZiAoaWR4ID49IDApIHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcblx0XHR9LFxuXG5cdFx0Ly8gaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxuXHRcdGRhdGE6IGN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxuXHR9O1xuXHRjdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XG5cdHJldHVybiBob3Q7XG59XG5cbmZ1bmN0aW9uIHNldFN0YXR1cyhuZXdTdGF0dXMpIHtcblx0Y3VycmVudFN0YXR1cyA9IG5ld1N0YXR1cztcblx0dmFyIHJlc3VsdHMgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdGVyZWRTdGF0dXNIYW5kbGVycy5sZW5ndGg7IGkrKylcblx0XHRyZXN1bHRzW2ldID0gcmVnaXN0ZXJlZFN0YXR1c0hhbmRsZXJzW2ldLmNhbGwobnVsbCwgbmV3U3RhdHVzKTtcblxuXHRyZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbihmdW5jdGlvbiAoKSB7fSk7XG59XG5cbmZ1bmN0aW9uIHVuYmxvY2soKSB7XG5cdGlmICgtLWJsb2NraW5nUHJvbWlzZXMgPT09IDApIHtcblx0XHRzZXRTdGF0dXMoXCJyZWFkeVwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChibG9ja2luZ1Byb21pc2VzID09PSAwKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gYmxvY2tpbmdQcm9taXNlc1dhaXRpbmc7XG5cdFx0XHRcdGJsb2NraW5nUHJvbWlzZXNXYWl0aW5nID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGxpc3RbaV0oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHRyYWNrQmxvY2tpbmdQcm9taXNlKHByb21pc2UpIHtcblx0c3dpdGNoIChjdXJyZW50U3RhdHVzKSB7XG5cdFx0Y2FzZSBcInJlYWR5XCI6XG5cdFx0XHRzZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuXHRcdC8qIGZhbGx0aHJvdWdoICovXG5cdFx0Y2FzZSBcInByZXBhcmVcIjpcblx0XHRcdGJsb2NraW5nUHJvbWlzZXMrKztcblx0XHRcdHByb21pc2UudGhlbih1bmJsb2NrLCB1bmJsb2NrKTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0fVxufVxuXG5mdW5jdGlvbiB3YWl0Rm9yQmxvY2tpbmdQcm9taXNlcyhmbikge1xuXHRpZiAoYmxvY2tpbmdQcm9taXNlcyA9PT0gMCkgcmV0dXJuIGZuKCk7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRcdGJsb2NraW5nUHJvbWlzZXNXYWl0aW5nLnB1c2goZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVzb2x2ZShmbigpKTtcblx0XHR9KTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGhvdENoZWNrKGFwcGx5T25VcGRhdGUpIHtcblx0aWYgKGN1cnJlbnRTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiY2hlY2soKSBpcyBvbmx5IGFsbG93ZWQgaW4gaWRsZSBzdGF0dXNcIik7XG5cdH1cblx0cmV0dXJuIHNldFN0YXR1cyhcImNoZWNrXCIpXG5cdFx0LnRoZW4oX193ZWJwYWNrX3JlcXVpcmVfXy5obXJNKVxuXHRcdC50aGVuKGZ1bmN0aW9uICh1cGRhdGUpIHtcblx0XHRcdGlmICghdXBkYXRlKSB7XG5cdFx0XHRcdHJldHVybiBzZXRTdGF0dXMoYXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSA/IFwicmVhZHlcIiA6IFwiaWRsZVwiKS50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFN0YXR1cyhcInByZXBhcmVcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciB1cGRhdGVkTW9kdWxlcyA9IFtdO1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbChcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhfX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMpLnJlZHVjZShmdW5jdGlvbiAoXG5cdFx0XHRcdFx0XHRwcm9taXNlcyxcblx0XHRcdFx0XHRcdGtleVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJDW2tleV0oXG5cdFx0XHRcdFx0XHRcdHVwZGF0ZS5jLFxuXHRcdFx0XHRcdFx0XHR1cGRhdGUucixcblx0XHRcdFx0XHRcdFx0dXBkYXRlLm0sXG5cdFx0XHRcdFx0XHRcdHByb21pc2VzLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyxcblx0XHRcdFx0XHRcdFx0dXBkYXRlZE1vZHVsZXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZXM7XG5cdFx0XHRcdFx0fSwgW10pXG5cdFx0XHRcdCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHdhaXRGb3JCbG9ja2luZ1Byb21pc2VzKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdGlmIChhcHBseU9uVXBkYXRlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbnRlcm5hbEFwcGx5KGFwcGx5T25VcGRhdGUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHNldFN0YXR1cyhcInJlYWR5XCIpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdXBkYXRlZE1vZHVsZXM7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcbn1cblxuZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xuXHRpZiAoY3VycmVudFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcImFwcGx5KCkgaXMgb25seSBhbGxvd2VkIGluIHJlYWR5IHN0YXR1cyAoc3RhdGU6IFwiICtcblx0XHRcdFx0XHRjdXJyZW50U3RhdHVzICtcblx0XHRcdFx0XHRcIilcIlxuXHRcdFx0KTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxBcHBseShvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFwcGx5SW52YWxpZGF0ZWRNb2R1bGVzKCk7XG5cblx0dmFyIHJlc3VsdHMgPSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHRyZXR1cm4gaGFuZGxlcihvcHRpb25zKTtcblx0fSk7XG5cdGN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzID0gdW5kZWZpbmVkO1xuXG5cdHZhciBlcnJvcnMgPSByZXN1bHRzXG5cdFx0Lm1hcChmdW5jdGlvbiAocikge1xuXHRcdFx0cmV0dXJuIHIuZXJyb3I7XG5cdFx0fSlcblx0XHQuZmlsdGVyKEJvb2xlYW4pO1xuXG5cdGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuXHRcdHJldHVybiBzZXRTdGF0dXMoXCJhYm9ydFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdHRocm93IGVycm9yc1swXTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxuXHR2YXIgZGlzcG9zZVByb21pc2UgPSBzZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xuXG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5kaXNwb3NlKSByZXN1bHQuZGlzcG9zZSgpO1xuXHR9KTtcblxuXHQvLyBOb3cgaW4gXCJhcHBseVwiIHBoYXNlXG5cdHZhciBhcHBseVByb21pc2UgPSBzZXRTdGF0dXMoXCJhcHBseVwiKTtcblxuXHR2YXIgZXJyb3I7XG5cdHZhciByZXBvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRpZiAoIWVycm9yKSBlcnJvciA9IGVycjtcblx0fTtcblxuXHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW107XG5cdHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0aWYgKHJlc3VsdC5hcHBseSkge1xuXHRcdFx0dmFyIG1vZHVsZXMgPSByZXN1bHQuYXBwbHkocmVwb3J0RXJyb3IpO1xuXHRcdFx0aWYgKG1vZHVsZXMpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2gobW9kdWxlc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiBQcm9taXNlLmFsbChbZGlzcG9zZVByb21pc2UsIGFwcGx5UHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdC8vIGhhbmRsZSBlcnJvcnMgaW4gYWNjZXB0IGhhbmRsZXJzIGFuZCBzZWxmIGFjY2VwdGVkIG1vZHVsZSBsb2FkXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRyZXR1cm4gc2V0U3RhdHVzKFwiZmFpbFwiKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAocXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXJuYWxBcHBseShvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChsaXN0KSB7XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVJZCkge1xuXHRcdFx0XHRcdGlmIChsaXN0LmluZGV4T2YobW9kdWxlSWQpIDwgMCkgbGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNldFN0YXR1cyhcImlkbGVcIikudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gb3V0ZGF0ZWRNb2R1bGVzO1xuXHRcdH0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSB7XG5cdGlmIChxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMpIHtcblx0XHRpZiAoIWN1cnJlbnRVcGRhdGVBcHBseUhhbmRsZXJzKSBjdXJyZW50VXBkYXRlQXBwbHlIYW5kbGVycyA9IFtdO1xuXHRcdE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uaG1ySSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRxdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlSWQpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5obXJJW2tleV0oXG5cdFx0XHRcdFx0bW9kdWxlSWQsXG5cdFx0XHRcdFx0Y3VycmVudFVwZGF0ZUFwcGx5SGFuZGxlcnNcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyA9IHVuZGVmaW5lZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBjaHVua3Ncbi8vIFwiMVwiIG1lYW5zIFwibG9hZGVkXCIsIG90aGVyd2lzZSBub3QgbG9hZGVkIHlldFxudmFyIGluc3RhbGxlZENodW5rcyA9IF9fd2VicGFja19yZXF1aXJlX18uaG1yU19yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5obXJTX3JlcXVpcmUgfHwge1xuXHRcIm1haW5cIjogMVxufTtcblxuLy8gbm8gb24gY2h1bmtzIGxvYWRlZFxuXG4vLyBubyBjaHVuayBpbnN0YWxsIGZ1bmN0aW9uIG5lZWRlZFxuXG4vLyBubyBjaHVuayBsb2FkaW5nXG5cbi8vIG5vIGV4dGVybmFsIGluc3RhbGwgY2h1bmtcblxuZnVuY3Rpb24gbG9hZFVwZGF0ZUNodW5rKGNodW5rSWQsIHVwZGF0ZWRNb2R1bGVzTGlzdCkge1xuXHR2YXIgdXBkYXRlID0gcmVxdWlyZShcIi4vXCIgKyBfX3dlYnBhY2tfcmVxdWlyZV9fLmh1KGNodW5rSWQpKTtcblx0dmFyIHVwZGF0ZWRNb2R1bGVzID0gdXBkYXRlLm1vZHVsZXM7XG5cdHZhciBydW50aW1lID0gdXBkYXRlLnJ1bnRpbWU7XG5cdGZvcih2YXIgbW9kdWxlSWQgaW4gdXBkYXRlZE1vZHVsZXMpIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8odXBkYXRlZE1vZHVsZXMsIG1vZHVsZUlkKSkge1xuXHRcdFx0Y3VycmVudFVwZGF0ZVttb2R1bGVJZF0gPSB1cGRhdGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHRpZih1cGRhdGVkTW9kdWxlc0xpc3QpIHVwZGF0ZWRNb2R1bGVzTGlzdC5wdXNoKG1vZHVsZUlkKTtcblx0XHR9XG5cdH1cblx0aWYocnVudGltZSkgY3VycmVudFVwZGF0ZVJ1bnRpbWUucHVzaChydW50aW1lKTtcbn1cblxudmFyIGN1cnJlbnRVcGRhdGVDaHVua3M7XG52YXIgY3VycmVudFVwZGF0ZTtcbnZhciBjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcztcbnZhciBjdXJyZW50VXBkYXRlUnVudGltZTtcbmZ1bmN0aW9uIGFwcGx5SGFuZGxlcihvcHRpb25zKSB7XG5cdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmYpIGRlbGV0ZSBfX3dlYnBhY2tfcmVxdWlyZV9fLmYucmVxdWlyZUhtcjtcblx0Y3VycmVudFVwZGF0ZUNodW5rcyA9IHVuZGVmaW5lZDtcblx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRNb2R1bGVFZmZlY3RzKHVwZGF0ZU1vZHVsZUlkKSB7XG5cdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFt1cGRhdGVNb2R1bGVJZF07XG5cdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG5cblx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMubWFwKGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2hhaW46IFtpZF0sXG5cdFx0XHRcdGlkOiBpZFxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xuXHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xuXHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xuXHRcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18uY1ttb2R1bGVJZF07XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFtb2R1bGUgfHxcblx0XHRcdFx0KG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCAmJiAhbW9kdWxlLmhvdC5fc2VsZkludmFsaWRhdGVkKVxuXHRcdFx0KVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdGlmIChtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0eXBlOiBcInNlbGYtZGVjbGluZWRcIixcblx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9kdWxlLmhvdC5fbWFpbikge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxuXHRcdFx0XHRcdGNoYWluOiBjaGFpbixcblx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbcGFyZW50SWRdO1xuXHRcdFx0XHRpZiAoIXBhcmVudCkgY29udGludWU7XG5cdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxuXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcblx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcblx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSAhPT0gLTEpIGNvbnRpbnVlO1xuXHRcdFx0XHRpZiAocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG5cdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG5cdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcblx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG5cdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcblx0XHRcdFx0cXVldWUucHVzaCh7XG5cdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcblx0XHRcdFx0XHRpZDogcGFyZW50SWRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcblx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcblx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxuXHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gYltpXTtcblx0XHRcdGlmIChhLmluZGV4T2YoaXRlbSkgPT09IC0xKSBhLnB1c2goaXRlbSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcblx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxuXHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcblx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuXHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xuXG5cdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUobW9kdWxlKSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyBtb2R1bGUuaWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCJcblx0XHQpO1xuXHR9O1xuXG5cdGZvciAodmFyIG1vZHVsZUlkIGluIGN1cnJlbnRVcGRhdGUpIHtcblx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGUsIG1vZHVsZUlkKSkge1xuXHRcdFx0dmFyIG5ld01vZHVsZUZhY3RvcnkgPSBjdXJyZW50VXBkYXRlW21vZHVsZUlkXTtcblx0XHRcdC8qKiBAdHlwZSB7VE9ET30gKi9cblx0XHRcdHZhciByZXN1bHQgPSBuZXdNb2R1bGVGYWN0b3J5XG5cdFx0XHRcdD8gZ2V0QWZmZWN0ZWRNb2R1bGVFZmZlY3RzKG1vZHVsZUlkKVxuXHRcdFx0XHQ6IHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiZGlzcG9zZWRcIixcblx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuXHRcdFx0XHRcdH07XG5cdFx0XHQvKiogQHR5cGUge0Vycm9yfGZhbHNlfSAqL1xuXHRcdFx0dmFyIGFib3J0RXJyb3IgPSBmYWxzZTtcblx0XHRcdHZhciBkb0FwcGx5ID0gZmFsc2U7XG5cdFx0XHR2YXIgZG9EaXNwb3NlID0gZmFsc2U7XG5cdFx0XHR2YXIgY2hhaW5JbmZvID0gXCJcIjtcblx0XHRcdGlmIChyZXN1bHQuY2hhaW4pIHtcblx0XHRcdFx0Y2hhaW5JbmZvID0gXCJcXG5VcGRhdGUgcHJvcGFnYXRpb246IFwiICsgcmVzdWx0LmNoYWluLmpvaW4oXCIgLT4gXCIpO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChyZXN1bHQudHlwZSkge1xuXHRcdFx0XHRjYXNlIFwic2VsZi1kZWNsaW5lZFwiOlxuXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcblx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgK1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG5cdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZGVjbGluZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG5cdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBkZWNsaW5lZCBkZXBlbmRlbmN5OiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcblx0XHRcdFx0XHRcdFx0XHRcIiBpbiBcIiArXG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0LnBhcmVudElkICtcblx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJ1bmFjY2VwdGVkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25VbmFjY2VwdGVkKSBvcHRpb25zLm9uVW5hY2NlcHRlZChyZXN1bHQpO1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxuXHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2UgXCIgKyBtb2R1bGVJZCArIFwiIGlzIG5vdCBhY2NlcHRlZFwiICsgY2hhaW5JbmZvXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiYWNjZXB0ZWRcIjpcblx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkFjY2VwdGVkKSBvcHRpb25zLm9uQWNjZXB0ZWQocmVzdWx0KTtcblx0XHRcdFx0XHRkb0FwcGx5ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRpc3Bvc2VkXCI6XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EaXNwb3NlZCkgb3B0aW9ucy5vbkRpc3Bvc2VkKHJlc3VsdCk7XG5cdFx0XHRcdFx0ZG9EaXNwb3NlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4Y2VwdGlvbiB0eXBlIFwiICsgcmVzdWx0LnR5cGUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFib3J0RXJyb3IpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRlcnJvcjogYWJvcnRFcnJvclxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRvQXBwbHkpIHtcblx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBuZXdNb2R1bGVGYWN0b3J5O1xuXHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIHJlc3VsdC5vdXRkYXRlZE1vZHVsZXMpO1xuXHRcdFx0XHRmb3IgKG1vZHVsZUlkIGluIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcykge1xuXHRcdFx0XHRcdGlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLm8ocmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRcdGlmICghb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKVxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0gPSBbXTtcblx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KFxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0sXG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoZG9EaXNwb3NlKSB7XG5cdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgW3Jlc3VsdC5tb2R1bGVJZF0pO1xuXHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IHdhcm5VbmV4cGVjdGVkUmVxdWlyZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Y3VycmVudFVwZGF0ZSA9IHVuZGVmaW5lZDtcblxuXHQvLyBTdG9yZSBzZWxmIGFjY2VwdGVkIG91dGRhdGVkIG1vZHVsZXMgdG8gcmVxdWlyZSB0aGVtIGxhdGVyIGJ5IHRoZSBtb2R1bGUgc3lzdGVtXG5cdHZhciBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMgPSBbXTtcblx0Zm9yICh2YXIgaiA9IDA7IGogPCBvdXRkYXRlZE1vZHVsZXMubGVuZ3RoOyBqKyspIHtcblx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tqXTtcblx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdGlmIChcblx0XHRcdG1vZHVsZSAmJlxuXHRcdFx0KG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCB8fCBtb2R1bGUuaG90Ll9tYWluKSAmJlxuXHRcdFx0Ly8gcmVtb3ZlZCBzZWxmLWFjY2VwdGVkIG1vZHVsZXMgc2hvdWxkIG5vdCBiZSByZXF1aXJlZFxuXHRcdFx0YXBwbGllZFVwZGF0ZVtvdXRkYXRlZE1vZHVsZUlkXSAhPT0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlICYmXG5cdFx0XHQvLyB3aGVuIGNhbGxlZCBpbnZhbGlkYXRlIHNlbGYtYWNjZXB0aW5nIGlzIG5vdCBwb3NzaWJsZVxuXHRcdFx0IW1vZHVsZS5ob3QuX3NlbGZJbnZhbGlkYXRlZFxuXHRcdCkge1xuXHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xuXHRcdFx0XHRtb2R1bGU6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdHJlcXVpcmU6IG1vZHVsZS5ob3QuX3JlcXVpcmVTZWxmLFxuXHRcdFx0XHRlcnJvckhhbmRsZXI6IG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzO1xuXG5cdHJldHVybiB7XG5cdFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmtJZCkge1xuXHRcdFx0XHRkZWxldGUgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuXHRcdFx0fSk7XG5cdFx0XHRjdXJyZW50VXBkYXRlUmVtb3ZlZENodW5rcyA9IHVuZGVmaW5lZDtcblxuXHRcdFx0dmFyIGlkeDtcblx0XHRcdHZhciBxdWV1ZSA9IG91dGRhdGVkTW9kdWxlcy5zbGljZSgpO1xuXHRcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWUucG9wKCk7XG5cdFx0XHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdO1xuXHRcdFx0XHRpZiAoIW1vZHVsZSkgY29udGludWU7XG5cblx0XHRcdFx0dmFyIGRhdGEgPSB7fTtcblxuXHRcdFx0XHQvLyBDYWxsIGRpc3Bvc2UgaGFuZGxlcnNcblx0XHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IGRpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGRpc3Bvc2VIYW5kbGVyc1tqXS5jYWxsKG51bGwsIGRhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uaG1yRFttb2R1bGVJZF0gPSBkYXRhO1xuXG5cdFx0XHRcdC8vIGRpc2FibGUgbW9kdWxlICh0aGlzIGRpc2FibGVzIHJlcXVpcmVzIGZyb20gdGhpcyBtb2R1bGUpXG5cdFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXG5cdFx0XHRcdGRlbGV0ZSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdO1xuXG5cdFx0XHRcdC8vIHdoZW4gZGlzcG9zaW5nIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBkaXNwb3NlIGhhbmRsZXJcblx0XHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcblxuXHRcdFx0XHQvLyByZW1vdmUgXCJwYXJlbnRzXCIgcmVmZXJlbmNlcyBmcm9tIGFsbCBjaGlsZHJlblxuXHRcdFx0XHRmb3IgKGogPSAwOyBqIDwgbW9kdWxlLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW21vZHVsZS5jaGlsZHJlbltqXV07XG5cdFx0XHRcdFx0aWYgKCFjaGlsZCkgY29udGludWU7XG5cdFx0XHRcdFx0aWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcblx0XHRcdFx0XHRpZiAoaWR4ID49IDApIHtcblx0XHRcdFx0XHRcdGNoaWxkLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIHJlbW92ZSBvdXRkYXRlZCBkZXBlbmRlbmN5IGZyb20gbW9kdWxlIGNoaWxkcmVuXG5cdFx0XHR2YXIgZGVwZW5kZW5jeTtcblx0XHRcdGZvciAodmFyIG91dGRhdGVkTW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhvdXRkYXRlZERlcGVuZGVuY2llcywgb3V0ZGF0ZWRNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHRtb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuXHRcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPVxuXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1tvdXRkYXRlZE1vZHVsZUlkXTtcblx0XHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbal07XG5cdFx0XHRcdFx0XHRcdGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xuXHRcdFx0XHRcdFx0XHRpZiAoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGFwcGx5OiBmdW5jdGlvbiAocmVwb3J0RXJyb3IpIHtcblx0XHRcdC8vIGluc2VydCBuZXcgY29kZVxuXHRcdFx0Zm9yICh2YXIgdXBkYXRlTW9kdWxlSWQgaW4gYXBwbGllZFVwZGF0ZSkge1xuXHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGFwcGxpZWRVcGRhdGUsIHVwZGF0ZU1vZHVsZUlkKSkge1xuXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVt1cGRhdGVNb2R1bGVJZF0gPSBhcHBsaWVkVXBkYXRlW3VwZGF0ZU1vZHVsZUlkXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBydW4gbmV3IHJ1bnRpbWUgbW9kdWxlc1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjdXJyZW50VXBkYXRlUnVudGltZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlUnVudGltZVtpXShfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcblx0XHRcdGZvciAodmFyIG91dGRhdGVkTW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcblx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubyhvdXRkYXRlZERlcGVuZGVuY2llcywgb3V0ZGF0ZWRNb2R1bGVJZCkpIHtcblx0XHRcdFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXy5jW291dGRhdGVkTW9kdWxlSWRdO1xuXHRcdFx0XHRcdGlmIChtb2R1bGUpIHtcblx0XHRcdFx0XHRcdG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID1cblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbb3V0ZGF0ZWRNb2R1bGVJZF07XG5cdFx0XHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gW107XG5cdFx0XHRcdFx0XHR2YXIgZXJyb3JIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xuXHRcdFx0XHRcdFx0XHR2YXIgYWNjZXB0Q2FsbGJhY2sgPVxuXHRcdFx0XHRcdFx0XHRcdG1vZHVsZS5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcGVuZGVuY3ldO1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3JIYW5kbGVyID1cblx0XHRcdFx0XHRcdFx0XHRtb2R1bGUuaG90Ll9hY2NlcHRlZEVycm9ySGFuZGxlcnNbZGVwZW5kZW5jeV07XG5cdFx0XHRcdFx0XHRcdGlmIChhY2NlcHRDYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjYWxsYmFja3MuaW5kZXhPZihhY2NlcHRDYWxsYmFjaykgIT09IC0xKSBjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChhY2NlcHRDYWxsYmFjayk7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3JIYW5kbGVycy5wdXNoKGVycm9ySGFuZGxlcik7XG5cdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzLnB1c2goZGVwZW5kZW5jeSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZvciAodmFyIGsgPSAwOyBrIDwgY2FsbGJhY2tzLmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2tzW2tdLmNhbGwobnVsbCwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGVycm9ySGFuZGxlcnNba10gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyc1trXShlcnIsIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZXBlbmRlbmN5SWQ6IGRlcGVuZGVuY2llc0ZvckNhbGxiYWNrc1trXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJhY2NlcHQtZXJyb3ItaGFuZGxlci1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogb3V0ZGF0ZWRNb2R1bGVJZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogZGVwZW5kZW5jaWVzRm9yQ2FsbGJhY2tzW2tdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycjIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycjIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvcmVkXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG91dGRhdGVkTW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBkZXBlbmRlbmNpZXNGb3JDYWxsYmFja3Nba10sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXG5cdFx0XHRmb3IgKHZhciBvID0gMDsgbyA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IG8rKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlc1tvXTtcblx0XHRcdFx0dmFyIG1vZHVsZUlkID0gaXRlbS5tb2R1bGU7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aXRlbS5yZXF1aXJlKG1vZHVsZUlkKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBpdGVtLmVycm9ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRpdGVtLmVycm9ySGFuZGxlcihlcnIsIHtcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlOiBfX3dlYnBhY2tfcmVxdWlyZV9fLmNbbW9kdWxlSWRdXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLm9uRXJyb3JlZCh7XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yLWhhbmRsZXItZXJyb3JlZFwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVycjEsXG5cdFx0XHRcdFx0XHRcdFx0XHRvcmlnaW5hbEVycm9yOiBlcnJcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRXJyb3JlZCkge1xuXHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycjEpO1xuXHRcdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtYWNjZXB0LWVycm9yZWRcIixcblx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlcG9ydEVycm9yKGVycik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvdXRkYXRlZE1vZHVsZXM7XG5cdFx0fVxuXHR9O1xufVxuX193ZWJwYWNrX3JlcXVpcmVfXy5obXJJLnJlcXVpcmUgPSBmdW5jdGlvbiAobW9kdWxlSWQsIGFwcGx5SGFuZGxlcnMpIHtcblx0aWYgKCFjdXJyZW50VXBkYXRlKSB7XG5cdFx0Y3VycmVudFVwZGF0ZSA9IHt9O1xuXHRcdGN1cnJlbnRVcGRhdGVSdW50aW1lID0gW107XG5cdFx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSBbXTtcblx0XHRhcHBseUhhbmRsZXJzLnB1c2goYXBwbHlIYW5kbGVyKTtcblx0fVxuXHRpZiAoIV9fd2VicGFja19yZXF1aXJlX18ubyhjdXJyZW50VXBkYXRlLCBtb2R1bGVJZCkpIHtcblx0XHRjdXJyZW50VXBkYXRlW21vZHVsZUlkXSA9IF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF07XG5cdH1cbn07XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtckMucmVxdWlyZSA9IGZ1bmN0aW9uIChcblx0Y2h1bmtJZHMsXG5cdHJlbW92ZWRDaHVua3MsXG5cdHJlbW92ZWRNb2R1bGVzLFxuXHRwcm9taXNlcyxcblx0YXBwbHlIYW5kbGVycyxcblx0dXBkYXRlZE1vZHVsZXNMaXN0XG4pIHtcblx0YXBwbHlIYW5kbGVycy5wdXNoKGFwcGx5SGFuZGxlcik7XG5cdGN1cnJlbnRVcGRhdGVDaHVua3MgPSB7fTtcblx0Y3VycmVudFVwZGF0ZVJlbW92ZWRDaHVua3MgPSByZW1vdmVkQ2h1bmtzO1xuXHRjdXJyZW50VXBkYXRlID0gcmVtb3ZlZE1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuXHRcdG9ialtrZXldID0gZmFsc2U7XG5cdFx0cmV0dXJuIG9iajtcblx0fSwge30pO1xuXHRjdXJyZW50VXBkYXRlUnVudGltZSA9IFtdO1xuXHRjaHVua0lkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaHVua0lkKSB7XG5cdFx0aWYgKFxuXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiZcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSAhPT0gdW5kZWZpbmVkXG5cdFx0KSB7XG5cdFx0XHRwcm9taXNlcy5wdXNoKGxvYWRVcGRhdGVDaHVuayhjaHVua0lkLCB1cGRhdGVkTW9kdWxlc0xpc3QpKTtcblx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3NbY2h1bmtJZF0gPSB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gZmFsc2U7XG5cdFx0fVxuXHR9KTtcblx0aWYgKF9fd2VicGFja19yZXF1aXJlX18uZikge1xuXHRcdF9fd2VicGFja19yZXF1aXJlX18uZi5yZXF1aXJlSG1yID0gZnVuY3Rpb24gKGNodW5rSWQsIHByb21pc2VzKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGN1cnJlbnRVcGRhdGVDaHVua3MgJiZcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vKGN1cnJlbnRVcGRhdGVDaHVua3MsIGNodW5rSWQpICYmXG5cdFx0XHRcdCFjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdXG5cdFx0XHQpIHtcblx0XHRcdFx0cHJvbWlzZXMucHVzaChsb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkpO1xuXHRcdFx0XHRjdXJyZW50VXBkYXRlQ2h1bmtzW2NodW5rSWRdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmhtck0gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHJlcXVpcmUoXCIuL1wiICsgX193ZWJwYWNrX3JlcXVpcmVfXy5obXJGKCkpO1xuXHR9KVsnY2F0Y2gnXShmdW5jdGlvbihlcnIpIHsgaWYoZXJyLmNvZGUgIT09ICdNT0RVTEVfTk9UX0ZPVU5EJykgdGhyb3cgZXJyOyB9KTtcbn0iLCIiLCIvLyBtb2R1bGUgY2FjaGUgYXJlIHVzZWQgc28gZW50cnkgaW5saW5pbmcgaXMgZGlzYWJsZWRcbi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L3BvbGwuanM/MTAwMFwiKTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL21haW4udHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=